

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[19:31:28] Loaded 10 rules                                                                                                                                                                             tasks.py:119
[12/08/24 19:31:28] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main)             subprocess.py:41
[12/08/24 19:31:30] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_31_28_877Z-debug-0.log                                                              
                    INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main)    subprocess.py:41
[12/08/24 19:34:10] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_31_30_606Z-debug-0.log                                                              
[12/08/24 19:34:11] INFO     CryticCompile: Problem executing hardhat: npm warn exec The following package was not found and will be installed: hardhat@2.22.17                                      hardhat.py:327
                             npm error Invalid Version:                                                                                                                                                            
                             npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_34_10_388Z-debug-0.log                                                                      
                                                                                                                                                                                                                   
                    INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main)   subprocess.py:41
[12/08/24 19:34:12] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_34_11_671Z-debug-0.log                                                              
[19:34:12] Traceback (most recent call last):                                                                                                                                                          tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                     
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                    
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                    
               self._compile(**kwargs)                                                                                                                                                                             
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                    
               self._platform.compile(self, **kwargs)                                                                                                                                                              
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 183, in compile                                                   
               hardhat_like_parsing(crytic_compile, self._target, build_directory, hardhat_working_dir)                                                                                                            
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 52, in hardhat_like_parsing                                       
               raise InvalidCompilation(txt)                                                                                                                                                                       
           crytic_compile.platform.exceptions.InvalidCompilation: Compilation failed. Can you run build command?                                                                                                   
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/artifacts/build-info is not a directory.                                                       
                                                                                                                                                                                                                   
           During handling of the above exception, another exception occurred:                                                                                                                                     
                                                                                                                                                                                                                   
           Traceback (most recent call last):                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                         
               falcon_instance = compile_project(source_dir)                                                                                                                                                       
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                    
               return falcon.Falcon(abs_path)                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                     
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                               
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                     
           Compilation failed. Can you run build command?                                                                                                                                                          
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/artifacts/build-info is not a directory.                                                       
                                                                                                                                                                                                                   
           Compile failed.                                                                                                                                                                             tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                  tasks.py:128
[12/08/24 19:34:14] INFO     antlr4helper.callgraph: In whitelist: Ownable.transferOwnership(address) returns()                                                                                     callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: ERC20.decreaseAllowance(address,uint) returns(bool)                                                                              callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: ERC20._transfer(address,address,uint) returns()                                                                                  callgraph.py:21
                    INFO     antlr4helper.callgraph: In whitelist: Ownable.transferOwnership(address) returns()                                                                                     callgraph.py:21
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│   function migrate(                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     LimboAddTokenToBehodlerPowerLike power,                                                                                                                                                                     │
│     CrossingParameters memory crossingParams,                                                                                                                                                                   │
│     CrossingConfig memory crossingConfig,                                                                                                                                                                       │
│     FlanLike flan,                                                                                                                                                                                              │
│     uint256 RectangleOfFairness,                                                                                                                                                                                │
│     Soul storage soul                                                                                                                                                                                           │
│   ) external returns (uint256, uint256) {                                                                                                                                                                       │
│     power.parameterize(token, crossingParams.burnable);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     //invoke Angband execute on power that migrates token type to Behodler                                                                                                                                      │
│     uint256 tokenBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│     IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);                                                                                                                                 │
│     AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));                                                                                                                     │
│                                                                                                                                                                                                                 │
│     uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));                                                                                                                      │
│                                                                                                                                                                                                                 │
│     uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;                                                                                              │
│                                                                                                                                                                                                                 │
│     //for top up or exotic high value migrations.                                                                                                                                                               │
│     if (scxMinted <= adjustedRectangle) {                                                                                                                                                                       │
│       adjustedRectangle = scxMinted / 2;                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //burn SCX - rectangle                                                                                                                                                                                      │
│     uint256 excessSCX = scxMinted - adjustedRectangle;                                                                                                                                                          │
│     require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //use remaining scx to buy flan and pool it on an external AMM                                                                                                                                              │
│     IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);                                                                                                                      │
│     uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     //reward caller and update soul state                                                                                                                                                                       │
│     require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");                                                                                                                             │
│     soul.state = SoulState.crossedOver;                                                                                                                                                                         │
│     return (tokenBalance, lpMinted);                                                                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function updateSoul(address token, Soul storage soul) internal {                                                                                                                                              │
│     require(soul.soulType != SoulType.uninitialized, "E1");                                                                                                                                                     │
│     uint256 finalTimeStamp = block.timestamp;                                                                                                                                                                   │
│     if (soul.state != SoulState.staking) {                                                                                                                                                                      │
│       finalTimeStamp = tokenCrossingParameters[latestIndex].stakingEndsTimestamp;                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     uint256 balance = IERC20(token).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (balance > 0) {                                                                                                                                                                                          │
│       uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;                                                                                                                    │
│                                                                                                                                                                                                                 │
│       soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);                                                                                                            │
│     }                                                                                                                                                                                                           │
│     soul.lastRewardTimestamp = finalTimeStamp;                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _unstake(                                                                                                                                                                                            │
│     address token,                                                                                                                                                                                              │
│     uint256 amount,                                                                                                                                                                                             │
│     address unstaker,                                                                                                                                                                                           │
│     address holder                                                                                                                                                                                              │
│   ) internal {                                                                                                                                                                                                  │
│     if (unstaker != holder) {                                                                                                                                                                                   │
│       unstakeApproval -= amount;                                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     Soul storage soul = currentSoul(token);                                                                                                                                                                     │
│     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");                                                                                                                      │
│     updateSoul(token, soul);                                                                                                                                                                                    │
│     User storage user = userInfo[latestIndex];                                                                                                                                                                  │
│     require(user.stakedAmount >= amount, "E4");                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = getPending(user, soul);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (pending > 0 && amount > 0) {                                                                                                                                                                            │
│       user.stakedAmount = user.stakedAmount - amount;                                                                                                                                                           │
│       IERC20(token).safeTransfer(address(unstaker), amount);                                                                                                                                                    │
│       rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);                                                                                                                                  │
│       emit Unstaked(unstaker, token, amount);                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function updateSoul(address token, Soul storage soul) internal {                                                                                                                                              │
│     require(soul.soulType != SoulType.uninitialized, "E1");                                                                                                                                                     │
│     uint256 finalTimeStamp = block.timestamp;                                                                                                                                                                   │
│     if (soul.state != SoulState.staking) {                                                                                                                                                                      │
│       finalTimeStamp = tokenCrossingParameters[latestIndex].stakingEndsTimestamp;                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     uint256 balance = IERC20(token).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (balance > 0) {                                                                                                                                                                                          │
│       uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;                                                                                                                    │
│                                                                                                                                                                                                                 │
│       soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);                                                                                                            │
│     }                                                                                                                                                                                                           │
│     soul.lastRewardTimestamp = finalTimeStamp;                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function stake(address token, uint256 amount) public enabled {                                                                                                                                                │
│     Soul storage soul = currentSoul(token);                                                                                                                                                                     │
│     require(soul.state == SoulState.staking, "E2");                                                                                                                                                             │
│     updateSoul(token, soul);                                                                                                                                                                                    │
│     uint256 currentIndex = latestIndex;                                                                                                                                                                         │
│     User storage user = userInfo;                                                                                                                                                                               │
│     if (amount > 0) {                                                                                                                                                                                           │
│       //dish out accumulated rewards.                                                                                                                                                                           │
│       uint256 pending = getPending(user, soul);                                                                                                                                                                 │
│       if (pending > 0) {                                                                                                                                                                                        │
│         Flan.mint(msg.sender, pending);                                                                                                                                                                         │
│       }                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│       //Balance checking accounts for FOT discrepencies                                                                                                                                                         │
│       uint256 oldBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│       IERC20(token).safeTransferFrom(msg.sender, address(this), amount);                                                                                                                                        │
│       uint256 newBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens                                                                                         │
│       if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {                                                                                                                         │
│         soul.state = SoulState.waitingToCross;                                                                                                                                                                  │
│         tokenCrossingParameters[latestIndex].stakingEndsTimestamp = block.timestamp;                                                                                                                            │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;                                                                                                                                │
│     emit Staked(msg.sender, token, user.stakedAmount);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function updateSoul(address token, Soul storage soul) internal {                                                                                                                                              │
│     require(soul.soulType != SoulType.uninitialized, "E1");                                                                                                                                                     │
│     uint256 finalTimeStamp = block.timestamp;                                                                                                                                                                   │
│     if (soul.state != SoulState.staking) {                                                                                                                                                                      │
│       finalTimeStamp = tokenCrossingParameters[latestIndex].stakingEndsTimestamp;                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     uint256 balance = IERC20(token).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (balance > 0) {                                                                                                                                                                                          │
│       uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;                                                                                                                    │
│                                                                                                                                                                                                                 │
│       soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);                                                                                                            │
│     }                                                                                                                                                                                                           │
│     soul.lastRewardTimestamp = finalTimeStamp;                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function claimReward(address token, uint256 index) public enabled {                                                                                                                                           │
│     Soul storage soul = souls;                                                                                                                                                                                  │
│     updateSoul(token, soul);                                                                                                                                                                                    │
│     User storage user = userInfo;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     uint256 pending = getPending(user, soul);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);                                                                                                                                │
│       emit ClaimedReward(msg.sender, token, index, pending);                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function updateSoul(address token, Soul storage soul) internal {                                                                                                                                              │
│     require(soul.soulType != SoulType.uninitialized, "E1");                                                                                                                                                     │
│     uint256 finalTimeStamp = block.timestamp;                                                                                                                                                                   │
│     if (soul.state != SoulState.staking) {                                                                                                                                                                      │
│       finalTimeStamp = tokenCrossingParameters[latestIndex].stakingEndsTimestamp;                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     uint256 balance = IERC20(token).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (balance > 0) {                                                                                                                                                                                          │
│       uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;                                                                                                                    │
│                                                                                                                                                                                                                 │
│       soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);                                                                                                            │
│     }                                                                                                                                                                                                           │
│     soul.lastRewardTimestamp = finalTimeStamp;                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function claimReward(address token, uint256 index) public enabled {                                                                                                                                           │
│     Soul storage soul = souls;                                                                                                                                                                                  │
│     updateSoul(token, soul);                                                                                                                                                                                    │
│     User storage user = userInfo;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     uint256 pending = getPending(user, soul);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);                                                                                                                                │
│       emit ClaimedReward(msg.sender, token, index, pending);                                                                                                                                                    │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function updateSoul(address token, Soul storage soul) internal {                                                                                                                                              │
│     require(soul.soulType != SoulType.uninitialized, "E1");                                                                                                                                                     │
│     uint256 finalTimeStamp = block.timestamp;                                                                                                                                                                   │
│     if (soul.state != SoulState.staking) {                                                                                                                                                                      │
│       finalTimeStamp = tokenCrossingParameters[latestIndex].stakingEndsTimestamp;                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     uint256 balance = IERC20(token).balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (balance > 0) {                                                                                                                                                                                          │
│       uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;                                                                                                                    │
│                                                                                                                                                                                                                 │
│       soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);                                                                                                            │
│     }                                                                                                                                                                                                           │
│     soul.lastRewardTimestamp = finalTimeStamp;                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function stake(address token, uint256 amount) public enabled {                                                                                                                                                │
│     Soul storage soul = currentSoul(token);                                                                                                                                                                     │
│     require(soul.state == SoulState.staking, "E2");                                                                                                                                                             │
│     updateSoul(token, soul);                                                                                                                                                                                    │
│     uint256 currentIndex = latestIndex;                                                                                                                                                                         │
│     User storage user = userInfo;                                                                                                                                                                               │
│     if (amount > 0) {                                                                                                                                                                                           │
│       //dish out accumulated rewards.                                                                                                                                                                           │
│       uint256 pending = getPending(user, soul);                                                                                                                                                                 │
│       if (pending > 0) {                                                                                                                                                                                        │
│         Flan.mint(msg.sender, pending);                                                                                                                                                                         │
│       }                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│       //Balance checking accounts for FOT discrepencies                                                                                                                                                         │
│       uint256 oldBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│       IERC20(token).safeTransferFrom(msg.sender, address(this), amount);                                                                                                                                        │
│       uint256 newBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens                                                                                         │
│       if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {                                                                                                                         │
│         soul.state = SoulState.waitingToCross;                                                                                                                                                                  │
│         tokenCrossingParameters[latestIndex].stakingEndsTimestamp = block.timestamp;                                                                                                                            │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;                                                                                                                                │
│     emit Staked(msg.sender, token, user.stakedAmount);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer,                                                                                                                           │
│ Code:                                                                                                                                                                                                           │
│   function _unstake(                                                                                                                                                                                            │
│     address token,                                                                                                                                                                                              │
│     uint256 amount,                                                                                                                                                                                             │
│     address unstaker,                                                                                                                                                                                           │
│     address holder                                                                                                                                                                                              │
│   ) internal {                                                                                                                                                                                                  │
│     if (unstaker != holder) {                                                                                                                                                                                   │
│       unstakeApproval -= amount;                                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     Soul storage soul = currentSoul(token);                                                                                                                                                                     │
│     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");                                                                                                                      │
│     updateSoul(token, soul);                                                                                                                                                                                    │
│     User storage user = userInfo[latestIndex];                                                                                                                                                                  │
│     require(user.stakedAmount >= amount, "E4");                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = getPending(user, soul);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (pending > 0 && amount > 0) {                                                                                                                                                                            │
│       user.stakedAmount = user.stakedAmount - amount;                                                                                                                                                           │
│       IERC20(token).safeTransfer(address(unstaker), amount);                                                                                                                                                    │
│       rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);                                                                                                                                  │
│       emit Unstaked(unstaker, token, amount);                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer, and there is no clear/reset of the approval when the transfer finishes its main branch or encounters exceptions           │
│ Code:                                                                                                                                                                                                           │
│   function _unstake(                                                                                                                                                                                            │
│     address token,                                                                                                                                                                                              │
│     uint256 amount,                                                                                                                                                                                             │
│     address unstaker,                                                                                                                                                                                           │
│     address holder                                                                                                                                                                                              │
│   ) internal {                                                                                                                                                                                                  │
│     if (unstaker != holder) {                                                                                                                                                                                   │
│       unstakeApproval -= amount;                                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     Soul storage soul = currentSoul(token);                                                                                                                                                                     │
│     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");                                                                                                                      │
│     updateSoul(token, soul);                                                                                                                                                                                    │
│     User storage user = userInfo[latestIndex];                                                                                                                                                                  │
│     require(user.stakedAmount >= amount, "E4");                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = getPending(user, soul);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (pending > 0 && amount > 0) {                                                                                                                                                                            │
│       user.stakedAmount = user.stakedAmount - amount;                                                                                                                                                           │
│       IERC20(token).safeTransfer(address(unstaker), amount);                                                                                                                                                    │
│       rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);                                                                                                                                  │
│       emit Unstaked(unstaker, token, amount);                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function claimSecondaryRewards(address token) public {                                                                                                                                                        │
│     SoulState state = currentSoul(token).state;                                                                                                                                                                 │
│     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");                                                                                                                            │
│     uint256 balance = IERC20(token).balanceOf(address(this));                                                                                                                                                   │
│     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);                                                                                                                                              │
│     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);                                                                                                                             │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function migrate(address token) public enabled {                                                                                                                                                              │
│     Soul storage soul = currentSoul(token);                                                                                                                                                                     │
│     require(soul.soulType == SoulType.threshold, "EB");                                                                                                                                                         │
│     require(soul.state == SoulState.waitingToCross, "E2");                                                                                                                                                      │
│     require(                                                                                                                                                                                                    │
│       block.timestamp - tokenCrossingParameters[latestIndex].stakingEndsTimestamp >                                                                                                                             │
│         crossingConfig.crossingMigrationDelay,                                                                                                                                                                  │
│       "EC"                                                                                                                                                                                                      │
│     );                                                                                                                                                                                                          │
│     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(                                                                                                                                                   │
│       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),                                                                                                                                            │
│       tokenCrossingParameters[latestIndex],                                                                                                                                                                     │
│       crossingConfig,                                                                                                                                                                                           │
│       Flan,                                                                                                                                                                                                     │
│       RectangleOfFairness,                                                                                                                                                                                      │
│       soul                                                                                                                                                                                                      │
│     );                                                                                                                                                                                                          │
│     emit TokenListed(token, tokenBalance, lpMinted);                                                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {                                                                                                          │
│     uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(                                                                                                                                │
│       VARS.DAI,                                                                                                                                                                                                 │
│       10000,                                                                                                                                                                                                    │
│       1 ether,                                                                                                                                                                                                  │
│       VARS.precision                                                                                                                                                                                            │
│     );                                                                                                                                                                                                          │
│     dai_scx = (daiToRelease * EXA) / (1 ether);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {                                                                                                          │
│     uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(                                                                                                                                │
│       VARS.DAI,                                                                                                                                                                                                 │
│       10000,                                                                                                                                                                                                    │
│       1 ether,                                                                                                                                                                                                  │
│       VARS.precision                                                                                                                                                                                            │
│     );                                                                                                                                                                                                          │
│     dai_scx = (daiToRelease * EXA) / (1 ether);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function generateFLNQuote() public override {                                                                                                                                                                 │
│     latestFlanQuotes[1] = latestFlanQuotes[0];                                                                                                                                                                  │
│     (                                                                                                                                                                                                           │
│       latestFlanQuotes[0].DaiScxSpotPrice,                                                                                                                                                                      │
│       latestFlanQuotes[0].DaiBalanceOnBehodler                                                                                                                                                                  │
│     ) = getLatestFLNQuote();                                                                                                                                                                                    │
│     latestFlanQuotes[0].blockProduced = block.number;                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {                                                                                                          │
│     uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(                                                                                                                                │
│       VARS.DAI,                                                                                                                                                                                                 │
│       10000,                                                                                                                                                                                                    │
│       1 ether,                                                                                                                                                                                                  │
│       VARS.precision                                                                                                                                                                                            │
│     );                                                                                                                                                                                                          │
│     dai_scx = (daiToRelease * EXA) / (1 ether);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function generateFLNQuote() public override {                                                                                                                                                                 │
│     latestFlanQuotes[1] = latestFlanQuotes[0];                                                                                                                                                                  │
│     (                                                                                                                                                                                                           │
│       latestFlanQuotes[0].DaiScxSpotPrice,                                                                                                                                                                      │
│       latestFlanQuotes[0].DaiBalanceOnBehodler                                                                                                                                                                  │
│     ) = getLatestFLNQuote();                                                                                                                                                                                    │
│     latestFlanQuotes[0].blockProduced = block.number;                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {                                                                                                          │
│     uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(                                                                                                                                │
│       VARS.DAI,                                                                                                                                                                                                 │
│       10000,                                                                                                                                                                                                    │
│       1 ether,                                                                                                                                                                                                  │
│       VARS.precision                                                                                                                                                                                            │
│     );                                                                                                                                                                                                          │
│     dai_scx = (daiToRelease * EXA) / (1 ether);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function migrate(                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     LimboAddTokenToBehodlerPowerLike power,                                                                                                                                                                     │
│     CrossingParameters memory crossingParams,                                                                                                                                                                   │
│     CrossingConfig memory crossingConfig,                                                                                                                                                                       │
│     FlanLike flan,                                                                                                                                                                                              │
│     uint256 RectangleOfFairness,                                                                                                                                                                                │
│     Soul storage soul                                                                                                                                                                                           │
│   ) external returns (uint256, uint256) {                                                                                                                                                                       │
│     power.parameterize(token, crossingParams.burnable);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     //invoke Angband execute on power that migrates token type to Behodler                                                                                                                                      │
│     uint256 tokenBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│     IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);                                                                                                                                 │
│     AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));                                                                                                                     │
│                                                                                                                                                                                                                 │
│     uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));                                                                                                                      │
│                                                                                                                                                                                                                 │
│     uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;                                                                                              │
│                                                                                                                                                                                                                 │
│     //for top up or exotic high value migrations.                                                                                                                                                               │
│     if (scxMinted <= adjustedRectangle) {                                                                                                                                                                       │
│       adjustedRectangle = scxMinted / 2;                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //burn SCX - rectangle                                                                                                                                                                                      │
│     uint256 excessSCX = scxMinted - adjustedRectangle;                                                                                                                                                          │
│     require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //use remaining scx to buy flan and pool it on an external AMM                                                                                                                                              │
│     IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);                                                                                                                      │
│     uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     //reward caller and update soul state                                                                                                                                                                       │
│     require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");                                                                                                                             │
│     soul.state = SoulState.crossedOver;                                                                                                                                                                         │
│     return (tokenBalance, lpMinted);                                                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function migrate(                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     LimboAddTokenToBehodlerPowerLike power,                                                                                                                                                                     │
│     CrossingParameters memory crossingParams,                                                                                                                                                                   │
│     CrossingConfig memory crossingConfig,                                                                                                                                                                       │
│     FlanLike flan,                                                                                                                                                                                              │
│     uint256 RectangleOfFairness,                                                                                                                                                                                │
│     Soul storage soul                                                                                                                                                                                           │
│   ) external returns (uint256, uint256) {                                                                                                                                                                       │
│     power.parameterize(token, crossingParams.burnable);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     //invoke Angband execute on power that migrates token type to Behodler                                                                                                                                      │
│     uint256 tokenBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│     IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);                                                                                                                                 │
│     AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));                                                                                                                     │
│                                                                                                                                                                                                                 │
│     uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));                                                                                                                      │
│                                                                                                                                                                                                                 │
│     uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;                                                                                              │
│                                                                                                                                                                                                                 │
│     //for top up or exotic high value migrations.                                                                                                                                                               │
│     if (scxMinted <= adjustedRectangle) {                                                                                                                                                                       │
│       adjustedRectangle = scxMinted / 2;                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //burn SCX - rectangle                                                                                                                                                                                      │
│     uint256 excessSCX = scxMinted - adjustedRectangle;                                                                                                                                                          │
│     require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //use remaining scx to buy flan and pool it on an external AMM                                                                                                                                              │
│     IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);                                                                                                                      │
│     uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     //reward caller and update soul state                                                                                                                                                                       │
│     require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");                                                                                                                             │
│     soul.state = SoulState.crossedOver;                                                                                                                                                                         │
│     return (tokenBalance, lpMinted);                                                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender                                                                                                                              │
│ have code statements that get or calculate LP token's value/price                                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function buyFlanAndBurn(                                                                                                                                                                                      │
│     address inputToken,                                                                                                                                                                                         │
│     uint256 amount,                                                                                                                                                                                             │
│     address recipient                                                                                                                                                                                           │
│   ) public override {                                                                                                                                                                                           │
│     address pair = VARS.factory.getPair(inputToken, VARS.flan);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                                    │
│     uint256 inputBalance = IERC20(inputToken).balanceOf(pair);                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);                                                                                                                                        │
│     uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;                                                                                                                                                │
│     uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;                                                                                                                                                │
│     IERC20(inputToken).transfer(pair, amount);                                                                                                                                                                  │
│     UniPairLike(pair).swap(amount0Out, amount1Out, address(this), "");                                                                                                                                          │
│     uint256 reward = (amountOut / 100);                                                                                                                                                                         │
│     ERC20Burnable(VARS.flan).transfer(recipient, reward);                                                                                                                                                       │
│     ERC20Burnable(VARS.flan).burn(amountOut - reward);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function claimSecondaryRewards(address token) public {                                                                                                                                                        │
│     SoulState state = currentSoul(token).state;                                                                                                                                                                 │
│     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");                                                                                                                            │
│     uint256 balance = IERC20(token).balanceOf(address(this));                                                                                                                                                   │
│     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);                                                                                                                                              │
│     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function buyFlanAndBurn(                                                                                                                                                                                      │
│     address inputToken,                                                                                                                                                                                         │
│     uint256 amount,                                                                                                                                                                                             │
│     address recipient                                                                                                                                                                                           │
│   ) public override {                                                                                                                                                                                           │
│     address pair = VARS.factory.getPair(inputToken, VARS.flan);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                                    │
│     uint256 inputBalance = IERC20(inputToken).balanceOf(pair);                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);                                                                                                                                        │
│     uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;                                                                                                                                                │
│     uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;                                                                                                                                                │
│     IERC20(inputToken).transfer(pair, amount);                                                                                                                                                                  │
│     UniPairLike(pair).swap(amount0Out, amount1Out, address(this), "");                                                                                                                                          │
│     uint256 reward = (amountOut / 100);                                                                                                                                                                         │
│     ERC20Burnable(VARS.flan).transfer(recipient, reward);                                                                                                                                                       │
│     ERC20Burnable(VARS.flan).burn(amountOut - reward);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve transfering token from an address different from message sender                                                                                                                              │
│ Code:                                                                                                                                                                                                           │
│     function incrementBurnOnTransferFee(int8 change)                                                                                                                                                            │
│         public                                                                                                                                                                                                  │
│         governanceApproved(false)                                                                                                                                                                               │
│     {                                                                                                                                                                                                           │
│         uint8 newFee = uint8(int8(burnOnTransferFee) + change);                                                                                                                                                 │
│         flashGoverner.enforceTolerance(newFee, burnOnTransferFee);                                                                                                                                              │
│         _setBurnOnTransferFee(newFee);                                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function safeTransfer(address _to, uint256 _amount) external {                                                                                                                                              │
│         uint256 flanBal = balanceOf(address(this));                                                                                                                                                             │
│         uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;                                                                                                                                         │
│         _transfer(_msgSender(), _to, flanToTransfer);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _unstake(                                                                                                                                                                                            │
│     address token,                                                                                                                                                                                              │
│     uint256 amount,                                                                                                                                                                                             │
│     address unstaker,                                                                                                                                                                                           │
│     address holder                                                                                                                                                                                              │
│   ) internal {                                                                                                                                                                                                  │
│     if (unstaker != holder) {                                                                                                                                                                                   │
│       unstakeApproval -= amount;                                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     Soul storage soul = currentSoul(token);                                                                                                                                                                     │
│     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");                                                                                                                      │
│     updateSoul(token, soul);                                                                                                                                                                                    │
│     User storage user = userInfo[latestIndex];                                                                                                                                                                  │
│     require(user.stakedAmount >= amount, "E4");                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = getPending(user, soul);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (pending > 0 && amount > 0) {                                                                                                                                                                            │
│       user.stakedAmount = user.stakedAmount - amount;                                                                                                                                                           │
│       IERC20(token).safeTransfer(address(unstaker), amount);                                                                                                                                                    │
│       rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);                                                                                                                                  │
│       emit Unstaked(unstaker, token, amount);                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│     function safeTransfer(address _to, uint256 _amount) external {                                                                                                                                              │
│         uint256 flanBal = balanceOf(address(this));                                                                                                                                                             │
│         uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;                                                                                                                                         │
│         _transfer(_msgSender(), _to, flanToTransfer);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function claimSecondaryRewards(address token) public {                                                                                                                                                        │
│     SoulState state = currentSoul(token).state;                                                                                                                                                                 │
│     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");                                                                                                                            │
│     uint256 balance = IERC20(token).balanceOf(address(this));                                                                                                                                                   │
│     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);                                                                                                                                              │
│     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);                                                                                                                             │
│   }                                                                                                                                                                                                             │
│     function safeTransfer(address _to, uint256 _amount) external {                                                                                                                                              │
│         uint256 flanBal = balanceOf(address(this));                                                                                                                                                             │
│         uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;                                                                                                                                         │
│         _transfer(_msgSender(), _to, flanToTransfer);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function _transfer(                                                                                                                                                                                         │
│         address sender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         uint256 amount                                                                                                                                                                                          │
│     ) internal override {                                                                                                                                                                                       │
│         require(sender != address(0), "ERC20: transfer from the zero address");                                                                                                                                 │
│         require(recipient != address(0), "ERC20: transfer to the zero address");                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 fee = (burnOnTransferFee * amount) / 100;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply - fee;                                                                                                                                                                      │
│         uint256 senderBalance = _balances;                                                                                                                                                                      │
│         require(                                                                                                                                                                                                │
│             senderBalance >= amount,                                                                                                                                                                            │
│             "ERC20: transfer amount exceeds balance"                                                                                                                                                            │
│         );                                                                                                                                                                                                      │
│         _balances = senderBalance - amount;                                                                                                                                                                     │
│         _balances += amount - fee;                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         emit Transfer(sender, recipient, amount);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function safeTransfer(address _to, uint256 _amount) external {                                                                                                                                              │
│         uint256 flanBal = balanceOf(address(this));                                                                                                                                                             │
│         uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;                                                                                                                                         │
│         _transfer(_msgSender(), _to, flanToTransfer);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│     function _transfer(                                                                                                                                                                                         │
│         address sender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         uint256 amount                                                                                                                                                                                          │
│     ) internal override {                                                                                                                                                                                       │
│         require(sender != address(0), "ERC20: transfer from the zero address");                                                                                                                                 │
│         require(recipient != address(0), "ERC20: transfer to the zero address");                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 fee = (burnOnTransferFee * amount) / 100;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply - fee;                                                                                                                                                                      │
│         uint256 senderBalance = _balances;                                                                                                                                                                      │
│         require(                                                                                                                                                                                                │
│             senderBalance >= amount,                                                                                                                                                                            │
│             "ERC20: transfer amount exceeds balance"                                                                                                                                                            │
│         );                                                                                                                                                                                                      │
│         _balances = senderBalance - amount;                                                                                                                                                                     │
│         _balances += amount - fee;                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         emit Transfer(sender, recipient, amount);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function transferFrom(                                                                                                                                                                                        │
│     address sender,                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     _transfer(sender, recipient, amount);                                                                                                                                                                       │
│     _approve(sender, msg.sender, _allowances - (amount));                                                                                                                                                       │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│     function _transfer(                                                                                                                                                                                         │
│         address sender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         uint256 amount                                                                                                                                                                                          │
│     ) internal override {                                                                                                                                                                                       │
│         require(sender != address(0), "ERC20: transfer from the zero address");                                                                                                                                 │
│         require(recipient != address(0), "ERC20: transfer to the zero address");                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 fee = (burnOnTransferFee * amount) / 100;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply - fee;                                                                                                                                                                      │
│         uint256 senderBalance = _balances;                                                                                                                                                                      │
│         require(                                                                                                                                                                                                │
│             senderBalance >= amount,                                                                                                                                                                            │
│             "ERC20: transfer amount exceeds balance"                                                                                                                                                            │
│         );                                                                                                                                                                                                      │
│         _balances = senderBalance - amount;                                                                                                                                                                     │
│         _balances += amount - fee;                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         emit Transfer(sender, recipient, amount);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function transferFrom(                                                                                                                                                                                        │
│     address sender,                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) public virtual override returns (bool) {                                                                                                                                                                    │
│     _transfer(sender, recipient, amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                       │
│     require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");                                                                                                                            │
│     unchecked {                                                                                                                                                                                                 │
│       _approve(sender, _msgSender(), currentAllowance - amount);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│     function _transfer(                                                                                                                                                                                         │
│         address sender,                                                                                                                                                                                         │
│         address recipient,                                                                                                                                                                                      │
│         uint256 amount                                                                                                                                                                                          │
│     ) internal override {                                                                                                                                                                                       │
│         require(sender != address(0), "ERC20: transfer from the zero address");                                                                                                                                 │
│         require(recipient != address(0), "ERC20: transfer to the zero address");                                                                                                                                │
│                                                                                                                                                                                                                 │
│         uint256 fee = (burnOnTransferFee * amount) / 100;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         _totalSupply = _totalSupply - fee;                                                                                                                                                                      │
│         uint256 senderBalance = _balances;                                                                                                                                                                      │
│         require(                                                                                                                                                                                                │
│             senderBalance >= amount,                                                                                                                                                                            │
│             "ERC20: transfer amount exceeds balance"                                                                                                                                                            │
│         );                                                                                                                                                                                                      │
│         _balances = senderBalance - amount;                                                                                                                                                                     │
│         _balances += amount - fee;                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         emit Transfer(sender, recipient, amount);                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes",                                                                                                                                                                                                 │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function redeem(address to, uint256 amount)                                                                                                                                                                 │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         uint256 baseTokens = (_redeemRate * amount) / ONE;                                                                                                                                                      │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│         IERC20(baseToken).transfer(to, baseTokens);                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function calculateMintedPyroWeth(uint256 baseTokenAmount) external view returns (uint256) {                                                                                                                   │
│     uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();                                                                                                                                        │
│     uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);                                                                                                                                 │
│     return (mintedPyroTokens * 999) / 1000; //0.1% fee                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function calculateMintedPyroWeth(uint256 baseTokenAmount) external view returns (uint256) {                                                                                                                   │
│     uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();                                                                                                                                        │
│     uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);                                                                                                                                 │
│     return (mintedPyroTokens * 999) / 1000; //0.1% fee                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function _redeem(                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     address owner,                                                                                                                                                                                              │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal updateReserve returns (uint256) {                                                                                                                                                                  │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     _balances -= amount;                                                                                                                                                                                        │
│     uint256 fee = calculateRedemptionFee(amount, owner);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 net = amount - fee;                                                                                                                                                                                 │
│     uint256 baseTokens = (net * ONE) / _redeemRate;                                                                                                                                                             │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│     emit Transfer(owner, address(0), uint128(amount), uint128(amount));                                                                                                                                         │
│     require(config.baseToken.transfer(recipient, baseTokens), "PyroToken reserve transfer failed.");                                                                                                            │
│     return baseTokens;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _redeem(                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     address owner,                                                                                                                                                                                              │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal updateReserve returns (uint256) {                                                                                                                                                                  │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     _balances -= amount;                                                                                                                                                                                        │
│     uint256 fee = calculateRedemptionFee(amount, owner);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 net = amount - fee;                                                                                                                                                                                 │
│     uint256 baseTokens = (net * ONE) / _redeemRate;                                                                                                                                                             │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│     emit Transfer(owner, address(0), uint128(amount), uint128(amount));                                                                                                                                         │
│     require(config.baseToken.transfer(recipient, baseTokens), "PyroToken reserve transfer failed.");                                                                                                            │
│     return baseTokens;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│     function redeemRate() public view returns (uint256) {                                                                                                                                                       │
│         uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));                                                                                                                                     │
│         if (totalSupply() == 0 || balanceOfBase == 0) return ONE;                                                                                                                                               │
│                                                                                                                                                                                                                 │
│         return (balanceOfBase * ONE) / totalSupply();                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {                                                                                                                                      │
│     require(fateToFlan > 0, "LimboDAO: Fate conversion to Flan disabled.");                                                                                                                                     │
│     fateState.fateBalance -= fate;                                                                                                                                                                              │
│     flan = (fateToFlan * fate) / ONE;                                                                                                                                                                           │
│     Flan(domainConfig.flan).mint(msg.sender, flan);                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function addLiquidity(address inputToken, uint256 amount)                                                                                                                                                     │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(inputToken)                                                                                                                                                                                  │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = uint256(int256(inputToken.shiftedBalance(MIN_LIQUIDITY).fromUInt()));                                                                                                              │
│                                                                                                                                                                                                                 │
│     inputToken.transferIn(msg.sender, amount);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 netInputAmount = uint256(int256(((amount - burnToken(inputToken, amount)) / MIN_LIQUIDITY).fromUInt()));                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 finalBalance = uint256(initialBalance + netInputAmount);                                                                                                                                            │
│     require(uint256(finalBalance) >= MIN_LIQUIDITY, "BEHODLER: min liquidity.");                                                                                                                                │
│     deltaSCX = uint256(finalBalance.log_2() - (initialBalance > 1 ? initialBalance.log_2() : 0));                                                                                                               │
│     mint(msg.sender, deltaSCX);                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function redeem(address to, uint256 amount)                                                                                                                                                                 │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         uint256 baseTokens = (_redeemRate * amount) / ONE;                                                                                                                                                      │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│         IERC20(baseToken).transfer(to, baseTokens);                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function SoulStats(address token, address _limbo)                                                                                                                                                             │
│     public                                                                                                                                                                                                      │
│     view                                                                                                                                                                                                        │
│     returns (                                                                                                                                                                                                   │
│       uint256, //state                                                                                                                                                                                          │
│       uint256, //staked balance                                                                                                                                                                                 │
│       uint256 //fps                                                                                                                                                                                             │
│     )                                                                                                                                                                                                           │
│   {                                                                                                                                                                                                             │
│     LimboLike limbo = getLimbo(_limbo);                                                                                                                                                                         │
│     uint256 latestIndex = limbo.latestIndex(token);                                                                                                                                                             │
│     (, , , , uint256 state, uint256 fps) = limbo.souls(token, latestIndex);                                                                                                                                     │
│     uint256 stakeBalance = IERC20(token).balanceOf(address(limbo));                                                                                                                                             │
│     return (state, stakeBalance, fps);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function GetPendingReward(                                                                                                                                                                                    │
│     address account,                                                                                                                                                                                            │
│     address token,                                                                                                                                                                                              │
│     address _limbo                                                                                                                                                                                              │
│   ) external view returns (uint256) {                                                                                                                                                                           │
│     LimboLike limbo = getLimbo(_limbo);                                                                                                                                                                         │
│     uint256 latestIndex = limbo.latestIndex(token);                                                                                                                                                             │
│     Soul memory soul; //stack too deep avoidance                                                                                                                                                                │
│     (soul.lastRewardTimestamp, soul.accumulatedFlanPerShare, , , soul.state, soul.flanPerSecond) = limbo.souls(                                                                                                 │
│       token,                                                                                                                                                                                                    │
│       latestIndex                                                                                                                                                                                               │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     (, uint256 stakingEndsTimestamp, , , ) = limbo.tokenCrossingParameters(token, latestIndex);                                                                                                                 │
│     uint256 finalTimeStamp = soul.state != 1 ? stakingEndsTimestamp : block.timestamp;                                                                                                                          │
│     uint256 limboBalance = IERC20(token).balanceOf(address(limbo));                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     (uint256 stakedAmount, uint256 rewardDebt, ) = limbo.userInfo(token, account, latestIndex);                                                                                                                 │
│     if (limboBalance > 0) {                                                                                                                                                                                     │
│       soul.accumulatedFlanPerShare =                                                                                                                                                                            │
│         soul.accumulatedFlanPerShare +                                                                                                                                                                          │
│         (((finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond * (1e12)) / limboBalance);                                                                                                           │
│     }                                                                                                                                                                                                           │
│     uint256 accumulated = ((stakedAmount * soul.accumulatedFlanPerShare) / (1e12));                                                                                                                             │
│     if (accumulated >= rewardDebt) return accumulated - rewardDebt;                                                                                                                                             │
│     return 0;                                                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function GetPendingReward(                                                                                                                                                                                    │
│     address account,                                                                                                                                                                                            │
│     address token,                                                                                                                                                                                              │
│     address _limbo                                                                                                                                                                                              │
│   ) external view returns (uint256) {                                                                                                                                                                           │
│     LimboLike limbo = getLimbo(_limbo);                                                                                                                                                                         │
│     uint256 latestIndex = limbo.latestIndex(token);                                                                                                                                                             │
│     Soul memory soul; //stack too deep avoidance                                                                                                                                                                │
│     (soul.lastRewardTimestamp, soul.accumulatedFlanPerShare, , , soul.state, soul.flanPerSecond) = limbo.souls(                                                                                                 │
│       token,                                                                                                                                                                                                    │
│       latestIndex                                                                                                                                                                                               │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     (, uint256 stakingEndsTimestamp, , , ) = limbo.tokenCrossingParameters(token, latestIndex);                                                                                                                 │
│     uint256 finalTimeStamp = soul.state != 1 ? stakingEndsTimestamp : block.timestamp;                                                                                                                          │
│     uint256 limboBalance = IERC20(token).balanceOf(address(limbo));                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     (uint256 stakedAmount, uint256 rewardDebt, ) = limbo.userInfo(token, account, latestIndex);                                                                                                                 │
│     if (limboBalance > 0) {                                                                                                                                                                                     │
│       soul.accumulatedFlanPerShare =                                                                                                                                                                            │
│         soul.accumulatedFlanPerShare +                                                                                                                                                                          │
│         (((finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond * (1e12)) / limboBalance);                                                                                                           │
│     }                                                                                                                                                                                                           │
│     uint256 accumulated = ((stakedAmount * soul.accumulatedFlanPerShare) / (1e12));                                                                                                                             │
│     if (accumulated >= rewardDebt) return accumulated - rewardDebt;                                                                                                                                             │
│     return 0;                                                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function ExpectedCrossingBonus(                                                                                                                                                                               │
│     address holder,                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     address _limbo                                                                                                                                                                                              │
│   ) external view returns (uint256 flanBonus) {                                                                                                                                                                 │
│     LimboLike limbo = getLimbo(_limbo);                                                                                                                                                                         │
│     uint256 latestIndex = limbo.latestIndex(token);                                                                                                                                                             │
│     (uint256 stakedAmount, , bool bonusPaid) = limbo.userInfo(token, holder, latestIndex);                                                                                                                      │
│     if (bonusPaid) return 0;                                                                                                                                                                                    │
│     uint256 bonusRate = ExpectedCrossingBonusRate(holder, token, _limbo);                                                                                                                                       │
│     flanBonus = (bonusRate * stakedAmount) / TERA;                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function ExpectedCrossingBonusRate(                                                                                                                                                                           │
│     address holder,                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     address _limbo                                                                                                                                                                                              │
│   ) public view returns (uint256 bonusRate) {                                                                                                                                                                   │
│     LimboLike limbo = getLimbo(_limbo);                                                                                                                                                                         │
│     uint256 latestIndex = limbo.latestIndex(token);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     (uint256 stakedAmount, , bool bonusPaid) = limbo.userInfo(token, holder, latestIndex);                                                                                                                      │
│     if (bonusPaid) return 0;                                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     (uint256 stakingBegins, uint256 stakingEnds, int256 crossingBonusDelta, uint256 initialCrossingBonus, ) = limbo                                                                                             │
│       .tokenCrossingParameters(token, latestIndex);                                                                                                                                                             │
│     stakingEnds = stakingEnds == 0 ? block.timestamp : stakingEnds;                                                                                                                                             │
│     stakingBegins = stakingBegins == 0 ? block.timestamp - 1 : stakingBegins;                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     int256 accumulatedFlanPerTeraToken = crossingBonusDelta * int256(stakingEnds - stakingBegins);                                                                                                              │
│     // console.log("token: %d", token);                                                                                                                                                                         │
│     // console.log("time elapsed %d", stakingEnds - stakingBegins);                                                                                                                                             │
│     // console.log(                                                                                                                                                                                             │
│     //   "accumulatedFlanPerTeraToken %d, initialCrossingBonus %d",                                                                                                                                             │
│     //   uint256(accumulatedFlanPerTeraToken),                                                                                                                                                                  │
│     //   uint256(initialCrossingBonus)                                                                                                                                                                          │
│     // );                                                                                                                                                                                                       │
│     int256 finalFlanPerTeraToken = int256(initialCrossingBonus) +                                                                                                                                               │
│       (stakedAmount > 0 ? accumulatedFlanPerTeraToken : int256(0));                                                                                                                                             │
│     bonusRate = finalFlanPerTeraToken > 0 ? uint256(finalFlanPerTeraToken) : 0;                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function ExpectedCrossingBonusRate(                                                                                                                                                                           │
│     address holder,                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     address _limbo                                                                                                                                                                                              │
│   ) public view returns (uint256 bonusRate) {                                                                                                                                                                   │
│     LimboLike limbo = getLimbo(_limbo);                                                                                                                                                                         │
│     uint256 latestIndex = limbo.latestIndex(token);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     (uint256 stakedAmount, , bool bonusPaid) = limbo.userInfo(token, holder, latestIndex);                                                                                                                      │
│     if (bonusPaid) return 0;                                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     (uint256 stakingBegins, uint256 stakingEnds, int256 crossingBonusDelta, uint256 initialCrossingBonus, ) = limbo                                                                                             │
│       .tokenCrossingParameters(token, latestIndex);                                                                                                                                                             │
│     stakingEnds = stakingEnds == 0 ? block.timestamp : stakingEnds;                                                                                                                                             │
│     stakingBegins = stakingBegins == 0 ? block.timestamp - 1 : stakingBegins;                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     int256 accumulatedFlanPerTeraToken = crossingBonusDelta * int256(stakingEnds - stakingBegins);                                                                                                              │
│     // console.log("token: %d", token);                                                                                                                                                                         │
│     // console.log("time elapsed %d", stakingEnds - stakingBegins);                                                                                                                                             │
│     // console.log(                                                                                                                                                                                             │
│     //   "accumulatedFlanPerTeraToken %d, initialCrossingBonus %d",                                                                                                                                             │
│     //   uint256(accumulatedFlanPerTeraToken),                                                                                                                                                                  │
│     //   uint256(initialCrossingBonus)                                                                                                                                                                          │
│     // );                                                                                                                                                                                                       │
│     int256 finalFlanPerTeraToken = int256(initialCrossingBonus) +                                                                                                                                               │
│       (stakedAmount > 0 ? accumulatedFlanPerTeraToken : int256(0));                                                                                                                                             │
│     bonusRate = finalFlanPerTeraToken > 0 ? uint256(finalFlanPerTeraToken) : 0;                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function deposit() external payable override {                                                                                                                                                                │
│     // _mintTo(msg.sender, msg.value);                                                                                                                                                                          │
│     balanceOf += msg.value;                                                                                                                                                                                     │
│     emit Transfer(address(0), msg.sender, msg.value);                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function depositTo(address to) external payable override {                                                                                                                                                    │
│     // _mintTo(to, msg.value);                                                                                                                                                                                  │
│     balanceOf += msg.value;                                                                                                                                                                                     │
│     emit Transfer(address(0), to, msg.value);                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function depositToAndCall(address to, bytes calldata data) external payable override returns (bool success) {                                                                                                 │
│     // _mintTo(to, msg.value);                                                                                                                                                                                  │
│     balanceOf += msg.value;                                                                                                                                                                                     │
│     emit Transfer(address(0), to, msg.value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     return ITransferReceiver(to).onTokenTransfer(msg.sender, msg.value, data);                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function flashLoan(                                                                                                                                                                                           │
│     IERC3156FlashBorrower receiver,                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     uint256 value,                                                                                                                                                                                              │
│     bytes calldata data                                                                                                                                                                                         │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     require(token == address(this), "WETH: flash mint only WETH10");                                                                                                                                            │
│     require(value <= type(uint112).max, "WETH: individual loan limit exceeded");                                                                                                                                │
│     flashMinted = flashMinted + value;                                                                                                                                                                          │
│     require(flashMinted <= type(uint112).max, "WETH: total loan limit exceeded");                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // _mintTo(address(receiver), value);                                                                                                                                                                       │
│     balanceOf += value;                                                                                                                                                                                         │
│     emit Transfer(address(0), address(receiver), value);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     require(                                                                                                                                                                                                    │
│       receiver.onFlashLoan(msg.sender, address(this), value, 0, data) == CALLBACK_SUCCESS,                                                                                                                      │
│       "WETH: flash loan failed"                                                                                                                                                                                 │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     // _decreaseAllowance(address(receiver), address(this), value);                                                                                                                                             │
│     uint256 allowed = allowance;                                                                                                                                                                                │
│     if (allowed != type(uint256).max) {                                                                                                                                                                         │
│       require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                             │
│       uint256 reduced = allowed - value;                                                                                                                                                                        │
│       allowance = reduced;                                                                                                                                                                                      │
│       emit Approval(address(receiver), address(this), reduced);                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _burnFrom(address(receiver), value);                                                                                                                                                                     │
│     uint256 balance = balanceOf;                                                                                                                                                                                │
│     require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                             │
│     balanceOf = balance - value;                                                                                                                                                                                │
│     emit Transfer(address(receiver), address(0), value);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     flashMinted = flashMinted - value;                                                                                                                                                                          │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function withdraw(uint256 value) external override {                                                                                                                                                          │
│     // _burnFrom(msg.sender, value);                                                                                                                                                                            │
│     uint256 balance = balanceOf;                                                                                                                                                                                │
│     require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                             │
│     balanceOf = balance - value;                                                                                                                                                                                │
│     emit Transfer(msg.sender, address(0), value);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // _transferEther(msg.sender, value);                                                                                                                                                                       │
│     (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                       │
│     require(success, "WETH: ETH transfer failed");                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function withdrawTo(address payable to, uint256 value) external override {                                                                                                                                    │
│     // _burnFrom(msg.sender, value);                                                                                                                                                                            │
│     uint256 balance = balanceOf;                                                                                                                                                                                │
│     require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                             │
│     balanceOf = balance - value;                                                                                                                                                                                │
│     emit Transfer(msg.sender, address(0), value);                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // _transferEther(to, value);                                                                                                                                                                               │
│     (bool success, ) = to.call{value: value}("");                                                                                                                                                               │
│     require(success, "WETH: ETH transfer failed");                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function withdrawFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address payable to,                                                                                                                                                                                         │
│     uint256 value                                                                                                                                                                                               │
│   ) external override {                                                                                                                                                                                         │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _burnFrom(from, value);                                                                                                                                                                                  │
│     uint256 balance = balanceOf;                                                                                                                                                                                │
│     require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                             │
│     balanceOf = balance - value;                                                                                                                                                                                │
│     emit Transfer(from, address(0), value);                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     // _transferEther(to, value);                                                                                                                                                                               │
│     (bool success, ) = to.call{value: value}("");                                                                                                                                                               │
│     require(success, "WETH: Ether transfer failed");                                                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function orchestrate() internal override returns (bool) {                                                                                                                                                   │
│         require(                                                                                                                                                                                                │
│             params.soul != address(0),                                                                                                                                                                          │
│             "MORGOTH: PowerInvoker not parameterized."                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 balanceOfToken = CommonIERC20(params.soul).balanceOf(                                                                                                                                           │
│             address(this)                                                                                                                                                                                       │
│         );                                                                                                                                                                                                      │
│         require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                      │
│         (address baseToken, bool migrate) = TokenProxyRegistry(                                                                                                                                                 │
│             params.tokenProxyRegistry                                                                                                                                                                           │
│         ).tokenProxy(params.soul);                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         address tokenToMigrate = params.soul;                                                                                                                                                                   │
│         if (migrate && baseToken != address(0)) {                                                                                                                                                               │
│             tokenToMigrate = baseToken;                                                                                                                                                                         │
│             TokenProxyLike(params.soul).redeem(address(this), balanceOfToken);                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         CommonIERC20(tokenToMigrate).approve(behodler, type(uint256).max);                                                                                                                                      │
│         BehodlerLiteLike(behodler).setTokenBurnable(                                                                                                                                                            │
│             tokenToMigrate,                                                                                                                                                                                     │
│             params.burnable                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         BehodlerLiteLike(behodler).addLiquidity(tokenToMigrate, balanceOfToken);                                                                                                                                │
│         uint256 scxBal = CommonIERC20(behodler).balanceOf(address(this));                                                                                                                                       │
│         CommonIERC20(behodler).transfer(params.limbo, scxBal);                                                                                                                                                  │
│         params.soul = address(0); // prevent non limbo from executing.                                                                                                                                          │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function buyFlanAndBurn(                                                                                                                                                                                      │
│     address inputToken,                                                                                                                                                                                         │
│     uint256 amount,                                                                                                                                                                                             │
│     address recipient                                                                                                                                                                                           │
│   ) public override {                                                                                                                                                                                           │
│     address pair = VARS.factory.getPair(inputToken, VARS.flan);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                                    │
│     uint256 inputBalance = IERC20(inputToken).balanceOf(pair);                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);                                                                                                                                        │
│     uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;                                                                                                                                                │
│     uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;                                                                                                                                                │
│     IERC20(inputToken).transfer(pair, amount);                                                                                                                                                                  │
│     UniPairLike(pair).swap(amount0Out, amount1Out, address(this), "");                                                                                                                                          │
│     uint256 reward = (amountOut / 100);                                                                                                                                                                         │
│     ERC20Burnable(VARS.flan).transfer(recipient, reward);                                                                                                                                                       │
│     ERC20Burnable(VARS.flan).burn(amountOut - reward);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function withdrawGovernanceAsset(address targetContract, address asset) public virtual {                                                                                                                      │
│     require(                                                                                                                                                                                                    │
│       pendingFlashDecision.asset == asset &&                                                                                                                                                                    │
│         pendingFlashDecision.amount > 0 &&                                                                                                                                                                      │
│         pendingFlashDecision.unlockTime < block.timestamp,                                                                                                                                                      │
│       "Limbo: Flashgovernance decision pending."                                                                                                                                                                │
│     );                                                                                                                                                                                                          │
│     IERC20(pendingFlashDecision.asset).transfer(                                                                                                                                                                │
│       msg.sender,                                                                                                                                                                                               │
│       pendingFlashDecision.amount                                                                                                                                                                               │
│     );                                                                                                                                                                                                          │
│     delete pendingFlashDecision;                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function redeem(address to, uint256 amount)                                                                                                                                                                 │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         uint256 baseTokens = (_redeemRate * amount) / ONE;                                                                                                                                                      │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│         IERC20(baseToken).transfer(to, baseTokens);                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function orchestrate() internal returns (bool) {                                                                                                                                                              │
│     require(params.soul != address(0), "MORGOTH: PowerInvoker not parameterized.");                                                                                                                             │
│     LachesisLike lachesis = LachesisLike(config.lachesis);                                                                                                                                                      │
│     lachesis.measure(params.soul, true, params.burnable);                                                                                                                                                       │
│     lachesis.updateBehodler(params.soul);                                                                                                                                                                       │
│     uint256 balanceOfToken = IERC20(params.soul).balanceOf(address(this));                                                                                                                                      │
│     require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                          │
│     IERC20(params.soul).approve(config.behodler, type(uint256).max);                                                                                                                                            │
│     BehodlerLike(config.behodler).addLiquidity(params.soul, balanceOfToken);                                                                                                                                    │
│     uint256 scxBal = IERC20(config.behodler).balanceOf(address(this));                                                                                                                                          │
│     IERC20(config.behodler).transfer(params.limbo, scxBal);                                                                                                                                                     │
│     params.soul = address(0); // prevent non limbo from executing.                                                                                                                                              │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function migrate(                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     LimboAddTokenToBehodlerPowerLike power,                                                                                                                                                                     │
│     CrossingParameters memory crossingParams,                                                                                                                                                                   │
│     CrossingConfig memory crossingConfig,                                                                                                                                                                       │
│     FlanLike flan,                                                                                                                                                                                              │
│     uint256 RectangleOfFairness,                                                                                                                                                                                │
│     Soul storage soul                                                                                                                                                                                           │
│   ) external returns (uint256, uint256) {                                                                                                                                                                       │
│     power.parameterize(token, crossingParams.burnable);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     //invoke Angband execute on power that migrates token type to Behodler                                                                                                                                      │
│     uint256 tokenBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│     IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);                                                                                                                                 │
│     AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));                                                                                                                     │
│                                                                                                                                                                                                                 │
│     uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));                                                                                                                      │
│                                                                                                                                                                                                                 │
│     uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;                                                                                              │
│                                                                                                                                                                                                                 │
│     //for top up or exotic high value migrations.                                                                                                                                                               │
│     if (scxMinted <= adjustedRectangle) {                                                                                                                                                                       │
│       adjustedRectangle = scxMinted / 2;                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //burn SCX - rectangle                                                                                                                                                                                      │
│     uint256 excessSCX = scxMinted - adjustedRectangle;                                                                                                                                                          │
│     require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //use remaining scx to buy flan and pool it on an external AMM                                                                                                                                              │
│     IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);                                                                                                                      │
│     uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     //reward caller and update soul state                                                                                                                                                                       │
│     require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");                                                                                                                             │
│     soul.state = SoulState.crossedOver;                                                                                                                                                                         │
│     return (tokenBalance, lpMinted);                                                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _redeem(                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     address owner,                                                                                                                                                                                              │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal updateReserve returns (uint256) {                                                                                                                                                                  │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     _balances -= amount;                                                                                                                                                                                        │
│     uint256 fee = calculateRedemptionFee(amount, owner);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 net = amount - fee;                                                                                                                                                                                 │
│     uint256 baseTokens = (net * ONE) / _redeemRate;                                                                                                                                                             │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│     emit Transfer(owner, address(0), uint128(amount), uint128(amount));                                                                                                                                         │
│     require(config.baseToken.transfer(recipient, baseTokens), "PyroToken reserve transfer failed.");                                                                                                            │
│     return baseTokens;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function transfer(address to, uint256 value) external override returns (bool) {                                                                                                                               │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function transferFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address to,                                                                                                                                                                                                 │
│     uint256 value                                                                                                                                                                                               │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         if (allowed < value) {                                                                                                                                                                                  │
│           console.log("FROM: %s TO: %s", from, to);                                                                                                                                                             │
│           console.log("allowed: %s value: %s", allowed, value);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _transferFrom(from, to, value);                                                                                                                                                                          │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(from, to, value);                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(from, address(0), value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function burnAsset(address asset, uint256 amount) public isLive incrementFate {                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     require(ERC677(asset).transferFrom(sender, address(this), amount), "LimboDAO: transferFailed");                                                                                                             │
│     uint256 fateCreated = fateState[_msgSender()].fateBalance;                                                                                                                                                  │
│     if (asset == domainConfig.eye) {                                                                                                                                                                            │
│       fateCreated = amount * 10;                                                                                                                                                                                │
│       ERC677(domainConfig.eye).burn(amount);                                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * amount) / ONE;                                                                                                                                                         │
│       fateCreated = impliedEye * 20;                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     fateState[_msgSender()].fateBalance += fateCreated;                                                                                                                                                         │
│     emit assetBurnt(_msgSender(), asset, fateCreated);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function transferFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address to,                                                                                                                                                                                                 │
│     uint256 value                                                                                                                                                                                               │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         if (allowed < value) {                                                                                                                                                                                  │
│           console.log("FROM: %s TO: %s", from, to);                                                                                                                                                             │
│           console.log("allowed: %s value: %s", allowed, value);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _transferFrom(from, to, value);                                                                                                                                                                          │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(from, to, value);                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(from, address(0), value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function transferFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address to,                                                                                                                                                                                                 │
│     uint256 value                                                                                                                                                                                               │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         if (allowed < value) {                                                                                                                                                                                  │
│           console.log("FROM: %s TO: %s", from, to);                                                                                                                                                             │
│           console.log("allowed: %s value: %s", allowed, value);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _transferFrom(from, to, value);                                                                                                                                                                          │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(from, to, value);                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(from, address(0), value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   function transferFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address to,                                                                                                                                                                                                 │
│     uint256 value                                                                                                                                                                                               │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         if (allowed < value) {                                                                                                                                                                                  │
│           console.log("FROM: %s TO: %s", from, to);                                                                                                                                                             │
│           console.log("allowed: %s value: %s", allowed, value);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _transferFrom(from, to, value);                                                                                                                                                                          │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(from, to, value);                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(from, address(0), value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function assertGovernanceApproved(                                                                                                                                                                            │
│     address sender,                                                                                                                                                                                             │
│     address target,                                                                                                                                                                                             │
│     bool emergency                                                                                                                                                                                              │
│   ) public {                                                                                                                                                                                                    │
│     if (                                                                                                                                                                                                        │
│       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&                                                                                                  │
│       pendingFlashDecision.unlockTime < block.timestamp                                                                                                                                                         │
│     ) {                                                                                                                                                                                                         │
│       require(                                                                                                                                                                                                  │
│         emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),                                                                                                                  │
│         "Limbo: flash governance disabled for rest of epoch"                                                                                                                                                    │
│       );                                                                                                                                                                                                        │
│       pendingFlashDecision = flashGovernanceConfig;                                                                                                                                                             │
│       pendingFlashDecision.unlockTime += block.timestamp;                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       security.lastFlashGovernanceAct = block.timestamp;                                                                                                                                                        │
│       emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);                                                                                                            │
│     } else {                                                                                                                                                                                                    │
│       revert("LIMBO: governance decision rejected.");                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function transferFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address to,                                                                                                                                                                                                 │
│     uint256 value                                                                                                                                                                                               │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         if (allowed < value) {                                                                                                                                                                                  │
│           console.log("FROM: %s TO: %s", from, to);                                                                                                                                                             │
│           console.log("allowed: %s value: %s", allowed, value);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _transferFrom(from, to, value);                                                                                                                                                                          │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(from, to, value);                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(from, address(0), value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function redeem(uint256 pyroTokenAmount) external reentrancyGuard returns (uint256) {                                                                                                                         │
│     IERC20(baseToken).transferFrom(msg.sender, address(this), pyroTokenAmount); //0.1% fee                                                                                                                      │
│     uint256 actualAmount = IERC20(baseToken).balanceOf(address(this));                                                                                                                                          │
│     PyroTokenLike(baseToken).redeem(actualAmount);                                                                                                                                                              │
│     uint256 balanceOfWeth = weth10.balanceOf(address(this));                                                                                                                                                    │
│     weth10.withdrawTo(payable(msg.sender), balanceOfWeth);                                                                                                                                                      │
│     return balanceOfWeth;                                                                                                                                                                                       │
│   }                                                                                                                                                                                                             │
│   function transferFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address to,                                                                                                                                                                                                 │
│     uint256 value                                                                                                                                                                                               │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         if (allowed < value) {                                                                                                                                                                                  │
│           console.log("FROM: %s TO: %s", from, to);                                                                                                                                                             │
│           console.log("allowed: %s value: %s", allowed, value);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _transferFrom(from, to, value);                                                                                                                                                                          │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(from, to, value);                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(from, address(0), value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function transferFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address to,                                                                                                                                                                                                 │
│     uint256 value                                                                                                                                                                                               │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         if (allowed < value) {                                                                                                                                                                                  │
│           console.log("FROM: %s TO: %s", from, to);                                                                                                                                                             │
│           console.log("allowed: %s value: %s", allowed, value);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _transferFrom(from, to, value);                                                                                                                                                                          │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(from, to, value);                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(from, address(0), value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function transferFrom(                                                                                                                                                                                        │
│     address from,                                                                                                                                                                                               │
│     address to,                                                                                                                                                                                                 │
│     uint256 value                                                                                                                                                                                               │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     if (from != msg.sender) {                                                                                                                                                                                   │
│       // _decreaseAllowance(from, msg.sender, value);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       uint256 allowed = allowance;                                                                                                                                                                              │
│       if (allowed != type(uint256).max) {                                                                                                                                                                       │
│         if (allowed < value) {                                                                                                                                                                                  │
│           console.log("FROM: %s TO: %s", from, to);                                                                                                                                                             │
│           console.log("allowed: %s value: %s", allowed, value);                                                                                                                                                 │
│         }                                                                                                                                                                                                       │
│         require(allowed >= value, "WETH: request exceeds allowance");                                                                                                                                           │
│         uint256 reduced = allowed - value;                                                                                                                                                                      │
│         allowance = reduced;                                                                                                                                                                                    │
│         emit Approval(from, msg.sender, reduced);                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // _transferFrom(from, to, value);                                                                                                                                                                          │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(from, to, value);                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(from, address(0), value);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function transferAndCall(                                                                                                                                                                                     │
│     address to,                                                                                                                                                                                                 │
│     uint256 value,                                                                                                                                                                                              │
│     bytes calldata data                                                                                                                                                                                         │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     // _transferFrom(msg.sender, to, value);                                                                                                                                                                    │
│     if (to != address(0)) {                                                                                                                                                                                     │
│       // Transfer                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: transfer amount exceeds balance");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       balanceOf += value;                                                                                                                                                                                       │
│       emit Transfer(msg.sender, to, value);                                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       // Withdraw                                                                                                                                                                                               │
│       uint256 balance = balanceOf;                                                                                                                                                                              │
│       require(balance >= value, "WETH: burn amount exceeds balance");                                                                                                                                           │
│       balanceOf = balance - value;                                                                                                                                                                              │
│       emit Transfer(msg.sender, address(0), value);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│       (bool success, ) = msg.sender.call{value: value}("");                                                                                                                                                     │
│       require(success, "WETH: ETH transfer failed");                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);                                                                                                                                      │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function redeem(uint256 pyroTokenAmount) external reentrancyGuard returns (uint256) {                                                                                                                         │
│     IERC20(baseToken).transferFrom(msg.sender, address(this), pyroTokenAmount); //0.1% fee                                                                                                                      │
│     uint256 actualAmount = IERC20(baseToken).balanceOf(address(this));                                                                                                                                          │
│     PyroTokenLike(baseToken).redeem(actualAmount);                                                                                                                                                              │
│     uint256 balanceOfWeth = weth10.balanceOf(address(this));                                                                                                                                                    │
│     weth10.withdrawTo(payable(msg.sender), balanceOfWeth);                                                                                                                                                      │
│     return balanceOfWeth;                                                                                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function orchestrate() internal override returns (bool) {                                                                                                                                                   │
│         require(                                                                                                                                                                                                │
│             params.soul != address(0),                                                                                                                                                                          │
│             "MORGOTH: PowerInvoker not parameterized."                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 balanceOfToken = CommonIERC20(params.soul).balanceOf(                                                                                                                                           │
│             address(this)                                                                                                                                                                                       │
│         );                                                                                                                                                                                                      │
│         require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                      │
│         (address baseToken, bool migrate) = TokenProxyRegistry(                                                                                                                                                 │
│             params.tokenProxyRegistry                                                                                                                                                                           │
│         ).tokenProxy(params.soul);                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         address tokenToMigrate = params.soul;                                                                                                                                                                   │
│         if (migrate && baseToken != address(0)) {                                                                                                                                                               │
│             tokenToMigrate = baseToken;                                                                                                                                                                         │
│             TokenProxyLike(params.soul).redeem(address(this), balanceOfToken);                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         CommonIERC20(tokenToMigrate).approve(behodler, type(uint256).max);                                                                                                                                      │
│         BehodlerLiteLike(behodler).setTokenBurnable(                                                                                                                                                            │
│             tokenToMigrate,                                                                                                                                                                                     │
│             params.burnable                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         BehodlerLiteLike(behodler).addLiquidity(tokenToMigrate, balanceOfToken);                                                                                                                                │
│         uint256 scxBal = CommonIERC20(behodler).balanceOf(address(this));                                                                                                                                       │
│         CommonIERC20(behodler).transfer(params.limbo, scxBal);                                                                                                                                                  │
│         params.soul = address(0); // prevent non limbo from executing.                                                                                                                                          │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│   function redeem(uint256 pyroTokenAmount) external reentrancyGuard returns (uint256) {                                                                                                                         │
│     IERC20(baseToken).transferFrom(msg.sender, address(this), pyroTokenAmount); //0.1% fee                                                                                                                      │
│     uint256 actualAmount = IERC20(baseToken).balanceOf(address(this));                                                                                                                                          │
│     PyroTokenLike(baseToken).redeem(actualAmount);                                                                                                                                                              │
│     uint256 balanceOfWeth = weth10.balanceOf(address(this));                                                                                                                                                    │
│     weth10.withdrawTo(payable(msg.sender), balanceOfWeth);                                                                                                                                                      │
│     return balanceOfWeth;                                                                                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function redeem(uint256 pyroTokenAmount) external reentrancyGuard returns (uint256) {                                                                                                                         │
│     IERC20(baseToken).transferFrom(msg.sender, address(this), pyroTokenAmount); //0.1% fee                                                                                                                      │
│     uint256 actualAmount = IERC20(baseToken).balanceOf(address(this));                                                                                                                                          │
│     PyroTokenLike(baseToken).redeem(actualAmount);                                                                                                                                                              │
│     uint256 balanceOfWeth = weth10.balanceOf(address(this));                                                                                                                                                    │
│     weth10.withdrawTo(payable(msg.sender), balanceOfWeth);                                                                                                                                                      │
│     return balanceOfWeth;                                                                                                                                                                                       │
│   }                                                                                                                                                                                                             │
│   function redeem(uint256 pyroTokenAmount) external reentrancyGuard returns (uint256) {                                                                                                                         │
│     IERC20(baseToken).transferFrom(msg.sender, address(this), pyroTokenAmount); //0.1% fee                                                                                                                      │
│     uint256 actualAmount = IERC20(baseToken).balanceOf(address(this));                                                                                                                                          │
│     PyroTokenLike(baseToken).redeem(actualAmount);                                                                                                                                                              │
│     uint256 balanceOfWeth = weth10.balanceOf(address(this));                                                                                                                                                    │
│     weth10.withdrawTo(payable(msg.sender), balanceOfWeth);                                                                                                                                                      │
│     return balanceOfWeth;                                                                                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {                                                                                                                                      │
│     require(fateToFlan > 0, "LimboDAO: Fate conversion to Flan disabled.");                                                                                                                                     │
│     fateState.fateBalance -= fate;                                                                                                                                                                              │
│     flan = (fateToFlan * fate) / ONE;                                                                                                                                                                           │
│     Flan(domainConfig.flan).mint(msg.sender, flan);                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function addLiquidity(address inputToken, uint256 amount)                                                                                                                                                     │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(inputToken)                                                                                                                                                                                  │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = uint256(int256(inputToken.shiftedBalance(MIN_LIQUIDITY).fromUInt()));                                                                                                              │
│                                                                                                                                                                                                                 │
│     inputToken.transferIn(msg.sender, amount);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 netInputAmount = uint256(int256(((amount - burnToken(inputToken, amount)) / MIN_LIQUIDITY).fromUInt()));                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 finalBalance = uint256(initialBalance + netInputAmount);                                                                                                                                            │
│     require(uint256(finalBalance) >= MIN_LIQUIDITY, "BEHODLER: min liquidity.");                                                                                                                                │
│     deltaSCX = uint256(finalBalance.log_2() - (initialBalance > 1 ? initialBalance.log_2() : 0));                                                                                                               │
│     mint(msg.sender, deltaSCX);                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function calculateMintedPyroWeth(uint256 baseTokenAmount) external view returns (uint256) {                                                                                                                   │
│     uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();                                                                                                                                        │
│     uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);                                                                                                                                 │
│     return (mintedPyroTokens * 999) / 1000; //0.1% fee                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function calculateMintedPyroWeth(uint256 baseTokenAmount) external view returns (uint256) {                                                                                                                   │
│     uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();                                                                                                                                        │
│     uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);                                                                                                                                 │
│     return (mintedPyroTokens * 999) / 1000; //0.1% fee                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function calculateRedeemedWeth(uint256 pyroTokenAmount) external view returns (uint256) {                                                                                                                     │
│     uint256 pyroTokenSupply = IERC20(baseToken).totalSupply() - ((pyroTokenAmount * 1) / 1000);                                                                                                                 │
│     uint256 wethBalance = IERC20(weth10).balanceOf(baseToken);                                                                                                                                                  │
│     uint256 newRedeemRate = (wethBalance * ONE) / pyroTokenSupply;                                                                                                                                              │
│     uint256 newPyroTokenbalance = (pyroTokenAmount * 999) / 1000;                                                                                                                                               │
│     uint256 fee = (newPyroTokenbalance * 2) / 100;                                                                                                                                                              │
│     uint256 net = newPyroTokenbalance - fee;                                                                                                                                                                    │
│     return (net * newRedeemRate) / ONE;                                                                                                                                                                         │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No",                                                                                                                                                                                                    │
│   "3": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function snuff(                                                                                                                                                                                             │
│         address pyroToken,                                                                                                                                                                                      │
│         address targetContract,                                                                                                                                                                                 │
│         FeeExemption exempt                                                                                                                                                                                     │
│     ) public override returns (bool) {                                                                                                                                                                          │
│         require(eye.transferFrom(msg.sender,address(this), 1000 * (1 ether)),"ERC20: transfer failed.");                                                                                                        │
│         uint balance = eye.balanceOf(address(this));                                                                                                                                                            │
│         eye.burn(balance);                                                                                                                                                                                      │
│         _snuff(pyroToken, targetContract, exempt);                                                                                                                                                              │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function _mint(address account, uint256 amount) internal virtual {                                                                                                                                            │
│     require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     _totalSupply += amount;                                                                                                                                                                                     │
│     _balances += amount;                                                                                                                                                                                        │
│     emit Transfer(address(0), account, uint128(amount), 0);                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function _mint(address account, uint256 amount) internal virtual {                                                                                                                                            │
│     require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     _totalSupply += amount;                                                                                                                                                                                     │
│     _balances += amount;                                                                                                                                                                                        │
│     emit Transfer(address(0), account, uint128(amount), 0);                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function _mint(address account, uint256 amount) internal virtual {                                                                                                                                            │
│     require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     _totalSupply += amount;                                                                                                                                                                                     │
│     _balances += amount;                                                                                                                                                                                        │
│     emit Transfer(address(0), account, uint128(amount), 0);                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   function _mint(address account, uint256 amount) internal virtual {                                                                                                                                            │
│     require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     _totalSupply += amount;                                                                                                                                                                                     │
│     _balances += amount;                                                                                                                                                                                        │
│     emit Transfer(address(0), account, uint128(amount), 0);                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   function _mint(address account, uint256 amount) internal virtual {                                                                                                                                            │
│     require(account != address(0), "ERC20: mint to the zero address");                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     _totalSupply += amount;                                                                                                                                                                                     │
│     _balances += amount;                                                                                                                                                                                        │
│     emit Transfer(address(0), account, uint128(amount), 0);                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function _burn(address account, uint256 amount) internal virtual {                                                                                                                                            │
│     require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 accountBalance = _balances;                                                                                                                                                                         │
│     require(accountBalance >= amount, "ERC20: burn amount exceeds balance");                                                                                                                                    │
│     unchecked {                                                                                                                                                                                                 │
│       _balances = accountBalance - amount;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     emit Transfer(account, address(0), uint128(amount), 0);                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function burnFrom(address account, uint256 amount) public virtual {                                                                                                                                           │
│     uint256 currentAllowance = allowance(account, _msgSender());                                                                                                                                                │
│     require(currentAllowance >= amount, "ERC20: burn amount exceeds allowance");                                                                                                                                │
│     unchecked {                                                                                                                                                                                                 │
│       _approve(account, _msgSender(), currentAllowance - amount);                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│     _burn(account, amount);                                                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│   function _burn(address account, uint256 amount) internal virtual {                                                                                                                                            │
│     require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 accountBalance = _balances;                                                                                                                                                                         │
│     require(accountBalance >= amount, "ERC20: burn amount exceeds balance");                                                                                                                                    │
│     unchecked {                                                                                                                                                                                                 │
│       _balances = accountBalance - amount;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     emit Transfer(account, address(0), uint128(amount), 0);                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function redeem(address to, uint256 amount)                                                                                                                                                                 │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         uint256 baseTokens = (_redeemRate * amount) / ONE;                                                                                                                                                      │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│         IERC20(baseToken).transfer(to, baseTokens);                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│   function _burn(address account, uint256 amount) internal virtual {                                                                                                                                            │
│     require(account != address(0), "ERC20: burn from the zero address");                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 accountBalance = _balances;                                                                                                                                                                         │
│     require(accountBalance >= amount, "ERC20: burn amount exceeds balance");                                                                                                                                    │
│     unchecked {                                                                                                                                                                                                 │
│       _balances = accountBalance - amount;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     emit Transfer(account, address(0), uint128(amount), 0);                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No",                                                                                                                                                                                                  │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {                                                                                                                                      │
│     require(fateToFlan > 0, "LimboDAO: Fate conversion to Flan disabled.");                                                                                                                                     │
│     fateState.fateBalance -= fate;                                                                                                                                                                              │
│     flan = (fateToFlan * fate) / ONE;                                                                                                                                                                           │
│     Flan(domainConfig.flan).mint(msg.sender, flan);                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function addLiquidity(address inputToken, uint256 amount)                                                                                                                                                     │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(inputToken)                                                                                                                                                                                  │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = uint256(int256(inputToken.shiftedBalance(MIN_LIQUIDITY).fromUInt()));                                                                                                              │
│                                                                                                                                                                                                                 │
│     inputToken.transferIn(msg.sender, amount);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 netInputAmount = uint256(int256(((amount - burnToken(inputToken, amount)) / MIN_LIQUIDITY).fromUInt()));                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 finalBalance = uint256(initialBalance + netInputAmount);                                                                                                                                            │
│     require(uint256(finalBalance) >= MIN_LIQUIDITY, "BEHODLER: min liquidity.");                                                                                                                                │
│     deltaSCX = uint256(finalBalance.log_2() - (initialBalance > 1 ? initialBalance.log_2() : 0));                                                                                                               │
│     mint(msg.sender, deltaSCX);                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function _redeem(                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     address owner,                                                                                                                                                                                              │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal updateReserve returns (uint256) {                                                                                                                                                                  │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     _balances -= amount;                                                                                                                                                                                        │
│     uint256 fee = calculateRedemptionFee(amount, owner);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 net = amount - fee;                                                                                                                                                                                 │
│     uint256 baseTokens = (net * ONE) / _redeemRate;                                                                                                                                                             │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│     emit Transfer(owner, address(0), uint128(amount), uint128(amount));                                                                                                                                         │
│     require(config.baseToken.transfer(recipient, baseTokens), "PyroToken reserve transfer failed.");                                                                                                            │
│     return baseTokens;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No",                                                                                                                                                                                                    │
│   "3": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function redeemFrom(                                                                                                                                                                                          │
│     address owner,                                                                                                                                                                                              │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) external returns (uint256) {                                                                                                                                                                                │
│     uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                       │
│     _approve(owner, _msgSender(), currentAllowance - amount);                                                                                                                                                   │
│     return _redeem(owner, recipient, amount);                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function _redeem(                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     address owner,                                                                                                                                                                                              │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal updateReserve returns (uint256) {                                                                                                                                                                  │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     _balances -= amount;                                                                                                                                                                                        │
│     uint256 fee = calculateRedemptionFee(amount, owner);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 net = amount - fee;                                                                                                                                                                                 │
│     uint256 baseTokens = (net * ONE) / _redeemRate;                                                                                                                                                             │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│     emit Transfer(owner, address(0), uint128(amount), uint128(amount));                                                                                                                                         │
│     require(config.baseToken.transfer(recipient, baseTokens), "PyroToken reserve transfer failed.");                                                                                                            │
│     return baseTokens;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 baseTokenAmount) external updateReserve initialized returns (uint256) {                                                                                              │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     uint initialBalance = config.baseToken.balanceOf(address(this));                                                                                                                                            │
│     require(config.baseToken.transferFrom(_msgSender(), address(this), baseTokenAmount));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //fee on transfer tokens                                                                                                                                                                                    │
│     uint256 trueTransfer = config.baseToken.balanceOf(address(this)) - initialBalance;                                                                                                                          │
│     uint256 pyro = ( ONE* trueTransfer) / _redeemRate;                                                                                                                                                          │
│     console.log("minted pyro %s, baseTokenAmount %s", pyro, trueTransfer);                                                                                                                                      │
│     _mint(recipient, pyro);                                                                                                                                                                                     │
│     emit Transfer(address(0), recipient, uint128(pyro), 0);                                                                                                                                                     │
│     return pyro;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes",                                                                                                                                                                                                 │
│     "2": "Yes"                                                                                                                                                                                                  │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│     function mint(address to, uint256 amount)                                                                                                                                                                   │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         require(                                                                                                                                                                                                │
│             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)                                                                                                                                   │
│         );                                                                                                                                                                                                      │
│         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│         uint256 proxy = (baseBalance * ONE) / _redeemRate;                                                                                                                                                      │
│         _mint(to, proxy);                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function redeem(address to, uint256 amount)                                                                                                                                                                 │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         uint256 baseTokens = (_redeemRate * amount) / ONE;                                                                                                                                                      │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│         IERC20(baseToken).transfer(to, baseTokens);                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes",                                                                                                                                                                                                 │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│     function redeem(address to, uint256 amount)                                                                                                                                                                 │
│         public                                                                                                                                                                                                  │
│         override                                                                                                                                                                                                │
│         returns (uint256)                                                                                                                                                                                       │
│     {                                                                                                                                                                                                           │
│         uint256 _redeemRate = redeemRate();                                                                                                                                                                     │
│         uint256 baseTokens = (_redeemRate * amount) / ONE;                                                                                                                                                      │
│         _burn(msg.sender, amount);                                                                                                                                                                              │
│         IERC20(baseToken).transfer(to, baseTokens);                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function calculateMintedPyroWeth(uint256 baseTokenAmount) external view returns (uint256) {                                                                                                                   │
│     uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();                                                                                                                                        │
│     uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);                                                                                                                                 │
│     return (mintedPyroTokens * 999) / 1000; //0.1% fee                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function calculateMintedPyroWeth(uint256 baseTokenAmount) external view returns (uint256) {                                                                                                                   │
│     uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();                                                                                                                                        │
│     uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);                                                                                                                                 │
│     return (mintedPyroTokens * 999) / 1000; //0.1% fee                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function _redeem(                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     address owner,                                                                                                                                                                                              │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal updateReserve returns (uint256) {                                                                                                                                                                  │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     _balances -= amount;                                                                                                                                                                                        │
│     uint256 fee = calculateRedemptionFee(amount, owner);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 net = amount - fee;                                                                                                                                                                                 │
│     uint256 baseTokens = (net * ONE) / _redeemRate;                                                                                                                                                             │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│     emit Transfer(owner, address(0), uint128(amount), uint128(amount));                                                                                                                                         │
│     require(config.baseToken.transfer(recipient, baseTokens), "PyroToken reserve transfer failed.");                                                                                                            │
│     return baseTokens;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _redeem(                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     address owner,                                                                                                                                                                                              │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal updateReserve returns (uint256) {                                                                                                                                                                  │
│     uint256 _redeemRate = redeemRate();                                                                                                                                                                         │
│     _balances -= amount;                                                                                                                                                                                        │
│     uint256 fee = calculateRedemptionFee(amount, owner);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 net = amount - fee;                                                                                                                                                                                 │
│     uint256 baseTokens = (net * ONE) / _redeemRate;                                                                                                                                                             │
│     _totalSupply -= amount;                                                                                                                                                                                     │
│     emit Transfer(owner, address(0), uint128(amount), uint128(amount));                                                                                                                                         │
│     require(config.baseToken.transfer(recipient, baseTokens), "PyroToken reserve transfer failed.");                                                                                                            │
│     return baseTokens;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function redeemRate() public view returns (uint256) {                                                                                                                                                         │
│     uint256 balanceOfBase = config.baseToken.balanceOf(address(this));                                                                                                                                          │
│     if (_totalSupply == 0 || balanceOfBase == 0) return ONE;                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     return (balanceOfBase * ONE) / _totalSupply;                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function drain(address baseToken) external returns (uint256) {                                                                                                                                                │
│     address pyroToken = getPyroToken(baseToken);                                                                                                                                                                │
│     IERC20 reserve = IERC20(baseToken);                                                                                                                                                                         │
│     uint256 amount = reserve.balanceOf(address(this));                                                                                                                                                          │
│     reserve.transfer(pyroToken, amount);                                                                                                                                                                        │
│     return amount;                                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function initialize(                                                                                                                                                                                          │
│     address baseToken,                                                                                                                                                                                          │
│     string memory name_,                                                                                                                                                                                        │
│     string memory symbol_                                                                                                                                                                                       │
│   ) public onlyReceiver {                                                                                                                                                                                       │
│     config.baseToken = IERC20(baseToken);                                                                                                                                                                       │
│     _name = name_;                                                                                                                                                                                              │
│     _symbol = symbol_;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function drain(address baseToken) external returns (uint256) {                                                                                                                                                │
│     address pyroToken = getPyroToken(baseToken);                                                                                                                                                                │
│     IERC20 reserve = IERC20(baseToken);                                                                                                                                                                         │
│     uint256 amount = reserve.balanceOf(address(this));                                                                                                                                                          │
│     reserve.transfer(pyroToken, amount);                                                                                                                                                                        │
│     return amount;                                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function burn(address holder, uint256 value) internal {                                                                                                                                                       │
│     balances = balances - value;                                                                                                                                                                                │
│     _totalSupply = _totalSupply - value;                                                                                                                                                                        │
│     emit Burn(value);                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function burnAsset(address asset, uint256 amount) public isLive incrementFate {                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     require(ERC677(asset).transferFrom(sender, address(this), amount), "LimboDAO: transferFailed");                                                                                                             │
│     uint256 fateCreated = fateState[_msgSender()].fateBalance;                                                                                                                                                  │
│     if (asset == domainConfig.eye) {                                                                                                                                                                            │
│       fateCreated = amount * 10;                                                                                                                                                                                │
│       ERC677(domainConfig.eye).burn(amount);                                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * amount) / ONE;                                                                                                                                                         │
│       fateCreated = impliedEye * 20;                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     fateState[_msgSender()].fateBalance += fateCreated;                                                                                                                                                         │
│     emit assetBurnt(_msgSender(), asset, fateCreated);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function burn(address holder, uint256 value) internal {                                                                                                                                                       │
│     balances = balances - value;                                                                                                                                                                                │
│     _totalSupply = _totalSupply - value;                                                                                                                                                                        │
│     emit Burn(value);                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function buyFlanAndBurn(                                                                                                                                                                                      │
│     address inputToken,                                                                                                                                                                                         │
│     uint256 amount,                                                                                                                                                                                             │
│     address recipient                                                                                                                                                                                           │
│   ) public override {                                                                                                                                                                                           │
│     address pair = VARS.factory.getPair(inputToken, VARS.flan);                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                                    │
│     uint256 inputBalance = IERC20(inputToken).balanceOf(pair);                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);                                                                                                                                        │
│     uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;                                                                                                                                                │
│     uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;                                                                                                                                                │
│     IERC20(inputToken).transfer(pair, amount);                                                                                                                                                                  │
│     UniPairLike(pair).swap(amount0Out, amount1Out, address(this), "");                                                                                                                                          │
│     uint256 reward = (amountOut / 100);                                                                                                                                                                         │
│     ERC20Burnable(VARS.flan).transfer(recipient, reward);                                                                                                                                                       │
│     ERC20Burnable(VARS.flan).burn(amountOut - reward);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function burn(address holder, uint256 value) internal {                                                                                                                                                       │
│     balances = balances - value;                                                                                                                                                                                │
│     _totalSupply = _totalSupply - value;                                                                                                                                                                        │
│     emit Burn(value);                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function burnFlashGovernanceAsset(                                                                                                                                                                            │
│     address targetContract,                                                                                                                                                                                     │
│     address user,                                                                                                                                                                                               │
│     address asset,                                                                                                                                                                                              │
│     uint256 amount                                                                                                                                                                                              │
│   ) public virtual onlySuccessfulProposal {                                                                                                                                                                     │
│     if (pendingFlashDecision.assetBurnable) {                                                                                                                                                                   │
│       Burnable(asset).burn(amount);                                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     pendingFlashDecision = flashGovernanceConfig;                                                                                                                                                               │
│   }                                                                                                                                                                                                             │
│   function burn(address holder, uint256 value) internal {                                                                                                                                                       │
│     balances = balances - value;                                                                                                                                                                                │
│     _totalSupply = _totalSupply - value;                                                                                                                                                                        │
│     emit Burn(value);                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function withdrawLiquidity(address outputToken, uint256 tokensToRelease)                                                                                                                                      │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(outputToken)                                                                                                                                                                                 │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = outputToken.tokenBalance();                                                                                                                                                        │
│     uint256 finalBalance = initialBalance - tokensToRelease;                                                                                                                                                    │
│     require(finalBalance > MIN_LIQUIDITY, "BEHODLER: min liquidity");                                                                                                                                           │
│     require(                                                                                                                                                                                                    │
│       (tokensToRelease * 100) / initialBalance <= safetyParameters.maxLiquidityExit,                                                                                                                            │
│       "BEHODLER: liquidity withdrawal too large."                                                                                                                                                               │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 logInitial = initialBalance.log_2();                                                                                                                                                                │
│     uint256 logFinal = finalBalance.log_2();                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     deltaSCX = logInitial - (finalBalance > 1 ? logFinal : 0);                                                                                                                                                  │
│     uint256 scxBalance = balances;                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     if (deltaSCX > scxBalance) {                                                                                                                                                                                │
│       //rounding errors in scx creation and destruction. Err on the side of holders                                                                                                                             │
│       uint256 difference = deltaSCX - scxBalance;                                                                                                                                                               │
│       if ((difference * 10000) / deltaSCX == 0) deltaSCX = scxBalance;                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     burn(msg.sender, deltaSCX);                                                                                                                                                                                 │
│     outputToken.transferOut(msg.sender, tokensToRelease);                                                                                                                                                       │
│   }                                                                                                                                                                                                             │
│   function burn(address holder, uint256 value) internal {                                                                                                                                                       │
│     balances = balances - value;                                                                                                                                                                                │
│     _totalSupply = _totalSupply - value;                                                                                                                                                                        │
│     emit Burn(value);                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function migrate(                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     LimboAddTokenToBehodlerPowerLike power,                                                                                                                                                                     │
│     CrossingParameters memory crossingParams,                                                                                                                                                                   │
│     CrossingConfig memory crossingConfig,                                                                                                                                                                       │
│     FlanLike flan,                                                                                                                                                                                              │
│     uint256 RectangleOfFairness,                                                                                                                                                                                │
│     Soul storage soul                                                                                                                                                                                           │
│   ) external returns (uint256, uint256) {                                                                                                                                                                       │
│     power.parameterize(token, crossingParams.burnable);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     //invoke Angband execute on power that migrates token type to Behodler                                                                                                                                      │
│     uint256 tokenBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│     IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);                                                                                                                                 │
│     AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));                                                                                                                     │
│                                                                                                                                                                                                                 │
│     uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));                                                                                                                      │
│                                                                                                                                                                                                                 │
│     uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;                                                                                              │
│                                                                                                                                                                                                                 │
│     //for top up or exotic high value migrations.                                                                                                                                                               │
│     if (scxMinted <= adjustedRectangle) {                                                                                                                                                                       │
│       adjustedRectangle = scxMinted / 2;                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //burn SCX - rectangle                                                                                                                                                                                      │
│     uint256 excessSCX = scxMinted - adjustedRectangle;                                                                                                                                                          │
│     require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //use remaining scx to buy flan and pool it on an external AMM                                                                                                                                              │
│     IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);                                                                                                                      │
│     uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     //reward caller and update soul state                                                                                                                                                                       │
│     require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");                                                                                                                             │
│     soul.state = SoulState.crossedOver;                                                                                                                                                                         │
│     return (tokenBalance, lpMinted);                                                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function burn(address holder, uint256 value) internal {                                                                                                                                                       │
│     balances = balances - value;                                                                                                                                                                                │
│     _totalSupply = _totalSupply - value;                                                                                                                                                                        │
│     emit Burn(value);                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function migrate(                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     LimboAddTokenToBehodlerPowerLike power,                                                                                                                                                                     │
│     CrossingParameters memory crossingParams,                                                                                                                                                                   │
│     CrossingConfig memory crossingConfig,                                                                                                                                                                       │
│     FlanLike flan,                                                                                                                                                                                              │
│     uint256 RectangleOfFairness,                                                                                                                                                                                │
│     Soul storage soul                                                                                                                                                                                           │
│   ) external returns (uint256, uint256) {                                                                                                                                                                       │
│     power.parameterize(token, crossingParams.burnable);                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     //invoke Angband execute on power that migrates token type to Behodler                                                                                                                                      │
│     uint256 tokenBalance = IERC20(token).balanceOf(address(this));                                                                                                                                              │
│     IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);                                                                                                                                 │
│     AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));                                                                                                                     │
│                                                                                                                                                                                                                 │
│     uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));                                                                                                                      │
│                                                                                                                                                                                                                 │
│     uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;                                                                                              │
│                                                                                                                                                                                                                 │
│     //for top up or exotic high value migrations.                                                                                                                                                               │
│     if (scxMinted <= adjustedRectangle) {                                                                                                                                                                       │
│       adjustedRectangle = scxMinted / 2;                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //burn SCX - rectangle                                                                                                                                                                                      │
│     uint256 excessSCX = scxMinted - adjustedRectangle;                                                                                                                                                          │
│     require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     //use remaining scx to buy flan and pool it on an external AMM                                                                                                                                              │
│     IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);                                                                                                                      │
│     uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     //reward caller and update soul state                                                                                                                                                                       │
│     require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");                                                                                                                             │
│     soul.state = SoulState.crossedOver;                                                                                                                                                                         │
│     return (tokenBalance, lpMinted);                                                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function burn(address holder, uint256 value) internal {                                                                                                                                                       │
│     balances = balances - value;                                                                                                                                                                                │
│     _totalSupply = _totalSupply - value;                                                                                                                                                                        │
│     emit Burn(value);                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {                                                                                                                                      │
│     require(fateToFlan > 0, "LimboDAO: Fate conversion to Flan disabled.");                                                                                                                                     │
│     fateState.fateBalance -= fate;                                                                                                                                                                              │
│     flan = (fateToFlan * fate) / ONE;                                                                                                                                                                           │
│     Flan(domainConfig.flan).mint(msg.sender, flan);                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function mint(uint256 baseTokenAmount) external payable reentrancyGuard returns (uint256) {                                                                                                                   │
│     require(msg.value == baseTokenAmount && baseTokenAmount > 0, "PyroWethProxy: amount invariant");                                                                                                            │
│     weth10.deposit{value: msg.value}();                                                                                                                                                                         │
│     uint256 weth10Balance = weth10.balanceOf(address(this));                                                                                                                                                    │
│     PyroTokenLike(baseToken).mint(weth10Balance);                                                                                                                                                               │
│     uint256 pyroWethBalance = IERC20(baseToken).balanceOf(address(this));                                                                                                                                       │
│     IERC20(baseToken).transfer(msg.sender, pyroWethBalance);                                                                                                                                                    │
│     return (pyroWethBalance * 999) / 1000; //0.1% fee                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function addLiquidity(address inputToken, uint256 amount)                                                                                                                                                     │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(inputToken)                                                                                                                                                                                  │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = uint256(int256(inputToken.shiftedBalance(MIN_LIQUIDITY).fromUInt()));                                                                                                              │
│                                                                                                                                                                                                                 │
│     inputToken.transferIn(msg.sender, amount);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 netInputAmount = uint256(int256(((amount - burnToken(inputToken, amount)) / MIN_LIQUIDITY).fromUInt()));                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 finalBalance = uint256(initialBalance + netInputAmount);                                                                                                                                            │
│     require(uint256(finalBalance) >= MIN_LIQUIDITY, "BEHODLER: min liquidity.");                                                                                                                                │
│     deltaSCX = uint256(finalBalance.log_2() - (initialBalance > 1 ? initialBalance.log_2() : 0));                                                                                                               │
│     mint(msg.sender, deltaSCX);                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function addLiquidity(address inputToken, uint256 amount)                                                                                                                                                     │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(inputToken)                                                                                                                                                                                  │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = uint256(int256(inputToken.shiftedBalance(MIN_LIQUIDITY).fromUInt()));                                                                                                              │
│                                                                                                                                                                                                                 │
│     inputToken.transferIn(msg.sender, amount);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 netInputAmount = uint256(int256(((amount - burnToken(inputToken, amount)) / MIN_LIQUIDITY).fromUInt()));                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 finalBalance = uint256(initialBalance + netInputAmount);                                                                                                                                            │
│     require(uint256(finalBalance) >= MIN_LIQUIDITY, "BEHODLER: min liquidity.");                                                                                                                                │
│     deltaSCX = uint256(finalBalance.log_2() - (initialBalance > 1 ? initialBalance.log_2() : 0));                                                                                                               │
│     mint(msg.sender, deltaSCX);                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {                                                                               │
│     uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.                                                                                              │
│     //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes                                                           │
│     require((localSCXBalance * 100) / rectangleOfFairness == 98, "EM");                                                                                                                                         │
│     rectangleOfFairness = localSCXBalance;                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     //get DAI per scx                                                                                                                                                                                           │
│     uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));                                                                                                         │
│     uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.                                                                                                           │
│     uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);                                                                                                         │
│     address pair = address(VARS.Flan_SCX_tokenPair);                                                                                                                                                            │
│     uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (existingFlanOnLP < DesiredFinalFlanOnLP) {                                                                                                                                                              │
│       uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;                                                                                                │
│                                                                                                                                                                                                                 │
│       flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;                                                                                                                      │
│       FlanLike(VARS.flan).mint(pair, flanToMint);                                                                                                                                                               │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       {                                                                                                                                                                                                         │
│         lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                │
│       }                                                                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();                                                                                                                               │
│                                                                                                                                                                                                                 │
│       FlanLike(VARS.flan).mint(pair, minFlan + 2);                                                                                                                                                              │
│       IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);                                                                                                                                                │
│       lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.                                             │
│     _zeroOutQuotes();                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function mint(address recipient, uint256 value) internal {                                                                                                                                                    │
│     balances = balances + (value);                                                                                                                                                                              │
│     _totalSupply = _totalSupply + (value);                                                                                                                                                                      │
│     emit Mint(msg.sender, recipient, value);                                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function _transfer(                                                                                                                                                                                           │
│     address sender,                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal virtual {                                                                                                                                                                                          │
│     require(sender != address(0), "Scarcity: transfer from the zero address");                                                                                                                                  │
│     require(recipient != address(0), "Scarcity: transfer to the zero address");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 feeComponent = (config.transferFee * amount) / (1000);                                                                                                                                              │
│     console.log("transferFee %s, amount %s, feeComponent %s", config.transferFee, amount, feeComponent);                                                                                                        │
│     uint256 burnComponent = (config.burnFee * amount) / (1000);                                                                                                                                                 │
│     _totalSupply = _totalSupply - burnComponent;                                                                                                                                                                │
│     emit Burn(burnComponent);                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     balances = balances + (feeComponent);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     balances = balances - (amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     balances = balances + (amount - (feeComponent + burnComponent));                                                                                                                                            │
│     emit Transfer(sender, recipient, amount);                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│     function safeTransfer(address _to, uint256 _amount) external {                                                                                                                                              │
│         uint256 flanBal = balanceOf(address(this));                                                                                                                                                             │
│         uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;                                                                                                                                         │
│         _transfer(_msgSender(), _to, flanToTransfer);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│   function _transfer(                                                                                                                                                                                           │
│     address sender,                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal virtual {                                                                                                                                                                                          │
│     require(sender != address(0), "Scarcity: transfer from the zero address");                                                                                                                                  │
│     require(recipient != address(0), "Scarcity: transfer to the zero address");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 feeComponent = (config.transferFee * amount) / (1000);                                                                                                                                              │
│     console.log("transferFee %s, amount %s, feeComponent %s", config.transferFee, amount, feeComponent);                                                                                                        │
│     uint256 burnComponent = (config.burnFee * amount) / (1000);                                                                                                                                                 │
│     _totalSupply = _totalSupply - burnComponent;                                                                                                                                                                │
│     emit Burn(burnComponent);                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     balances = balances + (feeComponent);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     balances = balances - (amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     balances = balances + (amount - (feeComponent + burnComponent));                                                                                                                                            │
│     emit Transfer(sender, recipient, amount);                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function transferFrom(                                                                                                                                                                                        │
│     address sender,                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) external override returns (bool) {                                                                                                                                                                          │
│     _transfer(sender, recipient, amount);                                                                                                                                                                       │
│     _approve(sender, msg.sender, _allowances - (amount));                                                                                                                                                       │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function _transfer(                                                                                                                                                                                           │
│     address sender,                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal virtual {                                                                                                                                                                                          │
│     require(sender != address(0), "Scarcity: transfer from the zero address");                                                                                                                                  │
│     require(recipient != address(0), "Scarcity: transfer to the zero address");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 feeComponent = (config.transferFee * amount) / (1000);                                                                                                                                              │
│     console.log("transferFee %s, amount %s, feeComponent %s", config.transferFee, amount, feeComponent);                                                                                                        │
│     uint256 burnComponent = (config.burnFee * amount) / (1000);                                                                                                                                                 │
│     _totalSupply = _totalSupply - burnComponent;                                                                                                                                                                │
│     emit Burn(burnComponent);                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     balances = balances + (feeComponent);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     balances = balances - (amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     balances = balances + (amount - (feeComponent + burnComponent));                                                                                                                                            │
│     emit Transfer(sender, recipient, amount);                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function transferFrom(                                                                                                                                                                                        │
│     address sender,                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) public virtual override returns (bool) {                                                                                                                                                                    │
│     _transfer(sender, recipient, amount);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                       │
│     require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");                                                                                                                            │
│     unchecked {                                                                                                                                                                                                 │
│       _approve(sender, _msgSender(), currentAllowance - amount);                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function _transfer(                                                                                                                                                                                           │
│     address sender,                                                                                                                                                                                             │
│     address recipient,                                                                                                                                                                                          │
│     uint256 amount                                                                                                                                                                                              │
│   ) internal virtual {                                                                                                                                                                                          │
│     require(sender != address(0), "Scarcity: transfer from the zero address");                                                                                                                                  │
│     require(recipient != address(0), "Scarcity: transfer to the zero address");                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 feeComponent = (config.transferFee * amount) / (1000);                                                                                                                                              │
│     console.log("transferFee %s, amount %s, feeComponent %s", config.transferFee, amount, feeComponent);                                                                                                        │
│     uint256 burnComponent = (config.burnFee * amount) / (1000);                                                                                                                                                 │
│     _totalSupply = _totalSupply - burnComponent;                                                                                                                                                                │
│     emit Burn(burnComponent);                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     balances = balances + (feeComponent);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     balances = balances - (amount);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     balances = balances + (amount - (feeComponent + burnComponent));                                                                                                                                            │
│     emit Transfer(sender, recipient, amount);                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function addLiquidity(address inputToken, uint256 amount)                                                                                                                                                     │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(inputToken)                                                                                                                                                                                  │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = uint256(int256(inputToken.shiftedBalance(MIN_LIQUIDITY).fromUInt()));                                                                                                              │
│                                                                                                                                                                                                                 │
│     inputToken.transferIn(msg.sender, amount);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 netInputAmount = uint256(int256(((amount - burnToken(inputToken, amount)) / MIN_LIQUIDITY).fromUInt()));                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 finalBalance = uint256(initialBalance + netInputAmount);                                                                                                                                            │
│     require(uint256(finalBalance) >= MIN_LIQUIDITY, "BEHODLER: min liquidity.");                                                                                                                                │
│     deltaSCX = uint256(finalBalance.log_2() - (initialBalance > 1 ? initialBalance.log_2() : 0));                                                                                                               │
│     mint(msg.sender, deltaSCX);                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│     function orchestrate() internal override returns (bool) {                                                                                                                                                   │
│         require(                                                                                                                                                                                                │
│             params.soul != address(0),                                                                                                                                                                          │
│             "MORGOTH: PowerInvoker not parameterized."                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 balanceOfToken = CommonIERC20(params.soul).balanceOf(                                                                                                                                           │
│             address(this)                                                                                                                                                                                       │
│         );                                                                                                                                                                                                      │
│         require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                      │
│         (address baseToken, bool migrate) = TokenProxyRegistry(                                                                                                                                                 │
│             params.tokenProxyRegistry                                                                                                                                                                           │
│         ).tokenProxy(params.soul);                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         address tokenToMigrate = params.soul;                                                                                                                                                                   │
│         if (migrate && baseToken != address(0)) {                                                                                                                                                               │
│             tokenToMigrate = baseToken;                                                                                                                                                                         │
│             TokenProxyLike(params.soul).redeem(address(this), balanceOfToken);                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         CommonIERC20(tokenToMigrate).approve(behodler, type(uint256).max);                                                                                                                                      │
│         BehodlerLiteLike(behodler).setTokenBurnable(                                                                                                                                                            │
│             tokenToMigrate,                                                                                                                                                                                     │
│             params.burnable                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         BehodlerLiteLike(behodler).addLiquidity(tokenToMigrate, balanceOfToken);                                                                                                                                │
│         uint256 scxBal = CommonIERC20(behodler).balanceOf(address(this));                                                                                                                                       │
│         CommonIERC20(behodler).transfer(params.limbo, scxBal);                                                                                                                                                  │
│         params.soul = address(0); // prevent non limbo from executing.                                                                                                                                          │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│   function addLiquidity(address inputToken, uint256 amount)                                                                                                                                                     │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(inputToken)                                                                                                                                                                                  │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = uint256(int256(inputToken.shiftedBalance(MIN_LIQUIDITY).fromUInt()));                                                                                                              │
│                                                                                                                                                                                                                 │
│     inputToken.transferIn(msg.sender, amount);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 netInputAmount = uint256(int256(((amount - burnToken(inputToken, amount)) / MIN_LIQUIDITY).fromUInt()));                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 finalBalance = uint256(initialBalance + netInputAmount);                                                                                                                                            │
│     require(uint256(finalBalance) >= MIN_LIQUIDITY, "BEHODLER: min liquidity.");                                                                                                                                │
│     deltaSCX = uint256(finalBalance.log_2() - (initialBalance > 1 ? initialBalance.log_2() : 0));                                                                                                               │
│     mint(msg.sender, deltaSCX);                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function orchestrate() internal returns (bool) {                                                                                                                                                              │
│     require(params.soul != address(0), "MORGOTH: PowerInvoker not parameterized.");                                                                                                                             │
│     LachesisLike lachesis = LachesisLike(config.lachesis);                                                                                                                                                      │
│     lachesis.measure(params.soul, true, params.burnable);                                                                                                                                                       │
│     lachesis.updateBehodler(params.soul);                                                                                                                                                                       │
│     uint256 balanceOfToken = IERC20(params.soul).balanceOf(address(this));                                                                                                                                      │
│     require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                          │
│     IERC20(params.soul).approve(config.behodler, type(uint256).max);                                                                                                                                            │
│     BehodlerLike(config.behodler).addLiquidity(params.soul, balanceOfToken);                                                                                                                                    │
│     uint256 scxBal = IERC20(config.behodler).balanceOf(address(this));                                                                                                                                          │
│     IERC20(config.behodler).transfer(params.limbo, scxBal);                                                                                                                                                     │
│     params.soul = address(0); // prevent non limbo from executing.                                                                                                                                              │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function addLiquidity(address inputToken, uint256 amount)                                                                                                                                                     │
│     external                                                                                                                                                                                                    │
│     payable                                                                                                                                                                                                     │
│     onlyValidToken(inputToken)                                                                                                                                                                                  │
│     returns (uint256 deltaSCX)                                                                                                                                                                                  │
│   {                                                                                                                                                                                                             │
│     uint256 initialBalance = uint256(int256(inputToken.shiftedBalance(MIN_LIQUIDITY).fromUInt()));                                                                                                              │
│                                                                                                                                                                                                                 │
│     inputToken.transferIn(msg.sender, amount);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 netInputAmount = uint256(int256(((amount - burnToken(inputToken, amount)) / MIN_LIQUIDITY).fromUInt()));                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 finalBalance = uint256(initialBalance + netInputAmount);                                                                                                                                            │
│     require(uint256(finalBalance) >= MIN_LIQUIDITY, "BEHODLER: min liquidity.");                                                                                                                                │
│     deltaSCX = uint256(finalBalance.log_2() - (initialBalance > 1 ? initialBalance.log_2() : 0));                                                                                                               │
│     mint(msg.sender, deltaSCX);                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│     function parameterize(address soul, bool burnable) public {                                                                                                                                                 │
│         require(                                                                                                                                                                                                │
│             msg.sender == params.limbo,                                                                                                                                                                         │
│             "MORGOTH: Only Limbo can migrate tokens from Limbo."                                                                                                                                                │
│         );                                                                                                                                                                                                      │
│         params.soul = soul;                                                                                                                                                                                     │
│         params.burnable = burnable;                                                                                                                                                                             │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                               │
│ have code statements that get or calculate LP token's value/price                                                                                                                                               │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│     function orchestrate() internal override returns (bool) {                                                                                                                                                   │
│         require(                                                                                                                                                                                                │
│             params.soul != address(0),                                                                                                                                                                          │
│             "MORGOTH: PowerInvoker not parameterized."                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 balanceOfToken = CommonIERC20(params.soul).balanceOf(                                                                                                                                           │
│             address(this)                                                                                                                                                                                       │
│         );                                                                                                                                                                                                      │
│         require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                      │
│         (address baseToken, bool migrate) = TokenProxyRegistry(                                                                                                                                                 │
│             params.tokenProxyRegistry                                                                                                                                                                           │
│         ).tokenProxy(params.soul);                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         address tokenToMigrate = params.soul;                                                                                                                                                                   │
│         if (migrate && baseToken != address(0)) {                                                                                                                                                               │
│             tokenToMigrate = baseToken;                                                                                                                                                                         │
│             TokenProxyLike(params.soul).redeem(address(this), balanceOfToken);                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         CommonIERC20(tokenToMigrate).approve(behodler, type(uint256).max);                                                                                                                                      │
│         BehodlerLiteLike(behodler).setTokenBurnable(                                                                                                                                                            │
│             tokenToMigrate,                                                                                                                                                                                     │
│             params.burnable                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         BehodlerLiteLike(behodler).addLiquidity(tokenToMigrate, balanceOfToken);                                                                                                                                │
│         uint256 scxBal = CommonIERC20(behodler).balanceOf(address(this));                                                                                                                                       │
│         CommonIERC20(behodler).transfer(params.limbo, scxBal);                                                                                                                                                  │
│         params.soul = address(0); // prevent non limbo from executing.                                                                                                                                          │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes",                                                                                                                                                                                                 │
│     "2": "No",                                                                                                                                                                                                  │
│     "3": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum │
│ value check                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│     function orchestrate() internal override returns (bool) {                                                                                                                                                   │
│         require(                                                                                                                                                                                                │
│             params.soul != address(0),                                                                                                                                                                          │
│             "MORGOTH: PowerInvoker not parameterized."                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 balanceOfToken = CommonIERC20(params.soul).balanceOf(                                                                                                                                           │
│             address(this)                                                                                                                                                                                       │
│         );                                                                                                                                                                                                      │
│         require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                      │
│         (address baseToken, bool migrate) = TokenProxyRegistry(                                                                                                                                                 │
│             params.tokenProxyRegistry                                                                                                                                                                           │
│         ).tokenProxy(params.soul);                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         address tokenToMigrate = params.soul;                                                                                                                                                                   │
│         if (migrate && baseToken != address(0)) {                                                                                                                                                               │
│             tokenToMigrate = baseToken;                                                                                                                                                                         │
│             TokenProxyLike(params.soul).redeem(address(this), balanceOfToken);                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         CommonIERC20(tokenToMigrate).approve(behodler, type(uint256).max);                                                                                                                                      │
│         BehodlerLiteLike(behodler).setTokenBurnable(                                                                                                                                                            │
│             tokenToMigrate,                                                                                                                                                                                     │
│             params.burnable                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         BehodlerLiteLike(behodler).addLiquidity(tokenToMigrate, balanceOfToken);                                                                                                                                │
│         uint256 scxBal = CommonIERC20(behodler).balanceOf(address(this));                                                                                                                                       │
│         CommonIERC20(behodler).transfer(params.limbo, scxBal);                                                                                                                                                  │
│         params.soul = address(0); // prevent non limbo from executing.                                                                                                                                          │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                               │
│ have code statements that get or calculate LP token's value/price                                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│  function invoke(bytes32 minion, address sender) public {                                                                                                                                                       │
│     require(msg.sender == address(config.angband), "MORGOTH: angband only");                                                                                                                                    │
│     require(orchestrate(), "MORGOTH: Power invocation");                                                                                                                                                        │
│     emit PowerInvoked(sender, minion, "domain");                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│     function orchestrate() internal override returns (bool) {                                                                                                                                                   │
│         require(                                                                                                                                                                                                │
│             params.soul != address(0),                                                                                                                                                                          │
│             "MORGOTH: PowerInvoker not parameterized."                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 balanceOfToken = CommonIERC20(params.soul).balanceOf(                                                                                                                                           │
│             address(this)                                                                                                                                                                                       │
│         );                                                                                                                                                                                                      │
│         require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                      │
│         (address baseToken, bool migrate) = TokenProxyRegistry(                                                                                                                                                 │
│             params.tokenProxyRegistry                                                                                                                                                                           │
│         ).tokenProxy(params.soul);                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         address tokenToMigrate = params.soul;                                                                                                                                                                   │
│         if (migrate && baseToken != address(0)) {                                                                                                                                                               │
│             tokenToMigrate = baseToken;                                                                                                                                                                         │
│             TokenProxyLike(params.soul).redeem(address(this), balanceOfToken);                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         CommonIERC20(tokenToMigrate).approve(behodler, type(uint256).max);                                                                                                                                      │
│         BehodlerLiteLike(behodler).setTokenBurnable(                                                                                                                                                            │
│             tokenToMigrate,                                                                                                                                                                                     │
│             params.burnable                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         BehodlerLiteLike(behodler).addLiquidity(tokenToMigrate, balanceOfToken);                                                                                                                                │
│         uint256 scxBal = CommonIERC20(behodler).balanceOf(address(this));                                                                                                                                       │
│         CommonIERC20(behodler).transfer(params.limbo, scxBal);                                                                                                                                                  │
│         params.soul = address(0); // prevent non limbo from executing.                                                                                                                                          │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "Yes",                                                                                                                                                                                                 │
│     "2": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries, but this operation could be attacked by slippage/Sandwich Attack due to no slip limit/minimum │
│ value check                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│  function invoke(bytes32 minion, address sender) public {                                                                                                                                                       │
│     require(msg.sender == address(config.angband), "MORGOTH: angband only");                                                                                                                                    │
│     require(orchestrate(), "MORGOTH: Power invocation");                                                                                                                                                        │
│     emit PowerInvoked(sender, minion, "domain");                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│     function orchestrate() internal override returns (bool) {                                                                                                                                                   │
│         require(                                                                                                                                                                                                │
│             params.soul != address(0),                                                                                                                                                                          │
│             "MORGOTH: PowerInvoker not parameterized."                                                                                                                                                          │
│         );                                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│         uint256 balanceOfToken = CommonIERC20(params.soul).balanceOf(                                                                                                                                           │
│             address(this)                                                                                                                                                                                       │
│         );                                                                                                                                                                                                      │
│         require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                      │
│         (address baseToken, bool migrate) = TokenProxyRegistry(                                                                                                                                                 │
│             params.tokenProxyRegistry                                                                                                                                                                           │
│         ).tokenProxy(params.soul);                                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│         address tokenToMigrate = params.soul;                                                                                                                                                                   │
│         if (migrate && baseToken != address(0)) {                                                                                                                                                               │
│             tokenToMigrate = baseToken;                                                                                                                                                                         │
│             TokenProxyLike(params.soul).redeem(address(this), balanceOfToken);                                                                                                                                  │
│         }                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│         CommonIERC20(tokenToMigrate).approve(behodler, type(uint256).max);                                                                                                                                      │
│         BehodlerLiteLike(behodler).setTokenBurnable(                                                                                                                                                            │
│             tokenToMigrate,                                                                                                                                                                                     │
│             params.burnable                                                                                                                                                                                     │
│         );                                                                                                                                                                                                      │
│         BehodlerLiteLike(behodler).addLiquidity(tokenToMigrate, balanceOfToken);                                                                                                                                │
│         uint256 scxBal = CommonIERC20(behodler).balanceOf(address(this));                                                                                                                                       │
│         CommonIERC20(behodler).transfer(params.limbo, scxBal);                                                                                                                                                  │
│         params.soul = address(0); // prevent non limbo from executing.                                                                                                                                          │
│         return true;                                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function parameterize(address soul, bool burnable) public {                                                                                                                                                   │
│     require(msg.sender == params.limbo, "MORGOTH: Only Limbo can migrate tokens from Limbo.");                                                                                                                  │
│     params.soul = soul;                                                                                                                                                                                         │
│     params.burnable = burnable;                                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│  function invoke(bytes32 minion, address sender) public {                                                                                                                                                       │
│     require(msg.sender == address(config.angband), "MORGOTH: angband only");                                                                                                                                    │
│     require(orchestrate(), "MORGOTH: Power invocation");                                                                                                                                                        │
│     emit PowerInvoked(sender, minion, "domain");                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                               │
│ have code statements that get or calculate LP token's value/price                                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function orchestrate() internal returns (bool) {                                                                                                                                                              │
│     require(params.soul != address(0), "MORGOTH: PowerInvoker not parameterized.");                                                                                                                             │
│     LachesisLike lachesis = LachesisLike(config.lachesis);                                                                                                                                                      │
│     lachesis.measure(params.soul, true, params.burnable);                                                                                                                                                       │
│     lachesis.updateBehodler(params.soul);                                                                                                                                                                       │
│     uint256 balanceOfToken = IERC20(params.soul).balanceOf(address(this));                                                                                                                                      │
│     require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                          │
│     IERC20(params.soul).approve(config.behodler, type(uint256).max);                                                                                                                                            │
│     BehodlerLike(config.behodler).addLiquidity(params.soul, balanceOfToken);                                                                                                                                    │
│     uint256 scxBal = IERC20(config.behodler).balanceOf(address(this));                                                                                                                                          │
│     IERC20(config.behodler).transfer(params.limbo, scxBal);                                                                                                                                                     │
│     params.soul = address(0); // prevent non limbo from executing.                                                                                                                                              │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: involve calculating swap/liquidity or adding liquidity, and there is asset exchanges or price queries,                                                                                               │
│ have code statements that get or calculate LP token's value/price                                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│  function invoke(bytes32 minion, address sender) public {                                                                                                                                                       │
│     require(msg.sender == address(config.angband), "MORGOTH: angband only");                                                                                                                                    │
│     require(orchestrate(), "MORGOTH: Power invocation");                                                                                                                                                        │
│     emit PowerInvoked(sender, minion, "domain");                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function orchestrate() internal returns (bool) {                                                                                                                                                              │
│     require(params.soul != address(0), "MORGOTH: PowerInvoker not parameterized.");                                                                                                                             │
│     LachesisLike lachesis = LachesisLike(config.lachesis);                                                                                                                                                      │
│     lachesis.measure(params.soul, true, params.burnable);                                                                                                                                                       │
│     lachesis.updateBehodler(params.soul);                                                                                                                                                                       │
│     uint256 balanceOfToken = IERC20(params.soul).balanceOf(address(this));                                                                                                                                      │
│     require(balanceOfToken > 0, "MORGOTH: remember to seed contract");                                                                                                                                          │
│     IERC20(params.soul).approve(config.behodler, type(uint256).max);                                                                                                                                            │
│     BehodlerLike(config.behodler).addLiquidity(params.soul, balanceOfToken);                                                                                                                                    │
│     uint256 scxBal = IERC20(config.behodler).balanceOf(address(this));                                                                                                                                          │
│     IERC20(config.behodler).transfer(params.limbo, scxBal);                                                                                                                                                     │
│     params.soul = address(0); // prevent non limbo from executing.                                                                                                                                              │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {                                                                                                                       │
│     assetApproved = approved;                                                                                                                                                                                   │
│     fateGrowthStrategy = FateGrowthStrategy.indirectTwoRootEye;                                                                                                                                                 │
│     emit assetApproval(asset, approved);                                                                                                                                                                        │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ add or check approval via require/if statements before the token transfer,                                                                                                                                      │
│ Code:                                                                                                                                                                                                           │
│   function setEYEBasedAssetStake(                                                                                                                                                                               │
│     uint256 finalAssetBalance,                                                                                                                                                                                  │
│     uint256 finalEYEBalance,                                                                                                                                                                                    │
│     uint256 rootEYE,                                                                                                                                                                                            │
│     address asset                                                                                                                                                                                               │
│   ) public isLive incrementFate {                                                                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     FateGrowthStrategy strategy = fateGrowthStrategy;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //verifying that rootEYE value is accurate within precision.                                                                                                                                                │
│     uint256 rootEYESquared = rootEYE * rootEYE;                                                                                                                                                                 │
│     uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);                                                                                                                                              │
│     require(                                                                                                                                                                                                    │
│       rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,                                                                                                                             │
│       "LimboDAO: Stake EYE invariant."                                                                                                                                                                          │
│     );                                                                                                                                                                                                          │
│     AssetClout storage clout = stakedUserAssetWeight;                                                                                                                                                           │
│     fateState.fatePerDay -= clout.fateWeight;                                                                                                                                                                   │
│     uint256 initialBalance = clout.balance;                                                                                                                                                                     │
│     //EYE                                                                                                                                                                                                       │
│     if (strategy == FateGrowthStrategy.directRoot) {                                                                                                                                                            │
│       require(finalAssetBalance == finalEYEBalance, "LimboDAO: staking eye invariant.");                                                                                                                        │
│       require(asset == domainConfig.eye);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       clout.fateWeight = rootEYE;                                                                                                                                                                               │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│       fateState.fatePerDay += rootEYE;                                                                                                                                                                          │
│     } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {                                                                                                                                             │
│       //LP                                                                                                                                                                                                      │
│       clout.fateWeight = 2 * rootEYE;                                                                                                                                                                           │
│       fateState.fatePerDay += clout.fateWeight;                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);                                                                                                                                │
│       finalEYEBalance /= precision;                                                                                                                                                                             │
│       require(                                                                                                                                                                                                  │
│         finalEYEBalance == impliedEye, //precision cap                                                                                                                                                          │
│         "LimboDAO: stake invariant check 2."                                                                                                                                                                    │
│       );                                                                                                                                                                                                        │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│     } else {                                                                                                                                                                                                    │
│       revert("LimboDAO: asset growth strategy not accounted for");                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);                                                                                                                                     │
│     asset.ERC20NetTransfer(sender, address(this), netBalance);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes",                                                                                                                                                                                                   │
│   "3": "Yes",                                                                                                                                                                                                   │
│   "4": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function setEYEBasedAssetStake(                                                                                                                                                                               │
│     uint256 finalAssetBalance,                                                                                                                                                                                  │
│     uint256 finalEYEBalance,                                                                                                                                                                                    │
│     uint256 rootEYE,                                                                                                                                                                                            │
│     address asset                                                                                                                                                                                               │
│   ) public isLive incrementFate {                                                                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     FateGrowthStrategy strategy = fateGrowthStrategy;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //verifying that rootEYE value is accurate within precision.                                                                                                                                                │
│     uint256 rootEYESquared = rootEYE * rootEYE;                                                                                                                                                                 │
│     uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);                                                                                                                                              │
│     require(                                                                                                                                                                                                    │
│       rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,                                                                                                                             │
│       "LimboDAO: Stake EYE invariant."                                                                                                                                                                          │
│     );                                                                                                                                                                                                          │
│     AssetClout storage clout = stakedUserAssetWeight;                                                                                                                                                           │
│     fateState.fatePerDay -= clout.fateWeight;                                                                                                                                                                   │
│     uint256 initialBalance = clout.balance;                                                                                                                                                                     │
│     //EYE                                                                                                                                                                                                       │
│     if (strategy == FateGrowthStrategy.directRoot) {                                                                                                                                                            │
│       require(finalAssetBalance == finalEYEBalance, "LimboDAO: staking eye invariant.");                                                                                                                        │
│       require(asset == domainConfig.eye);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       clout.fateWeight = rootEYE;                                                                                                                                                                               │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│       fateState.fatePerDay += rootEYE;                                                                                                                                                                          │
│     } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {                                                                                                                                             │
│       //LP                                                                                                                                                                                                      │
│       clout.fateWeight = 2 * rootEYE;                                                                                                                                                                           │
│       fateState.fatePerDay += clout.fateWeight;                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);                                                                                                                                │
│       finalEYEBalance /= precision;                                                                                                                                                                             │
│       require(                                                                                                                                                                                                  │
│         finalEYEBalance == impliedEye, //precision cap                                                                                                                                                          │
│         "LimboDAO: stake invariant check 2."                                                                                                                                                                    │
│       );                                                                                                                                                                                                        │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│     } else {                                                                                                                                                                                                    │
│       revert("LimboDAO: asset growth strategy not accounted for");                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);                                                                                                                                     │
│     asset.ERC20NetTransfer(sender, address(this), netBalance);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: deposit/mint/add the liquidity pool/amount/share and set the total share to the number of first deposit when the supply/liquidity is 0                                                               │
│ Code:                                                                                                                                                                                                           │
│   function setEYEBasedAssetStake(                                                                                                                                                                               │
│     uint256 finalAssetBalance,                                                                                                                                                                                  │
│     uint256 finalEYEBalance,                                                                                                                                                                                    │
│     uint256 rootEYE,                                                                                                                                                                                            │
│     address asset                                                                                                                                                                                               │
│   ) public isLive incrementFate {                                                                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     FateGrowthStrategy strategy = fateGrowthStrategy;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //verifying that rootEYE value is accurate within precision.                                                                                                                                                │
│     uint256 rootEYESquared = rootEYE * rootEYE;                                                                                                                                                                 │
│     uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);                                                                                                                                              │
│     require(                                                                                                                                                                                                    │
│       rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,                                                                                                                             │
│       "LimboDAO: Stake EYE invariant."                                                                                                                                                                          │
│     );                                                                                                                                                                                                          │
│     AssetClout storage clout = stakedUserAssetWeight;                                                                                                                                                           │
│     fateState.fatePerDay -= clout.fateWeight;                                                                                                                                                                   │
│     uint256 initialBalance = clout.balance;                                                                                                                                                                     │
│     //EYE                                                                                                                                                                                                       │
│     if (strategy == FateGrowthStrategy.directRoot) {                                                                                                                                                            │
│       require(finalAssetBalance == finalEYEBalance, "LimboDAO: staking eye invariant.");                                                                                                                        │
│       require(asset == domainConfig.eye);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       clout.fateWeight = rootEYE;                                                                                                                                                                               │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│       fateState.fatePerDay += rootEYE;                                                                                                                                                                          │
│     } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {                                                                                                                                             │
│       //LP                                                                                                                                                                                                      │
│       clout.fateWeight = 2 * rootEYE;                                                                                                                                                                           │
│       fateState.fatePerDay += clout.fateWeight;                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);                                                                                                                                │
│       finalEYEBalance /= precision;                                                                                                                                                                             │
│       require(                                                                                                                                                                                                  │
│         finalEYEBalance == impliedEye, //precision cap                                                                                                                                                          │
│         "LimboDAO: stake invariant check 2."                                                                                                                                                                    │
│       );                                                                                                                                                                                                        │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│     } else {                                                                                                                                                                                                    │
│       revert("LimboDAO: asset growth strategy not accounted for");                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);                                                                                                                                     │
│     asset.ERC20NetTransfer(sender, address(this), netBalance);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer, and there is no clear/reset of the approval when the transfer finishes its main branch or encounters exceptions           │
│ Code:                                                                                                                                                                                                           │
│   function setEYEBasedAssetStake(                                                                                                                                                                               │
│     uint256 finalAssetBalance,                                                                                                                                                                                  │
│     uint256 finalEYEBalance,                                                                                                                                                                                    │
│     uint256 rootEYE,                                                                                                                                                                                            │
│     address asset                                                                                                                                                                                               │
│   ) public isLive incrementFate {                                                                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     FateGrowthStrategy strategy = fateGrowthStrategy;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //verifying that rootEYE value is accurate within precision.                                                                                                                                                │
│     uint256 rootEYESquared = rootEYE * rootEYE;                                                                                                                                                                 │
│     uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);                                                                                                                                              │
│     require(                                                                                                                                                                                                    │
│       rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,                                                                                                                             │
│       "LimboDAO: Stake EYE invariant."                                                                                                                                                                          │
│     );                                                                                                                                                                                                          │
│     AssetClout storage clout = stakedUserAssetWeight;                                                                                                                                                           │
│     fateState.fatePerDay -= clout.fateWeight;                                                                                                                                                                   │
│     uint256 initialBalance = clout.balance;                                                                                                                                                                     │
│     //EYE                                                                                                                                                                                                       │
│     if (strategy == FateGrowthStrategy.directRoot) {                                                                                                                                                            │
│       require(finalAssetBalance == finalEYEBalance, "LimboDAO: staking eye invariant.");                                                                                                                        │
│       require(asset == domainConfig.eye);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       clout.fateWeight = rootEYE;                                                                                                                                                                               │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│       fateState.fatePerDay += rootEYE;                                                                                                                                                                          │
│     } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {                                                                                                                                             │
│       //LP                                                                                                                                                                                                      │
│       clout.fateWeight = 2 * rootEYE;                                                                                                                                                                           │
│       fateState.fatePerDay += clout.fateWeight;                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);                                                                                                                                │
│       finalEYEBalance /= precision;                                                                                                                                                                             │
│       require(                                                                                                                                                                                                  │
│         finalEYEBalance == impliedEye, //precision cap                                                                                                                                                          │
│         "LimboDAO: stake invariant check 2."                                                                                                                                                                    │
│       );                                                                                                                                                                                                        │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│     } else {                                                                                                                                                                                                    │
│       revert("LimboDAO: asset growth strategy not accounted for");                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);                                                                                                                                     │
│     asset.ERC20NetTransfer(sender, address(this), netBalance);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ add or check approval via require/if statements before the token transfer,                                                                                                                                      │
│ Code:                                                                                                                                                                                                           │
│   function burnAsset(address asset, uint256 amount) public isLive incrementFate {                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     require(ERC677(asset).transferFrom(sender, address(this), amount), "LimboDAO: transferFailed");                                                                                                             │
│     uint256 fateCreated = fateState[_msgSender()].fateBalance;                                                                                                                                                  │
│     if (asset == domainConfig.eye) {                                                                                                                                                                            │
│       fateCreated = amount * 10;                                                                                                                                                                                │
│       ERC677(domainConfig.eye).burn(amount);                                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * amount) / ONE;                                                                                                                                                         │
│       fateCreated = impliedEye * 20;                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     fateState[_msgSender()].fateBalance += fateCreated;                                                                                                                                                         │
│     emit assetBurnt(_msgSender(), asset, fateCreated);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No",                                                                                                                                                                                                    │
│   "3": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: add or check approval via require/if statements before the token transfer, and there is no clear/reset of the approval when the transfer finishes its main branch or encounters exceptions           │
│ Code:                                                                                                                                                                                                           │
│   function burnAsset(address asset, uint256 amount) public isLive incrementFate {                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     require(ERC677(asset).transferFrom(sender, address(this), amount), "LimboDAO: transferFailed");                                                                                                             │
│     uint256 fateCreated = fateState[_msgSender()].fateBalance;                                                                                                                                                  │
│     if (asset == domainConfig.eye) {                                                                                                                                                                            │
│       fateCreated = amount * 10;                                                                                                                                                                                │
│       ERC677(domainConfig.eye).burn(amount);                                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * amount) / ONE;                                                                                                                                                         │
│       fateCreated = impliedEye * 20;                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     fateState[_msgSender()].fateBalance += fateCreated;                                                                                                                                                         │
│     emit assetBurnt(_msgSender(), asset, fateCreated);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "balance": "Variable holding the token balance calculation"                                                                                                                                                 │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "accumulatedFlanPerShare": "Variable holding the calculated value of LP token"                                                                                                                              │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:35] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/Limbo.sol, current function:      tasks.py:260
                             updateSoul, current vul: price-manipulation                                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "soul": "Holds the market reserves/AMMprice/exchangeRate"                                                                                                                                                   │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/Limbo.sol, current function:      tasks.py:359
                             updateSoul, current vul: price-manipulation                                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "daiToRelease": "Variable holding the calculated value of daiToRelease"                                                                                                                                     │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "dai_scx": "Variable holding the calculated value/price of LP token"                                                                                                                                        │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:36] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/UniswapHelper.sol, current        tasks.py:260
                             function: getLatestFLNQuote, current vul: price-manipulation                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "latestFlanQuotes[0].DaiScxSpotPrice": "Holds the market reserves/AMM price/exchange rate",                                                                                                                 │
│     "latestFlanQuotes[0].DaiBalanceOnBehodler": "Holds the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                                     │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "latestFlanQuotes[0].blockProduced": "Holds the calculated value/price of LP token"                                                                                                                         │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:37] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/UniswapHelper.sol, current        tasks.py:359
                             function: getLatestFLNQuote, current vul: price-manipulation                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;`                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function purchasePyroFlan(address stablecoin, uint256 amount) external {                                                                                                                                      │
│     uint normalizedAmount = normalize(stablecoin, amount);                                                                                                                                                      │
│     address flanLP = config.flanLPs;                                                                                                                                                                            │
│     address pyroFlanLP = config.pyroFlanLPs;                                                                                                                                                                    │
│     require(flanLP != address(0) && pyroFlanLP != address(0), "BACKSTOP: configure stablecoin");                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                        │
│     uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                       │
│     uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;                                                                                                             │
│                                                                                                                                                                                                                 │
│     //Price tilt pairs and mint liquidity                                                                                                                                                                       │
│     FlanLike(config.flan).mint(address(this), normalizedAmount / 2);                                                                                                                                            │
│     IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);                                                                                                                                                 │
│     IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     UniPairLike(flanLP).mint(address(this));                                                                                                                                                                    │
│     uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                           │
│     PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);                                                                                                                                        │
│     UniPairLike(pyroFlanLP).mint(address(this));                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);                                                                                                                                              │
│     uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;                                                                                                                         │
│     require(tiltedPrice < config.acceptableHighestPrice, "BACKSTOP: potential price manipulation");                                                                                                             │
│     uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return                                                                                             │
│     uint256 premium = (flanToMint * (growth / 2)) / 100;                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     FlanLike(config.flan).mint(address(this), flanToMint + premium);                                                                                                                                            │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│     PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);                                                                                                                                      │
│     redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);`                                                                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:38] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/FlanBackstop.sol, current         tasks.py:260
                             function: purchasePyroFlan, current vul: wrong-order-interest                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balanceOfBase": "Variable holding the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                    │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "balanceOfBase": "Variable holding the calculated value/price of LP token"                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:39] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:260
                             current function: redeemRate, current vul: price-manipulation                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "baseBalance": "Variable that holds the base token balance of the contract"                                                                                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "proxy": "Variable that holds the calculated value of LP token"                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:40] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:359
                             current function: redeemRate, current vul: price-manipulation                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "balanceOfBase": "Holds the value of total minted share or amount"                                                                                                                                      │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "totalSupply()": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                        │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "balanceOfBase": "Holds the value of the deposit/mint/add amount"                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:41] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:260
                             current function: redeemRate, current vul: first-deposit                                                                                                                              
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_redeemRate": "Holds the value of total minted share or amount"                                                                                                                                        │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "baseBalance": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                          │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:42] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:359
                             current function: redeemRate, current vul: first-deposit                                                                                                                              
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "pyroTokenRedeemRate": "Holds the redeem rate of PyroToken"                                                                                                                                                 │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "mintedPyroTokens": "Holds the calculated value of minted Pyro tokens"                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:43] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:359
                             current function: redeemRate, current vul: price-manipulation                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_redeemRate": "Variable holding the market reserves/AMM price/exchange rate calculation"                                                                                                                   │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "baseTokens": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:359
                             current function: redeemRate, current vul: price-manipulation                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "balanceOfFlan": "Variable holding the balance of Flan tokens in flanLP",                                                                                                                                   │
│     "balanceOfStable": "Variable holding the balance of stablecoin tokens in flanLP",                                                                                                                           │
│     "tiltedPrice": "Variable holding the calculated tilted price"                                                                                                                                               │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "flanToMint": "Variable holding the calculated amount of Flan tokens to mint"                                                                                                                               │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:44] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:359
                             current function: redeemRate, current vul: price-manipulation                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "flanToMint": "Holds the value of total minted share or amount"                                                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "balanceOfStableBefore": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableC": {                                                                                                                                                                                                │
│     "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:46] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:359
                             current function: redeemRate, current vul: first-deposit                                                                                                                              
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "baseBalance": "Variable that holds the base token balance of the contract"                                                                                                                             │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "proxy": "Variable that holds the calculated value of LP token"                                                                                                                                         │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:260
                             current function: mint, current vul: price-manipulation                                                                                                                               
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "priceBefore": "Variable holding the calculated price before the transaction"                                                                                                                               │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "tiltedPrice": "Variable holding the calculated tilted price after the transaction"                                                                                                                         │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:47] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/TokenProxies/RebaseProxy.sol,     tasks.py:359
                             current function: mint, current vul: price-manipulation                                                                                                                               
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "limboBalance": "Variable holding the market reserves/AMMprice/exchangeRate calculation"                                                                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "accumulated": "Variable holding the calculated value/price of LP token"                                                                                                                                    │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:48] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/periphery/SoulReader.sol, current tasks.py:260
                             function: GetPendingReward, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function ExpectedCrossingBonusRate(                                                                                                                                                                           │
│     address holder,                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     address _limbo                                                                                                                                                                                              │
│   ) public view returns (uint256 bonusRate) {                                                                                                                                                                   │
│     LimboLike limbo = getLimbo(_limbo);                                                                                                                                                                         │
│     uint256 latestIndex = limbo.latestIndex(token);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     (uint256 stakedAmount, , bool bonusPaid) = limbo.userInfo(token, holder, latestIndex);                                                                                                                      │
│     if (bonusPaid) return 0;                                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     (uint256 stakingBegins, uint256 stakingEnds, int256 crossingBonusDelta, uint256 initialCrossingBonus, ) = limbo                                                                                             │
│       .tokenCrossingParameters(token, latestIndex);                                                                                                                                                             │
│     stakingEnds = stakingEnds == 0 ? block.timestamp : stakingEnds;                                                                                                                                             │
│     stakingBegins = stakingBegins == 0 ? block.timestamp - 1 : stakingBegins;                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     int256 accumulatedFlanPerTeraToken = crossingBonusDelta * int256(stakingEnds - stakingBegins);                                                                                                              │
│     // console.log("token: %d", token);                                                                                                                                                                         │
│     // console.log("time elapsed %d", stakingEnds - stakingBegins);                                                                                                                                             │
│     // console.log(                                                                                                                                                                                             │
│     //   "accumulatedFlanPerTeraToken %d, initialCrossingBonus %d",                                                                                                                                             │
│     //   uint256(accumulatedFlanPerTeraToken),                                                                                                                                                                  │
│     //   uint256(initialCrossingBonus)                                                                                                                                                                          │
│     // );                                                                                                                                                                                                       │
│     int256 finalFlanPerTeraToken = int256(initialCrossingBonus) +                                                                                                                                               │
│       (stakedAmount > 0 ? accumulatedFlanPerTeraToken : int256(0));                                                                                                                                             │
│     bonusRate = finalFlanPerTeraToken > 0 ? uint256(finalFlanPerTeraToken) : 0;                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `accumulatedFlanPerTeraToken = crossingBonusDelta * int256(stakingEnds - stakingBegins);`.                                                       │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function ExpectedCrossingBonusRate(                                                                                                                                                                           │
│     address holder,                                                                                                                                                                                             │
│     address token,                                                                                                                                                                                              │
│     address _limbo                                                                                                                                                                                              │
│   ) public view returns (uint256 bonusRate) {                                                                                                                                                                   │
│     LimboLike limbo = getLimbo(_limbo);                                                                                                                                                                         │
│     uint256 latestIndex = limbo.latestIndex(token);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     (uint256 stakedAmount, , bool bonusPaid) = limbo.userInfo(token, holder, latestIndex);                                                                                                                      │
│     if (bonusPaid) return 0;                                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     (uint256 stakingBegins, uint256 stakingEnds, int256 crossingBonusDelta, uint256 initialCrossingBonus, ) = limbo                                                                                             │
│       .tokenCrossingParameters(token, latestIndex);                                                                                                                                                             │
│     stakingEnds = stakingEnds == 0 ? block.timestamp : stakingEnds;                                                                                                                                             │
│     stakingBegins = stakingBegins == 0 ? block.timestamp - 1 : stakingBegins;                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     int256 accumulatedFlanPerTeraToken = crossingBonusDelta * int256(stakingEnds - stakingBegins);                                                                                                              │
│     // console.log("token: %d", token);                                                                                                                                                                         │
│     // console.log("time elapsed %d", stakingEnds - stakingBegins);                                                                                                                                             │
│     // console.log(                                                                                                                                                                                             │
│     //   "accumulatedFlanPerTeraToken %d, initialCrossingBonus %d",                                                                                                                                             │
│     //   uint256(accumulatedFlanPerTeraToken),                                                                                                                                                                  │
│     //   uint256(initialCrossingBonus)                                                                                                                                                                          │
│     // );                                                                                                                                                                                                       │
│     int256 finalFlanPerTeraToken = int256(initialCrossingBonus) +                                                                                                                                               │
│       (stakedAmount > 0 ? accumulatedFlanPerTeraToken : int256(0));                                                                                                                                             │
│     bonusRate = finalFlanPerTeraToken > 0 ? uint256(finalFlanPerTeraToken) : 0;                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `finalFlanPerTeraToken = int256(initialCrossingBonus) + (stakedAmount > 0 ? accumulatedFlanPerTeraToken : int256(0));`                                                                                          │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:49] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/periphery/SoulReader.sol, current tasks.py:260
                             function: ExpectedCrossingBonusRate, current vul: wrong-order-interest                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "weth10Balance": "Variable that holds the market reserves/AMMprice/exchangeRate calculation"                                                                                                                │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pyroWethBalance": "Variable that holds the calculated value/price of LP token"                                                                                                                             │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:50] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/PyroWethProxy.sol, current                    
                             function: mint, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "balanceOfFlanBefore": "Variable holding the balance of the 'flan' token before the transaction",                                                                                                           │
│     "balanceOfStableBefore": "Variable holding the balance of the stablecoin before the transaction",                                                                                                           │
│     "priceBefore": "Variable holding the calculated price before the transaction",                                                                                                                              │
│     "balanceOfFlan": "Variable holding the balance of the 'flan' token after the transaction",                                                                                                                  │
│     "balanceOfStable": "Variable holding the balance of the stablecoin after the transaction",                                                                                                                  │
│     "tiltedPrice": "Variable holding the tilted price after the transaction",                                                                                                                                   │
│     "growth": "Variable holding the growth percentage after the transaction",                                                                                                                                   │
│     "flanToMint": "Variable holding the amount of 'flan' tokens to mint after the transaction",                                                                                                                 │
│     "premium": "Variable holding the premium amount after the transaction"                                                                                                                                      │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "flanToMint": "Variable holding the calculated value of LP tokens to mint after the transaction"                                                                                                            │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:52] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/PyroWethProxy.sol, current                    
                             function: mint, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function calculateMintedPyroWeth(uint256 baseTokenAmount) external view returns (uint256) {                                                                                                                   │
│     uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();                                                                                                                                        │
│     uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);                                                                                                                                 │
│     return (mintedPyroTokens * 999) / 1000; //0.1% fee                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();`                                                                                                                                          │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function calculateMintedPyroWeth(uint256 baseTokenAmount) external view returns (uint256) {                                                                                                                   │
│     uint256 pyroTokenRedeemRate = PyroTokenLike(baseToken).redeemRate();                                                                                                                                        │
│     uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);                                                                                                                                 │
│     return (mintedPyroTokens * 999) / 1000; //0.1% fee                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 mintedPyroTokens = (baseTokenAmount * ONE) / (pyroTokenRedeemRate);`                                                                                                                                   │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:53] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/PyroWethProxy.sol, current                    
                             function: calculateMintedPyroWeth, current vul: wrong-order-interest                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "trueTransfer": "Variable holding the calculated value of transferred tokens"                                                                                                                               │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pyro": "Variable holding the calculated value of LP tokens to be minted"                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: mint, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "balanceOfFlanBefore": "Variable holding the balance of 'flan' token before the transaction",                                                                                                               │
│     "balanceOfStableBefore": "Variable holding the balance of 'stablecoin' token before the transaction",                                                                                                       │
│     "priceBefore": "Variable holding the calculated price before the transaction",                                                                                                                              │
│     "balanceOfFlan": "Variable holding the balance of 'flan' token after the transaction",                                                                                                                      │
│     "balanceOfStable": "Variable holding the balance of 'stablecoin' token after the transaction",                                                                                                              │
│     "tiltedPrice": "Variable holding the tilted price after the transaction",                                                                                                                                   │
│     "growth": "Variable holding the growth percentage after the transaction",                                                                                                                                   │
│     "flanToMint": "Variable holding the amount of 'flan' tokens to mint after the transaction",                                                                                                                 │
│     "premium": "Variable holding the premium amount to incentivize minting"                                                                                                                                     │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "flanToMint": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:55] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: mint, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "balanceOfBase": "Variable holding the base token balance of the contract"                                                                                                                                  │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "balanceOfBase": "Variable holding the calculated value/price of LP token"                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:57] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "baseBalance": "Variable holding the base token balance of the contract"                                                                                                                                │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "proxy": "Variable holding the calculated value of LP tokens"                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_totalSupply": "Holds the value of total minted share or amount"                                                                                                                                           │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_totalSupply": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableC": {                                                                                                                                                                                                │
│     "balanceOfBase": "Holds the value of the deposit/mint/add amount"                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:58] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: first-deposit                                                                                                                                      
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_redeemRate": "Holds the value of total minted share or amount"                                                                                                                                        │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "baseBalance": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                          │
│     },                                                                                                                                                                                                          │
│     "VariableC": {                                                                                                                                                                                              │
│         "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:35:59] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: first-deposit                                                                                                                                      
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "VariableA": {                                                                                                                                                                                              │
│         "_redeemRate": "Holds the market reserves/AMM price/exchange rate calculation"                                                                                                                          │
│     },                                                                                                                                                                                                          │
│     "VariableB": {                                                                                                                                                                                              │
│         "baseTokens": "Holds the calculated value/price of LP token"                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:00] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "pyroTokenRedeemRate": "Holds the redeem rate of PyroToken"                                                                                                                                                 │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "mintedPyroTokens": "Holds the calculated value of minted Pyro tokens"                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:01] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_redeemRate": "Variable holding the market reserves/AMM price/exchange rate calculation"                                                                                                                   │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "baseTokens": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:02] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "priceBefore": "Variable holding the calculated price before the transaction"                                                                                                                               │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "tiltedPrice": "Variable holding the calculated tilted price after the transaction"                                                                                                                         │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: price-manipulation                                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "flanToMint": "Holds the value of total minted share or amount"                                                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "balanceOfStableBefore": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableC": {                                                                                                                                                                                                │
│     "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:06] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: redeemRate, current vul: first-deposit                                                                                                                                      
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `uint256 rate = redeemRate();`.                                                                                                                  │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function setObligationFor(                                                                                                                                                                                    │
│     address borrower,                                                                                                                                                                                           │
│     uint256 baseTokenBorrowed,                                                                                                                                                                                  │
│     uint256 pyroTokenStaked                                                                                                                                                                                     │
│   ) external onlyLoanOfficer nonReentrant returns (bool success) {                                                                                                                                              │
│     DebtObligation memory currentDebt = debtObligations;                                                                                                                                                        │
│     uint256 rate = redeemRate();                                                                                                                                                                                │
│     uint256 minPyroStake = (baseTokenBorrowed * ONE) / rate;                                                                                                                                                    │
│     require(pyroTokenStaked >= minPyroStake, "Pyro: Unsustainable loan.");                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     int256 netStake = int256(pyroTokenStaked) - int256(currentDebt.pyro);                                                                                                                                       │
│     uint256 stake;                                                                                                                                                                                              │
│     if (netStake > 0) {                                                                                                                                                                                         │
│       stake = uint256(netStake);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│       uint256 currentAllowance = _allowances[_msgSender()];                                                                                                                                                     │
│       _approve(borrower, _msgSender(), currentAllowance - stake);                                                                                                                                               │
│                                                                                                                                                                                                                 │
│       _balances -= stake;                                                                                                                                                                                       │
│       _balances += stake;                                                                                                                                                                                       │
│     } else if (netStake < 0) {                                                                                                                                                                                  │
│       stake = uint256(-netStake);                                                                                                                                                                               │
│       _balances += stake;                                                                                                                                                                                       │
│       _balances -= stake;                                                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     int256 netBorrowing = int256(baseTokenBorrowed) - int256(currentDebt.base);                                                                                                                                 │
│     if (netBorrowing > 0) {                                                                                                                                                                                     │
│       config.baseToken.transfer(borrower, uint256(netBorrowing));                                                                                                                                               │
│     } else if (netBorrowing < 0) {                                                                                                                                                                              │
│       config.baseToken.transferFrom(borrower, address(this), uint256(-netBorrowing));                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     success = true;                                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `debtObligations = DebtObligation(baseTokenBorrowed, pyroTokenStaked, rate);`                                                                                                                                   │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:07] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LiquidityReceiver.sol, current                
                             function: setObligationFor, current vul: wrong-order-interest                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_totalSupply": "Holds the value of total minted share or amount"                                                                                                                                           │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_totalSupply": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableC": {                                                                                                                                                                                                │
│     "value": "Holds the value of the deposit/mint/add amount"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:08] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/BehodlerLite.sol, current                     
                             function: mint, current vul: first-deposit                                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "deltaSCX": "Holds the value of total minted share or amount."                                                                                                                                              │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "initialBalance": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0."                                                                          │
│   },                                                                                                                                                                                                            │
│   "VariableC": {                                                                                                                                                                                                │
│     "amount": "Holds the value of the deposit/mint/add amount."                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:09] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/BehodlerLite.sol, current                     
                             function: mint, current vul: first-deposit                                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "balances": "Custom token balanceOf/totalSupply/amount/liquidity calculation",                                                                                                                              │
│     "_totalSupply": "Custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                                                                           │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_totalSupply": "Calculated value/price of LP token"                                                                                                                                                        │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:10] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/BehodlerLite.sol, current                     
                             function: mint, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "priceBefore": "Variable holding the calculated price before the transaction"                                                                                                                               │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "tiltedPrice": "Variable holding the calculated tilted price after the transaction"                                                                                                                         │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:11] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/BehodlerLite.sol, current                     
                             function: mint, current vul: price-manipulation                                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "flanToMint": "Holds the value of total minted share or amount"                                                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "balanceOfStableBefore": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableC": {                                                                                                                                                                                                │
│     "amount": "Holds the value of the deposit/mint/add amount"                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:12] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/BehodlerLite.sol, current                     
                             function: mint, current vul: first-deposit                                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableName": "balanceOfToken"                                                                                                                                                                              │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LimboAddTokenToBehodler.sol,                  
                             current function: orchestrate, current vul: no-slippage-limit-check                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableName": ""                                                                                                                                                                                            │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:13] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/testing/realBehodler/LimboAddTokenToBehodler.sol,                  
                             current function: orchestrate, current vul: no-slippage-limit-check                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function setEYEBasedAssetStake(                                                                                                                                                                               │
│     uint256 finalAssetBalance,                                                                                                                                                                                  │
│     uint256 finalEYEBalance,                                                                                                                                                                                    │
│     uint256 rootEYE,                                                                                                                                                                                            │
│     address asset                                                                                                                                                                                               │
│   ) public isLive incrementFate {                                                                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     FateGrowthStrategy strategy = fateGrowthStrategy;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //verifying that rootEYE value is accurate within precision.                                                                                                                                                │
│     uint256 rootEYESquared = rootEYE * rootEYE;                                                                                                                                                                 │
│     uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);                                                                                                                                              │
│     require(                                                                                                                                                                                                    │
│       rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,                                                                                                                             │
│       "LimboDAO: Stake EYE invariant."                                                                                                                                                                          │
│     );                                                                                                                                                                                                          │
│     AssetClout storage clout = stakedUserAssetWeight;                                                                                                                                                           │
│     fateState.fatePerDay -= clout.fateWeight;                                                                                                                                                                   │
│     uint256 initialBalance = clout.balance;                                                                                                                                                                     │
│     //EYE                                                                                                                                                                                                       │
│     if (strategy == FateGrowthStrategy.directRoot) {                                                                                                                                                            │
│       require(finalAssetBalance == finalEYEBalance, "LimboDAO: staking eye invariant.");                                                                                                                        │
│       require(asset == domainConfig.eye);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       clout.fateWeight = rootEYE;                                                                                                                                                                               │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│       fateState.fatePerDay += rootEYE;                                                                                                                                                                          │
│     } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {                                                                                                                                             │
│       //LP                                                                                                                                                                                                      │
│       clout.fateWeight = 2 * rootEYE;                                                                                                                                                                           │
│       fateState.fatePerDay += clout.fateWeight;                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);                                                                                                                                │
│       finalEYEBalance /= precision;                                                                                                                                                                             │
│       require(                                                                                                                                                                                                  │
│         finalEYEBalance == impliedEye, //precision cap                                                                                                                                                          │
│         "LimboDAO: stake invariant check 2."                                                                                                                                                                    │
│       );                                                                                                                                                                                                        │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│     } else {                                                                                                                                                                                                    │
│       revert("LimboDAO: asset growth strategy not accounted for");                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);                                                                                                                                     │
│     asset.ERC20NetTransfer(sender, address(this), netBalance);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `ONE`                                                                                                                                                                                                           │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/DAO/LimboDAO.sol, current         tasks.py:260
                             function: setEYEBasedAssetStake, current vul: wrong-order-interest                                                                                                                    
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "clout.balance": "Holds the value of total minted share or amount"                                                                                                                                          │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "totalSupply": "Holds the total supply/liquidity AND is used by the conditional branch to determine the supply/liquidity is 0"                                                                              │
│   },                                                                                                                                                                                                            │
│   "VariableC": {                                                                                                                                                                                                │
│     "finalAssetBalance": "Holds the value of the deposit/mint/add amount"                                                                                                                                       │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:15] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/DAO/LimboDAO.sol, current         tasks.py:260
                             function: setEYEBasedAssetStake, current vul: first-deposit                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: Which statement add or check approval via require/if statements before the token transfer? Answer only ZERO or ONE statement, cover the code with backquotes.                                        │
│ Code:                                                                                                                                                                                                           │
│   function setEYEBasedAssetStake(                                                                                                                                                                               │
│     uint256 finalAssetBalance,                                                                                                                                                                                  │
│     uint256 finalEYEBalance,                                                                                                                                                                                    │
│     uint256 rootEYE,                                                                                                                                                                                            │
│     address asset                                                                                                                                                                                               │
│   ) public isLive incrementFate {                                                                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     FateGrowthStrategy strategy = fateGrowthStrategy;                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     //verifying that rootEYE value is accurate within precision.                                                                                                                                                │
│     uint256 rootEYESquared = rootEYE * rootEYE;                                                                                                                                                                 │
│     uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);                                                                                                                                              │
│     require(                                                                                                                                                                                                    │
│       rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,                                                                                                                             │
│       "LimboDAO: Stake EYE invariant."                                                                                                                                                                          │
│     );                                                                                                                                                                                                          │
│     AssetClout storage clout = stakedUserAssetWeight;                                                                                                                                                           │
│     fateState.fatePerDay -= clout.fateWeight;                                                                                                                                                                   │
│     uint256 initialBalance = clout.balance;                                                                                                                                                                     │
│     //EYE                                                                                                                                                                                                       │
│     if (strategy == FateGrowthStrategy.directRoot) {                                                                                                                                                            │
│       require(finalAssetBalance == finalEYEBalance, "LimboDAO: staking eye invariant.");                                                                                                                        │
│       require(asset == domainConfig.eye);                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       clout.fateWeight = rootEYE;                                                                                                                                                                               │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│       fateState.fatePerDay += rootEYE;                                                                                                                                                                          │
│     } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {                                                                                                                                             │
│       //LP                                                                                                                                                                                                      │
│       clout.fateWeight = 2 * rootEYE;                                                                                                                                                                           │
│       fateState.fatePerDay += clout.fateWeight;                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);                                                                                                                                │
│       finalEYEBalance /= precision;                                                                                                                                                                             │
│       require(                                                                                                                                                                                                  │
│         finalEYEBalance == impliedEye, //precision cap                                                                                                                                                          │
│         "LimboDAO: stake invariant check 2."                                                                                                                                                                    │
│       );                                                                                                                                                                                                        │
│       clout.balance = finalAssetBalance;                                                                                                                                                                        │
│     } else {                                                                                                                                                                                                    │
│       revert("LimboDAO: asset growth strategy not accounted for");                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│     int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);                                                                                                                                     │
│     asset.ERC20NetTransfer(sender, address(this), netBalance);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `require(assetApproved, "LimboDAO: illegal asset");`                                                                                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/DAO/LimboDAO.sol, current         tasks.py:260
                             function: setEYEBasedAssetStake, current vul: approval-not-clear                                                                                                                      
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: Which statement add or check approval via require/if statements before the token transfer? Answer only ZERO or ONE statement, cover the code with backquotes.                                        │
│ Code:                                                                                                                                                                                                           │
│   function burnAsset(address asset, uint256 amount) public isLive incrementFate {                                                                                                                               │
│     require(assetApproved, "LimboDAO: illegal asset");                                                                                                                                                          │
│     address sender = _msgSender();                                                                                                                                                                              │
│     require(ERC677(asset).transferFrom(sender, address(this), amount), "LimboDAO: transferFailed");                                                                                                             │
│     uint256 fateCreated = fateState[_msgSender()].fateBalance;                                                                                                                                                  │
│     if (asset == domainConfig.eye) {                                                                                                                                                                            │
│       fateCreated = amount * 10;                                                                                                                                                                                │
│       ERC677(domainConfig.eye).burn(amount);                                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);                                                                                                                                     │
│       require(actualEyeBalance > 0, "LimboDAO: No EYE");                                                                                                                                                        │
│       uint256 totalSupply = IERC20(asset).totalSupply();                                                                                                                                                        │
│       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;                                                                                                                                              │
│       uint256 impliedEye = (eyePerUnit * amount) / ONE;                                                                                                                                                         │
│       fateCreated = impliedEye * 20;                                                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     fateState[_msgSender()].fateBalance += fateCreated;                                                                                                                                                         │
│     emit assetBurnt(_msgSender(), asset, fateCreated);                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `require(assetApproved, "LimboDAO: illegal asset");`                                                                                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:36:16] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-01-behodler-main/contracts/DAO/LimboDAO.sol, current         tasks.py:260
                             function: burnAsset, current vul: approval-not-clear                                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                   Summary                   
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value              ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 44                 │
│ Contracts            │ 89                 │
│ Functions            │ 122                │
│ Lines of Code        │ 5467               │
│ Used Time            │ 287.46605038642883 │
│ Estimated Cost (USD) │ 0.1623385          │
└──────────────────────┴────────────────────┘
