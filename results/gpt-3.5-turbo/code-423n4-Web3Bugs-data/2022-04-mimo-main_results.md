

  .oooooo.    ooooooooo.   ooooooooooooo  .oooooo..o                                 
 d8P'  `Y8b   `888   `Y88. 8'   888   `8 d8P'    `Y8                                 
888            888   .d88'      888      Y88bo.       .ooooo.   .oooo.   ooo. .oo.   
888            888ooo88P'       888       `"Y8888o.  d88' `"Y8 `P  )88b  `888P"Y88b  
888     ooooo  888              888           `"Y88b 888        .oP"888   888   888  
`88.    .88'   888              888      oo     .d8P 888   .o8 d8(  888   888   888  
 `Y8bood8P'   o888o            o888o     8""88888P'  `Y8bod8P' `Y888""8o o888o o888o                                                        


                                                                   

[19:52:39] Loaded 10 rules                                                                                                                                                                                       tasks.py:119
[12/08/24 19:52:39] INFO     CryticCompile: 'npx hardhat clean' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main)                           subprocess.py:41
[12/08/24 19:52:41] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                              subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                          subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                                         
                             stdout: Ok to proceed? (y)                                                                                                                                                                      
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                                       subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_52_40_041Z-debug-0.log                                                                        
                    INFO     CryticCompile: 'npx hardhat clean --global' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main)                  subprocess.py:41
[12/08/24 19:55:07] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_52_41_956Z-debug-0.log                                                              
[12/08/24 19:55:09] INFO     CryticCompile: Problem executing hardhat: npm warn exec The following package was not found and will be installed: hardhat@2.22.17                                      hardhat.py:327
                             npm error Invalid Version:                                                                                                                                                            
                             npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_55_07_809Z-debug-0.log                                                                      
                                                                                                                                                                                                                   
                    INFO     CryticCompile: 'npx hardhat compile --force' running (wd: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main)       subprocess.py:41
[12/08/24 19:55:10] ERROR    CryticCompile: 'npx' returned non-zero exit code 1                                                                                                                    subprocess.py:60
                    ERROR    CryticCompile: Need to install the following packages:                                                                                                                subprocess.py:66
                             stdout: hardhat@2.22.17                                                                                                                                                               
                             stdout: Ok to proceed? (y)                                                                                                                                                            
                    ERROR    CryticCompile: npm error Invalid Version:                                                                                                                             subprocess.py:68
                             stderr: npm error A complete log of this run can be found in: /home/owen/.npm/_logs/2024-12-09T02_55_09_088Z-debug-0.log                                                              
[19:55:10] Traceback (most recent call last):                                                                                                                                                          tasks.py:126
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 90, in __init__                                                                     
               crytic_compile = CryticCompile(target, **kwargs)                                                                                                                                                    
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 131, in __init__                                                    
               self._compile(**kwargs)                                                                                                                                                                             
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/crytic_compile.py", line 553, in _compile                                                    
               self._platform.compile(self, **kwargs)                                                                                                                                                              
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 183, in compile                                                   
               hardhat_like_parsing(crytic_compile, self._target, build_directory, hardhat_working_dir)                                                                                                            
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/crytic_compile/platform/hardhat.py", line 52, in hardhat_like_parsing                                       
               raise InvalidCompilation(txt)                                                                                                                                                                       
           crytic_compile.platform.exceptions.InvalidCompilation: Compilation failed. Can you run build command?                                                                                                   
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/artifacts/build-info is not a directory.                                                           
                                                                                                                                                                                                                   
           During handling of the above exception, another exception occurred:                                                                                                                                     
                                                                                                                                                                                                                   
           Traceback (most recent call last):                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 124, in simple_cli                                                                                                         
               falcon_instance = compile_project(source_dir)                                                                                                                                                       
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 103, in compile_project                                                                                                    
               return falcon.Falcon(abs_path)                                                                                                                                                                      
             File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/.venv/lib/python3.10/site-packages/falcon/falcon.py", line 94, in __init__                                                                     
               raise FalconError(f"Invalid compilation: \n{str(e)}")                                                                                                                                               
           falcon.exceptions.FalconError: Invalid compilation:                                                                                                                                                     
           Compilation failed. Can you run build command?                                                                                                                                                          
           /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/artifacts/build-info is not a directory.                                                           
                                                                                                                                                                                                                   
           Compile failed.                                                                                                                                                                             tasks.py:127
           Since the compilation is failed, some static analysis tool may not be enabled, which may cause lower precision and recall.                                                                  tasks.py:128
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function leverageOperation(                                                                                                                                                                                   │
│     IERC20 token,                                                                                                                                                                                               │
│     uint256 flashloanRepayAmount,                                                                                                                                                                               │
│     bytes memory params                                                                                                                                                                                         │
│   ) internal {                                                                                                                                                                                                  │
│     leverageSwap(params, token);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     require(token.balanceOf(address(this)) >= flashloanRepayAmount, "SV101");                                                                                                                                   │
│     a.core().deposit(address(token), token.balanceOf(address(this)) - flashloanRepayAmount);                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function executeOperation(                                                                                                                                                                                    │
│     address[] calldata assets,                                                                                                                                                                                  │
│     uint256[] calldata amounts,                                                                                                                                                                                 │
│     uint256[] calldata premiums,                                                                                                                                                                                │
│     address,                                                                                                                                                                                                    │
│     bytes calldata params                                                                                                                                                                                       │
│   ) external returns (bool) {                                                                                                                                                                                   │
│     require(msg.sender == address(lendingPool), "SV002");                                                                                                                                                       │
│     (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));                                                                                                               │
│     IERC20 asset = IERC20(assets[0]);                                                                                                                                                                           │
│     uint256 flashloanRepayAmount = amounts[0] + premiums[0];                                                                                                                                                    │
│     if (operation == Operation.LEVERAGE) {                                                                                                                                                                      │
│       leverageOperation(asset, flashloanRepayAmount, operationParams);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     if (operation == Operation.REBALANCE) {                                                                                                                                                                     │
│       rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);                                                                                                                             │
│     }                                                                                                                                                                                                           │
│     if (operation == Operation.EMPTY) {                                                                                                                                                                         │
│       emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     asset.approve(address(lendingPool), flashloanRepayAmount);                                                                                                                                                  │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function leverageOperation(                                                                                                                                                                                   │
│     IERC20 token,                                                                                                                                                                                               │
│     uint256 flashloanRepayAmount,                                                                                                                                                                               │
│     bytes memory params                                                                                                                                                                                         │
│   ) internal {                                                                                                                                                                                                  │
│     leverageSwap(params, token);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     require(token.balanceOf(address(this)) >= flashloanRepayAmount, "SV101");                                                                                                                                   │
│     a.core().deposit(address(token), token.balanceOf(address(this)) - flashloanRepayAmount);                                                                                                                    │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function rebalanceOperation(                                                                                                                                                                                  │
│     IERC20 fromCollateral,                                                                                                                                                                                      │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 flashloanRepayAmount,                                                                                                                                                                               │
│     bytes memory params                                                                                                                                                                                         │
│   ) internal {                                                                                                                                                                                                  │
│     (uint256 vaultId, address toCollateral, uint256 parAmount, bytes memory dexTxData, uint dexIndex) = abi                                                                                                     │
│       .decode(params, (uint256, address, uint256, bytes, uint ));                                                                                                                                               │
│     aggregatorSwap(dexIndex, fromCollateral, amount, dexTxData);                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 depositAmount = IERC20(toCollateral).balanceOf(address(this));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     IERC20(toCollateral).approve(address(a.core()), depositAmount);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     a.core().depositAndBorrow(toCollateral, depositAmount, parAmount);                                                                                                                                          │
│     a.core().repay(vaultId, parAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     a.core().withdraw(vaultId, flashloanRepayAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     require(fromCollateral.balanceOf(address(this)) >= flashloanRepayAmount, "SV101");                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function executeOperation(                                                                                                                                                                                    │
│     address[] calldata assets,                                                                                                                                                                                  │
│     uint256[] calldata amounts,                                                                                                                                                                                 │
│     uint256[] calldata premiums,                                                                                                                                                                                │
│     address,                                                                                                                                                                                                    │
│     bytes calldata params                                                                                                                                                                                       │
│   ) external returns (bool) {                                                                                                                                                                                   │
│     require(msg.sender == address(lendingPool), "SV002");                                                                                                                                                       │
│     (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));                                                                                                               │
│     IERC20 asset = IERC20(assets[0]);                                                                                                                                                                           │
│     uint256 flashloanRepayAmount = amounts[0] + premiums[0];                                                                                                                                                    │
│     if (operation == Operation.LEVERAGE) {                                                                                                                                                                      │
│       leverageOperation(asset, flashloanRepayAmount, operationParams);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     if (operation == Operation.REBALANCE) {                                                                                                                                                                     │
│       rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);                                                                                                                             │
│     }                                                                                                                                                                                                           │
│     if (operation == Operation.EMPTY) {                                                                                                                                                                         │
│       emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     asset.approve(address(lendingPool), flashloanRepayAmount);                                                                                                                                                  │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function rebalanceOperation(                                                                                                                                                                                  │
│     IERC20 fromCollateral,                                                                                                                                                                                      │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 flashloanRepayAmount,                                                                                                                                                                               │
│     bytes memory params                                                                                                                                                                                         │
│   ) internal {                                                                                                                                                                                                  │
│     (uint256 vaultId, address toCollateral, uint256 parAmount, bytes memory dexTxData, uint dexIndex) = abi                                                                                                     │
│       .decode(params, (uint256, address, uint256, bytes, uint ));                                                                                                                                               │
│     aggregatorSwap(dexIndex, fromCollateral, amount, dexTxData);                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 depositAmount = IERC20(toCollateral).balanceOf(address(this));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     IERC20(toCollateral).approve(address(a.core()), depositAmount);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     a.core().depositAndBorrow(toCollateral, depositAmount, parAmount);                                                                                                                                          │
│     a.core().repay(vaultId, parAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     a.core().withdraw(vaultId, flashloanRepayAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     require(fromCollateral.balanceOf(address(this)) >= flashloanRepayAmount, "SV101");                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function emptyVaultOperation(                                                                                                                                                                                 │
│     IERC20 vaultCollateral,                                                                                                                                                                                     │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 flashloanRepayAmount,                                                                                                                                                                               │
│     bytes memory params                                                                                                                                                                                         │
│   ) internal {                                                                                                                                                                                                  │
│     // Use par to repay debt                                                                                                                                                                                    │
│     (uint256 vaultId, bytes memory dexTxData, uint dexIndex) = abi.decode(params, (uint256, bytes, uint));                                                                                                      │
│                                                                                                                                                                                                                 │
│     aggregatorSwap(dexIndex, vaultCollateral, amount, dexTxData); // swap assets for par to repay back loan                                                                                                     │
│                                                                                                                                                                                                                 │
│     IERC20 par = IERC20(a.stablex());                                                                                                                                                                           │
│     par.approve(address(a.core()), par.balanceOf(address(this)));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Repay the par debt                                                                                                                                                                                       │
│     a.core().repayAll(vaultId);                                                                                                                                                                                 │
│     uint256 vaultBalance = a.vaultsData().vaultCollateralBalance(vaultId);                                                                                                                                      │
│     // Withdraw all collateral                                                                                                                                                                                  │
│     a.core().withdraw(vaultId, vaultBalance);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     require(vaultCollateral.balanceOf(address(this)) >= flashloanRepayAmount, "SV101");                                                                                                                         │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function executeOperation(                                                                                                                                                                                    │
│     address[] calldata assets,                                                                                                                                                                                  │
│     uint256[] calldata amounts,                                                                                                                                                                                 │
│     uint256[] calldata premiums,                                                                                                                                                                                │
│     address,                                                                                                                                                                                                    │
│     bytes calldata params                                                                                                                                                                                       │
│   ) external returns (bool) {                                                                                                                                                                                   │
│     require(msg.sender == address(lendingPool), "SV002");                                                                                                                                                       │
│     (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));                                                                                                               │
│     IERC20 asset = IERC20(assets[0]);                                                                                                                                                                           │
│     uint256 flashloanRepayAmount = amounts[0] + premiums[0];                                                                                                                                                    │
│     if (operation == Operation.LEVERAGE) {                                                                                                                                                                      │
│       leverageOperation(asset, flashloanRepayAmount, operationParams);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     if (operation == Operation.REBALANCE) {                                                                                                                                                                     │
│       rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);                                                                                                                             │
│     }                                                                                                                                                                                                           │
│     if (operation == Operation.EMPTY) {                                                                                                                                                                         │
│       emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);                                                                                                                            │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     asset.approve(address(lendingPool), flashloanRepayAmount);                                                                                                                                                  │
│     return true;                                                                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│   function emptyVaultOperation(                                                                                                                                                                                 │
│     IERC20 vaultCollateral,                                                                                                                                                                                     │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 flashloanRepayAmount,                                                                                                                                                                               │
│     bytes memory params                                                                                                                                                                                         │
│   ) internal {                                                                                                                                                                                                  │
│     // Use par to repay debt                                                                                                                                                                                    │
│     (uint256 vaultId, bytes memory dexTxData, uint dexIndex) = abi.decode(params, (uint256, bytes, uint));                                                                                                      │
│                                                                                                                                                                                                                 │
│     aggregatorSwap(dexIndex, vaultCollateral, amount, dexTxData); // swap assets for par to repay back loan                                                                                                     │
│                                                                                                                                                                                                                 │
│     IERC20 par = IERC20(a.stablex());                                                                                                                                                                           │
│     par.approve(address(a.core()), par.balanceOf(address(this)));                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Repay the par debt                                                                                                                                                                                       │
│     a.core().repayAll(vaultId);                                                                                                                                                                                 │
│     uint256 vaultBalance = a.vaultsData().vaultCollateralBalance(vaultId);                                                                                                                                      │
│     // Withdraw all collateral                                                                                                                                                                                  │
│     a.core().withdraw(vaultId, vaultBalance);                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     require(vaultCollateral.balanceOf(address(this)) >= flashloanRepayAmount, "SV101");                                                                                                                         │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function leverageSwap(bytes memory params, IERC20 token) internal {                                                                                                                                           │
│     (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(                                                                                                                                    │
│       params,                                                                                                                                                                                                   │
│       (uint256, bytes, uint )                                                                                                                                                                                   │
│     );                                                                                                                                                                                                          │
│     token.approve(address(a.core()), 2**256 - 1);                                                                                                                                                               │
│     a.core().depositAndBorrow(address(token), token.balanceOf(address(this)), parToSell);                                                                                                                       │
│     IERC20 par = IERC20(a.stablex());                                                                                                                                                                           │
│     aggregatorSwap(dexIndex, par, parToSell, dexTxData);                                                                                                                                                        │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function leverageOperation(                                                                                                                                                                                   │
│     IERC20 token,                                                                                                                                                                                               │
│     uint256 flashloanRepayAmount,                                                                                                                                                                               │
│     bytes memory params                                                                                                                                                                                         │
│   ) internal {                                                                                                                                                                                                  │
│     leverageSwap(params, token);                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     require(token.balanceOf(address(this)) >= flashloanRepayAmount, "SV101");                                                                                                                                   │
│     a.core().deposit(address(token), token.balanceOf(address(this)) - flashloanRepayAmount);                                                                                                                    │
│   }                                                                                                                                                                                                             │
│   function leverageSwap(bytes memory params, IERC20 token) internal {                                                                                                                                           │
│     (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(                                                                                                                                    │
│       params,                                                                                                                                                                                                   │
│       (uint256, bytes, uint )                                                                                                                                                                                   │
│     );                                                                                                                                                                                                          │
│     token.approve(address(a.core()), 2**256 - 1);                                                                                                                                                               │
│     a.core().depositAndBorrow(address(token), token.balanceOf(address(this)), parToSell);                                                                                                                       │
│     IERC20 par = IERC20(a.stablex());                                                                                                                                                                           │
│     aggregatorSwap(dexIndex, par, parToSell, dexTxData);                                                                                                                                                        │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function repay() public onlyManager {                                                                                                                                                                         │
│     IVaultsCore core = a.core();                                                                                                                                                                                │
│     IVaultsDataProvider vaultsData = a.vaultsData();                                                                                                                                                            │
│     uint256 vaultCount = a.vaultsData().vaultCount();                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     for (uint256 vaultId = 1; vaultId <= vaultCount; vaultId++) {                                                                                                                                               │
│       uint256 baseDebt = vaultsData.vaultBaseDebt(vaultId);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│       //if (vaultId==28 || vaultId==29 || vaultId==30 || vaultId==31 || vaultId==32 || vaultId==33 || vaultId==35){                                                                                             │
│       //  continue;                                                                                                                                                                                             │
│       //}                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       if (baseDebt == 0) {                                                                                                                                                                                      │
│         continue;                                                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│       core.repay(vaultId, REPAY_PER_VAULT);                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     IERC20 par = IERC20(a.stablex());                                                                                                                                                                           │
│     par.safeTransfer(msg.sender, par.balanceOf(address(this)));                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function rebalanceOperation(                                                                                                                                                                                  │
│     IERC20 fromCollateral,                                                                                                                                                                                      │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 flashloanRepayAmount,                                                                                                                                                                               │
│     bytes memory params                                                                                                                                                                                         │
│   ) internal {                                                                                                                                                                                                  │
│     (uint256 vaultId, address toCollateral, uint256 parAmount, bytes memory dexTxData, uint dexIndex) = abi                                                                                                     │
│       .decode(params, (uint256, address, uint256, bytes, uint ));                                                                                                                                               │
│     aggregatorSwap(dexIndex, fromCollateral, amount, dexTxData);                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256 depositAmount = IERC20(toCollateral).balanceOf(address(this));                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     IERC20(toCollateral).approve(address(a.core()), depositAmount);                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     a.core().depositAndBorrow(toCollateral, depositAmount, parAmount);                                                                                                                                          │
│     a.core().repay(vaultId, parAmount);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     a.core().withdraw(vaultId, flashloanRepayAmount);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     require(fromCollateral.balanceOf(address(this)) >= flashloanRepayAmount, "SV101");                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function repay() public onlyManager {                                                                                                                                                                         │
│     IVaultsCore core = a.core();                                                                                                                                                                                │
│     IVaultsDataProvider vaultsData = a.vaultsData();                                                                                                                                                            │
│     uint256 vaultCount = a.vaultsData().vaultCount();                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     for (uint256 vaultId = 1; vaultId <= vaultCount; vaultId++) {                                                                                                                                               │
│       uint256 baseDebt = vaultsData.vaultBaseDebt(vaultId);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│       //if (vaultId==28 || vaultId==29 || vaultId==30 || vaultId==31 || vaultId==32 || vaultId==33 || vaultId==35){                                                                                             │
│       //  continue;                                                                                                                                                                                             │
│       //}                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       if (baseDebt == 0) {                                                                                                                                                                                      │
│         continue;                                                                                                                                                                                               │
│       }                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│       core.repay(vaultId, REPAY_PER_VAULT);                                                                                                                                                                     │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     IERC20 par = IERC20(a.stablex());                                                                                                                                                                           │
│     par.safeTransfer(msg.sender, par.balanceOf(address(this)));                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function upgrade() public onlyManager {                                                                                                                                                                       │
│     IConfigProviderV1 oldConfig = IConfigProviderV1(address(a.config()));                                                                                                                                       │
│     IPriceFeed oldPriceFeed = IPriceFeed(address(a.priceFeed()));                                                                                                                                               │
│     IVaultsCoreV1 oldCore = IVaultsCoreV1(address(a.core()));                                                                                                                                                   │
│     IFeeDistributorV1 oldFeeDistributor = IFeeDistributorV1(address(a.feeDistributor()));                                                                                                                       │
│                                                                                                                                                                                                                 │
│     bytes32 MINTER_ROLE = a.controller().MINTER_ROLE();                                                                                                                                                         │
│     bytes32 MANAGER_ROLE = a.controller().MANAGER_ROLE();                                                                                                                                                       │
│     bytes32 DEFAULT_ADMIN_ROLE = 0x0000000000000000000000000000000000000000000000000000000000000000;                                                                                                            │
│     a.controller().grantRole(MANAGER_ROLE, address(this));                                                                                                                                                      │
│     a.controller().grantRole(MINTER_ROLE, address(core));                                                                                                                                                       │
│     a.controller().grantRole(MINTER_ROLE, address(feeDistributor));                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     oldCore.refresh();                                                                                                                                                                                          │
│     if (oldCore.availableIncome() > 0) {                                                                                                                                                                        │
│       oldFeeDistributor.release();                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     a.controller().revokeRole(MINTER_ROLE, address(a.core()));                                                                                                                                                  │
│     a.controller().revokeRole(MINTER_ROLE, address(a.feeDistributor()));                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     oldCore.upgrade(payable(address(core)));                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     a.setVaultsCore(core);                                                                                                                                                                                      │
│     a.setConfigProvider(config);                                                                                                                                                                                │
│     a.setLiquidationManager(liquidationManager);                                                                                                                                                                │
│     a.setFeeDistributor(feeDistributor);                                                                                                                                                                        │
│     a.setPriceFeed(priceFeed);                                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     priceFeed.setEurOracle(address(oldPriceFeed.eurOracle()));                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 numCollateralConfigs = oldConfig.numCollateralConfigs();                                                                                                                                            │
│     for (uint256 i = 1; i <= numCollateralConfigs; i++) {                                                                                                                                                       │
│       IConfigProviderV1.CollateralConfig memory collateralConfig = oldConfig.collateralConfigs(i);                                                                                                              │
│                                                                                                                                                                                                                 │
│       config.setCollateralConfig(                                                                                                                                                                               │
│         collateralConfig.collateralType,                                                                                                                                                                        │
│         collateralConfig.debtLimit,                                                                                                                                                                             │
│         collateralConfig.minCollateralRatio,                                                                                                                                                                    │
│         collateralConfig.minCollateralRatio,                                                                                                                                                                    │
│         collateralConfig.borrowRate,                                                                                                                                                                            │
│         collateralConfig.originationFee,                                                                                                                                                                        │
│         LIQUIDATION_BONUS,                                                                                                                                                                                      │
│         0                                                                                                                                                                                                       │
│       );                                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│       priceFeed.setAssetOracle(                                                                                                                                                                                 │
│         collateralConfig.collateralType,                                                                                                                                                                        │
│         address(oldPriceFeed.assetOracles(collateralConfig.collateralType))                                                                                                                                     │
│       );                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     coreState.syncStateFromV1(oldCore);                                                                                                                                                                         │
│     core.acceptUpgrade(payable(address(oldCore)));                                                                                                                                                              │
│     core.setDebtNotifier(debtNotifier);                                                                                                                                                                         │
│     debtNotifier.a().setDebtNotifier(debtNotifier);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     address[] memory payees = new address[](2);                                                                                                                                                                 │
│     payees[0] = bpool;                                                                                                                                                                                          │
│     payees[1] = address(core);                                                                                                                                                                                  │
│     uint256[] memory shares = new uint256[](2);                                                                                                                                                                 │
│     shares[0] = uint256(90);                                                                                                                                                                                    │
│     shares[1] = uint256(10);                                                                                                                                                                                    │
│     feeDistributor.changePayees(payees, shares);                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     a.controller().revokeRole(MANAGER_ROLE, address(this));                                                                                                                                                     │
│     a.controller().revokeRole(DEFAULT_ADMIN_ROLE, address(this));                                                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function initializeRates(address _collateralType) public override onlyConfig {                                                                                                                                │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     lastRefresh[_collateralType] = now;                                                                                                                                                                         │
│     cumulativeRates[_collateralType] = WadRayMath.ray();                                                                                                                                                        │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function refreshCollateral(address _collateralType) public override {                                                                                                                                         │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     require(a.config().collateralIds(_collateralType) != 0);                                                                                                                                                    │
│     uint256 timestamp = now;                                                                                                                                                                                    │
│     uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);                                                                                                                                          │
│     _refreshCumulativeRate(_collateralType, timeElapsed);                                                                                                                                                       │
│     lastRefresh[_collateralType] = timestamp;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function refreshCollateral(address _collateralType) public override {                                                                                                                                         │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     require(a.config().collateralIds(_collateralType) != 0);                                                                                                                                                    │
│     uint256 timestamp = now;                                                                                                                                                                                    │
│     uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);                                                                                                                                          │
│     _refreshCumulativeRate(_collateralType, timeElapsed);                                                                                                                                                       │
│     lastRefresh[_collateralType] = timestamp;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {                                                                                                                     │
│     uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);                                                                                                                                      │
│     uint256 oldCumulativeRate = cumulativeRates[_collateralType];                                                                                                                                               │
│     cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );                                                                                                                                                                                                          │
│     emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {                                                                                                                     │
│     uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);                                                                                                                                      │
│     uint256 oldCumulativeRate = cumulativeRates[_collateralType];                                                                                                                                               │
│     cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );                                                                                                                                                                                                          │
│     emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                              │
│     address collateralType = a.vaultsData().vaultCollateralType(_vaultId);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // Make sure current rate is up to date                                                                                                                                                                     │
│     refreshCollateral(collateralType);                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│     // Decrement vault borrow balance                                                                                                                                                                           │
│     if (_amount >= currentVaultDebt) {                                                                                                                                                                          │
│       //full repayment                                                                                                                                                                                          │
│       _amount = currentVaultDebt; //only pay back what's outstanding                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     _reduceVaultDebt(_vaultId, _amount);                                                                                                                                                                        │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     emit Repaid(_vaultId, _amount, msg.sender);                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                              │
│     address collateralType = a.vaultsData().vaultCollateralType(_vaultId);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // Make sure current rate is up to date                                                                                                                                                                     │
│     refreshCollateral(collateralType);                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│     // Decrement vault borrow balance                                                                                                                                                                           │
│     if (_amount >= currentVaultDebt) {                                                                                                                                                                          │
│       //full repayment                                                                                                                                                                                          │
│       _amount = currentVaultDebt; //only pay back what's outstanding                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     _reduceVaultDebt(_vaultId, _amount);                                                                                                                                                                        │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     emit Repaid(_vaultId, _amount, msg.sender);                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {                                                                                                                                       │
│     address collateralType = a.vaultsData().vaultCollateralType(_vaultId);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│     uint256 remainder = currentVaultDebt.sub(_amount);                                                                                                                                                          │
│     uint256 cumulativeRate = cumulativeRates;                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (remainder == 0) {                                                                                                                                                                                       │
│       a.vaultsData().setBaseDebt(_vaultId, 0);                                                                                                                                                                  │
│     } else {                                                                                                                                                                                                    │
│       uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);                                                                                                                      │
│       a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function liquidate(uint256 _vaultId) public override nonReentrant {                                                                                                                                           │
│     IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     refreshCollateral(v.collateralType);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     require(                                                                                                                                                                                                    │
│       !ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(                                                                                                                                        │
│         v.collateralType,                                                                                                                                                                                       │
│         collateralValue,                                                                                                                                                                                        │
│         currentVaultDebt                                                                                                                                                                                        │
│       )                                                                                                                                                                                                         │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 discountedValue = ILiquidationManagerV1(address(a.liquidationManager())).applyLiquidationDiscount(                                                                                                  │
│       collateralValue                                                                                                                                                                                           │
│     );                                                                                                                                                                                                          │
│     uint256 collateralToReceive;                                                                                                                                                                                │
│     uint256 stableXToPay = currentVaultDebt;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     if (discountedValue < currentVaultDebt) {                                                                                                                                                                   │
│       //Insurance Case                                                                                                                                                                                          │
│       uint256 insuranceAmount = currentVaultDebt.sub(discountedValue);                                                                                                                                          │
│       require(a.stablex().balanceOf(address(this)) >= insuranceAmount);                                                                                                                                         │
│       a.stablex().burn(address(this), insuranceAmount);                                                                                                                                                         │
│       emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);                                                                                                                                                │
│       collateralToReceive = v.collateralBalance;                                                                                                                                                                │
│       stableXToPay = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       collateralToReceive = a.priceFeed().convertTo(v.collateralType, currentVaultDebt);                                                                                                                        │
│       collateralToReceive = collateralToReceive.add(                                                                                                                                                            │
│         ILiquidationManagerV1(address(a.liquidationManager())).liquidationBonus(collateralToReceive)                                                                                                            │
│       );                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     // reduce the vault debt to 0                                                                                                                                                                               │
│     _reduceVaultDebt(_vaultId, currentVaultDebt);                                                                                                                                                               │
│     a.stablex().burn(msg.sender, stableXToPay);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     // send the collateral to the liquidator                                                                                                                                                                    │
│     a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                                │
│     IERC20 asset = IERC20(v.collateralType);                                                                                                                                                                    │
│     asset.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     emit Liquidated(_vaultId, stableXToPay, collateralToReceive, v.owner, msg.sender);                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function liquidate(uint256 _vaultId) public override nonReentrant {                                                                                                                                           │
│     IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     refreshCollateral(v.collateralType);                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     require(                                                                                                                                                                                                    │
│       !ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(                                                                                                                                        │
│         v.collateralType,                                                                                                                                                                                       │
│         collateralValue,                                                                                                                                                                                        │
│         currentVaultDebt                                                                                                                                                                                        │
│       )                                                                                                                                                                                                         │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 discountedValue = ILiquidationManagerV1(address(a.liquidationManager())).applyLiquidationDiscount(                                                                                                  │
│       collateralValue                                                                                                                                                                                           │
│     );                                                                                                                                                                                                          │
│     uint256 collateralToReceive;                                                                                                                                                                                │
│     uint256 stableXToPay = currentVaultDebt;                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     if (discountedValue < currentVaultDebt) {                                                                                                                                                                   │
│       //Insurance Case                                                                                                                                                                                          │
│       uint256 insuranceAmount = currentVaultDebt.sub(discountedValue);                                                                                                                                          │
│       require(a.stablex().balanceOf(address(this)) >= insuranceAmount);                                                                                                                                         │
│       a.stablex().burn(address(this), insuranceAmount);                                                                                                                                                         │
│       emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);                                                                                                                                                │
│       collateralToReceive = v.collateralBalance;                                                                                                                                                                │
│       stableXToPay = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                     │
│     } else {                                                                                                                                                                                                    │
│       collateralToReceive = a.priceFeed().convertTo(v.collateralType, currentVaultDebt);                                                                                                                        │
│       collateralToReceive = collateralToReceive.add(                                                                                                                                                            │
│         ILiquidationManagerV1(address(a.liquidationManager())).liquidationBonus(collateralToReceive)                                                                                                            │
│       );                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│     // reduce the vault debt to 0                                                                                                                                                                               │
│     _reduceVaultDebt(_vaultId, currentVaultDebt);                                                                                                                                                               │
│     a.stablex().burn(msg.sender, stableXToPay);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     // send the collateral to the liquidator                                                                                                                                                                    │
│     a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                                │
│     IERC20 asset = IERC20(v.collateralType);                                                                                                                                                                    │
│     asset.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     emit Liquidated(_vaultId, stableXToPay, collateralToReceive, v.owner, msg.sender);                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralConfig(                                                                                                                                                                                 │
│     address _collateralType,                                                                                                                                                                                    │
│     uint256 _debtLimit,                                                                                                                                                                                         │
│     uint256 _minCollateralRatio,                                                                                                                                                                                │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _originationFee                                                                                                                                                                                     │
│   ) public override onlyManager {                                                                                                                                                                               │
│     require(address(_collateralType) != address(0));                                                                                                                                                            │
│     if (collateralIds[_collateralType] == 0) {                                                                                                                                                                  │
│       //new collateral                                                                                                                                                                                          │
│       IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);                                                                                                                                        │
│       CollateralConfig memory config = CollateralConfig({                                                                                                                                                       │
│         collateralType: _collateralType,                                                                                                                                                                        │
│         debtLimit: _debtLimit,                                                                                                                                                                                  │
│         minCollateralRatio: _minCollateralRatio,                                                                                                                                                                │
│         borrowRate: _borrowRate,                                                                                                                                                                                │
│         originationFee: _originationFee                                                                                                                                                                         │
│       });                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       numCollateralConfigs++;                                                                                                                                                                                   │
│       _collateralConfigs = config;                                                                                                                                                                              │
│       collateralIds[_collateralType] = numCollateralConfigs;                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       // Update collateral config                                                                                                                                                                               │
│       IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);                                                                                                                                      │
│       uint256 id = collateralIds[_collateralType];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       _collateralConfigs.collateralType = _collateralType;                                                                                                                                                      │
│       _collateralConfigs.debtLimit = _debtLimit;                                                                                                                                                                │
│       _collateralConfigs.minCollateralRatio = _minCollateralRatio;                                                                                                                                              │
│       _collateralConfigs.borrowRate = _borrowRate;                                                                                                                                                              │
│       _collateralConfigs.originationFee = _originationFee;                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralConfig(                                                                                                                                                                                 │
│     address _collateralType,                                                                                                                                                                                    │
│     uint256 _debtLimit,                                                                                                                                                                                         │
│     uint256 _minCollateralRatio,                                                                                                                                                                                │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _originationFee                                                                                                                                                                                     │
│   ) public override onlyManager {                                                                                                                                                                               │
│     require(address(_collateralType) != address(0));                                                                                                                                                            │
│     if (collateralIds[_collateralType] == 0) {                                                                                                                                                                  │
│       //new collateral                                                                                                                                                                                          │
│       IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);                                                                                                                                        │
│       CollateralConfig memory config = CollateralConfig({                                                                                                                                                       │
│         collateralType: _collateralType,                                                                                                                                                                        │
│         debtLimit: _debtLimit,                                                                                                                                                                                  │
│         minCollateralRatio: _minCollateralRatio,                                                                                                                                                                │
│         borrowRate: _borrowRate,                                                                                                                                                                                │
│         originationFee: _originationFee                                                                                                                                                                         │
│       });                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       numCollateralConfigs++;                                                                                                                                                                                   │
│       _collateralConfigs = config;                                                                                                                                                                              │
│       collateralIds[_collateralType] = numCollateralConfigs;                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       // Update collateral config                                                                                                                                                                               │
│       IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);                                                                                                                                      │
│       uint256 id = collateralIds[_collateralType];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       _collateralConfigs.collateralType = _collateralType;                                                                                                                                                      │
│       _collateralConfigs.debtLimit = _debtLimit;                                                                                                                                                                │
│       _collateralConfigs.minCollateralRatio = _minCollateralRatio;                                                                                                                                              │
│       _collateralConfigs.borrowRate = _borrowRate;                                                                                                                                                              │
│       _collateralConfigs.originationFee = _originationFee;                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {                                                                                                  │
│     IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);                                                                                                                                        │
│     _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;                                                                                                                                │
│     _emitUpdateEvent(_collateralType);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {                                                                                                  │
│     IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);                                                                                                                                        │
│     _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;                                                                                                                                │
│     _emitUpdateEvent(_collateralType);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function latestRoundData()                                                                                                                                                                                    │
│     public                                                                                                                                                                                                      │
│     view                                                                                                                                                                                                        │
│     override                                                                                                                                                                                                    │
│     returns (                                                                                                                                                                                                   │
│       uint80 roundId,                                                                                                                                                                                           │
│       int256 answer,                                                                                                                                                                                            │
│       uint256 startedAt,                                                                                                                                                                                        │
│       uint256 updatedAt,                                                                                                                                                                                        │
│       uint80 answeredInRound                                                                                                                                                                                    │
│     )                                                                                                                                                                                                           │
│   {                                                                                                                                                                                                             │
│     (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();                                                                                                                                │
│     (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();                                                                                                                                │
│     uint256 priceA = uint256(answerA);                                                                                                                                                                          │
│     uint256 priceB = uint256(answerB);                                                                                                                                                                          │
│     uint160 sqrtPriceX96 = uint160(                                                                                                                                                                             │
│       MathPow.sqrt((priceA.mul(_tokenDecimalsUnitB).mul(1 << 96)) / (priceB.mul(_tokenDecimalsUnitA))) << 48                                                                                                    │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     (uint256 rA, uint256 rB) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);                                                                                                                                 │
│     require(rA > 0 || rB > 0, "C100");                                                                                                                                                                          │
│     uint256 totalSupply = pool.totalSupply();                                                                                                                                                                   │
│     require(totalSupply >= 1e9, "C101");                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     answer = int256(                                                                                                                                                                                            │
│       priceA.mul(rA.mul(_tokenDecimalsOffsetA)).add(priceB.mul(rB.mul(_tokenDecimalsOffsetB))).div(totalSupply)                                                                                                 │
│     );                                                                                                                                                                                                          │
│     updatedAt = assetUpdatedAtA;                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     // use ealier time for updateAt                                                                                                                                                                             │
│     if (assetUpdatedAtA > assetUpdatedAtB) {                                                                                                                                                                    │
│       updatedAt = assetUpdatedAtB;                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function latestRoundData()                                                                                                                                                                                    │
│     public                                                                                                                                                                                                      │
│     view                                                                                                                                                                                                        │
│     override                                                                                                                                                                                                    │
│     returns (                                                                                                                                                                                                   │
│       uint80 roundId,                                                                                                                                                                                           │
│       int256 answer,                                                                                                                                                                                            │
│       uint256 startedAt,                                                                                                                                                                                        │
│       uint256 updatedAt,                                                                                                                                                                                        │
│       uint80 answeredInRound                                                                                                                                                                                    │
│     )                                                                                                                                                                                                           │
│   {                                                                                                                                                                                                             │
│     (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();                                                                                                                                │
│     (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();                                                                                                                                │
│     uint256 priceA = uint256(answerA);                                                                                                                                                                          │
│     uint256 priceB = uint256(answerB);                                                                                                                                                                          │
│     uint160 sqrtPriceX96 = uint160(                                                                                                                                                                             │
│       MathPow.sqrt((priceA.mul(_tokenDecimalsUnitB).mul(1 << 96)) / (priceB.mul(_tokenDecimalsUnitA))) << 48                                                                                                    │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     (uint256 rA, uint256 rB) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);                                                                                                                                 │
│     require(rA > 0 || rB > 0, "C100");                                                                                                                                                                          │
│     uint256 totalSupply = pool.totalSupply();                                                                                                                                                                   │
│     require(totalSupply >= 1e9, "C101");                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     answer = int256(                                                                                                                                                                                            │
│       priceA.mul(rA.mul(_tokenDecimalsOffsetA)).add(priceB.mul(rB.mul(_tokenDecimalsOffsetB))).div(totalSupply)                                                                                                 │
│     );                                                                                                                                                                                                          │
│     updatedAt = assetUpdatedAtA;                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     // use ealier time for updateAt                                                                                                                                                                             │
│     if (assetUpdatedAtA > assetUpdatedAtB) {                                                                                                                                                                    │
│       updatedAt = assetUpdatedAtB;                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes.                                                                                                                                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function getAssetPrice(address _asset) public view override returns (uint256 price) {                                                                                                                         │
│     (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = eurOracle.latestRoundData();                                                                                                                               │
│     require(eurAnswer > 0, "EUR price data not valid");                                                                                                                                                         │
│     require(block.timestamp - eurUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, "EUR price data is stale");                                                                                                          │
│                                                                                                                                                                                                                 │
│     (, int256 answer, , uint256 assetUpdatedAt, ) = assetOracles[_asset].latestRoundData();                                                                                                                     │
│     require(answer > 0, "Price data not valid");                                                                                                                                                                │
│     require(block.timestamp - assetUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, "Price data is stale");                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint8 eurDecimals = eurOracle.decimals();                                                                                                                                                                   │
│     uint256 eurAccuracy = MathPow.pow(10, eurDecimals);                                                                                                                                                         │
│     return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function latestRoundData()                                                                                                                                                                                    │
│     public                                                                                                                                                                                                      │
│     view                                                                                                                                                                                                        │
│     override                                                                                                                                                                                                    │
│     returns (                                                                                                                                                                                                   │
│       uint80 roundId,                                                                                                                                                                                           │
│       int256 answer,                                                                                                                                                                                            │
│       uint256 startedAt,                                                                                                                                                                                        │
│       uint256 updatedAt,                                                                                                                                                                                        │
│       uint80 answeredInRound                                                                                                                                                                                    │
│     )                                                                                                                                                                                                           │
│   {                                                                                                                                                                                                             │
│     (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();                                                                                                                                │
│     (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();                                                                                                                                │
│     uint256 priceA = uint256(answerA);                                                                                                                                                                          │
│     uint256 priceB = uint256(answerB);                                                                                                                                                                          │
│     uint160 sqrtPriceX96 = uint160(                                                                                                                                                                             │
│       MathPow.sqrt((priceA.mul(_tokenDecimalsUnitB).mul(1 << 96)) / (priceB.mul(_tokenDecimalsUnitA))) << 48                                                                                                    │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     (uint256 rA, uint256 rB) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);                                                                                                                                 │
│     require(rA > 0 || rB > 0, "C100");                                                                                                                                                                          │
│     uint256 totalSupply = pool.totalSupply();                                                                                                                                                                   │
│     require(totalSupply >= 1e9, "C101");                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     answer = int256(                                                                                                                                                                                            │
│       priceA.mul(rA.mul(_tokenDecimalsOffsetA)).add(priceB.mul(rB.mul(_tokenDecimalsOffsetB))).div(totalSupply)                                                                                                 │
│     );                                                                                                                                                                                                          │
│     updatedAt = assetUpdatedAtA;                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     // use ealier time for updateAt                                                                                                                                                                             │
│     if (assetUpdatedAtA > assetUpdatedAtB) {                                                                                                                                                                    │
│       updatedAt = assetUpdatedAtB;                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function getAssetPrice(address _asset) public view override returns (uint256 price) {                                                                                                                         │
│     (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = eurOracle.latestRoundData();                                                                                                                               │
│     require(eurAnswer > 0, "EUR price data not valid");                                                                                                                                                         │
│     require(block.timestamp - eurUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, "EUR price data is stale");                                                                                                          │
│                                                                                                                                                                                                                 │
│     (, int256 answer, , uint256 assetUpdatedAt, ) = assetOracles[_asset].latestRoundData();                                                                                                                     │
│     require(answer > 0, "Price data not valid");                                                                                                                                                                │
│     require(block.timestamp - assetUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, "Price data is stale");                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint8 eurDecimals = eurOracle.decimals();                                                                                                                                                                   │
│     uint256 eurAccuracy = MathPow.pow(10, eurDecimals);                                                                                                                                                         │
│     return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function latestRoundData()                                                                                                                                                                                    │
│     public                                                                                                                                                                                                      │
│     view                                                                                                                                                                                                        │
│     override                                                                                                                                                                                                    │
│     returns (                                                                                                                                                                                                   │
│       uint80 roundId,                                                                                                                                                                                           │
│       int256 answer,                                                                                                                                                                                            │
│       uint256 startedAt,                                                                                                                                                                                        │
│       uint256 updatedAt,                                                                                                                                                                                        │
│       uint80 answeredInRound                                                                                                                                                                                    │
│     )                                                                                                                                                                                                           │
│   {                                                                                                                                                                                                             │
│     (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();                                                                                                                                │
│     (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();                                                                                                                                │
│     uint256 priceA = uint256(answerA);                                                                                                                                                                          │
│     uint256 priceB = uint256(answerB);                                                                                                                                                                          │
│     uint160 sqrtPriceX96 = uint160(                                                                                                                                                                             │
│       MathPow.sqrt((priceA.mul(_tokenDecimalsUnitB).mul(1 << 96)) / (priceB.mul(_tokenDecimalsUnitA))) << 48                                                                                                    │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     (uint256 rA, uint256 rB) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);                                                                                                                                 │
│     require(rA > 0 || rB > 0, "C100");                                                                                                                                                                          │
│     uint256 totalSupply = pool.totalSupply();                                                                                                                                                                   │
│     require(totalSupply >= 1e9, "C101");                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     answer = int256(                                                                                                                                                                                            │
│       priceA.mul(rA.mul(_tokenDecimalsOffsetA)).add(priceB.mul(rB.mul(_tokenDecimalsOffsetB))).div(totalSupply)                                                                                                 │
│     );                                                                                                                                                                                                          │
│     updatedAt = assetUpdatedAtA;                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     // use ealier time for updateAt                                                                                                                                                                             │
│     if (assetUpdatedAtA > assetUpdatedAtB) {                                                                                                                                                                    │
│       updatedAt = assetUpdatedAtB;                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function latestRoundData()                                                                                                                                                                                    │
│     public                                                                                                                                                                                                      │
│     view                                                                                                                                                                                                        │
│     override                                                                                                                                                                                                    │
│     returns (                                                                                                                                                                                                   │
│       uint80 roundId,                                                                                                                                                                                           │
│       int256 answer,                                                                                                                                                                                            │
│       uint256 startedAt,                                                                                                                                                                                        │
│       uint256 updatedAt,                                                                                                                                                                                        │
│       uint80 answeredInRound                                                                                                                                                                                    │
│     )                                                                                                                                                                                                           │
│   {                                                                                                                                                                                                             │
│     (address[] memory tokens, uint256[] memory balances, ) = vault.getPoolTokens(poolId);                                                                                                                       │
│     (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();                                                                                                                                │
│     (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256[] memory normalizedWeights = pool.getNormalizedWeights();                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     uint256 pxA = uint256(answerA);                                                                                                                                                                             │
│     uint256 pxB = uint256(answerB);                                                                                                                                                                             │
│     (uint256 fairResA, uint256 fairResB) = _computeFairReserves(                                                                                                                                                │
│       _getNormalizedBalance(tokens[0], balances[0]),                                                                                                                                                            │
│       _getNormalizedBalance(tokens[1], balances[1]),                                                                                                                                                            │
│       normalizedWeights[0],                                                                                                                                                                                     │
│       normalizedWeights[1],                                                                                                                                                                                     │
│       pxA,                                                                                                                                                                                                      │
│       pxB                                                                                                                                                                                                       │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     answer = int256(fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply()));                                                                                                                          │
│     updatedAt = assetUpdatedAtA;                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     // use oldest timestamp for updatedAt                                                                                                                                                                       │
│     if (assetUpdatedAtA > assetUpdatedAtB) {                                                                                                                                                                    │
│       updatedAt = assetUpdatedAtB;                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ deposit/mint/add the liquidity pool/amount/share                                                                                                                                                                │
│ Code:                                                                                                                                                                                                           │
│   function getAssetPrice(address _asset) public view override returns (uint256 price) {                                                                                                                         │
│     (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = eurOracle.latestRoundData();                                                                                                                               │
│     require(eurAnswer > 0, "EUR price data not valid");                                                                                                                                                         │
│     require(block.timestamp - eurUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, "EUR price data is stale");                                                                                                          │
│                                                                                                                                                                                                                 │
│     (, int256 answer, , uint256 assetUpdatedAt, ) = assetOracles[_asset].latestRoundData();                                                                                                                     │
│     require(answer > 0, "Price data not valid");                                                                                                                                                                │
│     require(block.timestamp - assetUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, "Price data is stale");                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint8 eurDecimals = eurOracle.decimals();                                                                                                                                                                   │
│     uint256 eurAccuracy = MathPow.pow(10, eurDecimals);                                                                                                                                                         │
│     return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function latestRoundData()                                                                                                                                                                                    │
│     public                                                                                                                                                                                                      │
│     view                                                                                                                                                                                                        │
│     override                                                                                                                                                                                                    │
│     returns (                                                                                                                                                                                                   │
│       uint80 roundId,                                                                                                                                                                                           │
│       int256 answer,                                                                                                                                                                                            │
│       uint256 startedAt,                                                                                                                                                                                        │
│       uint256 updatedAt,                                                                                                                                                                                        │
│       uint80 answeredInRound                                                                                                                                                                                    │
│     )                                                                                                                                                                                                           │
│   {                                                                                                                                                                                                             │
│     (address[] memory tokens, uint256[] memory balances, ) = vault.getPoolTokens(poolId);                                                                                                                       │
│     (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();                                                                                                                                │
│     (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256[] memory normalizedWeights = pool.getNormalizedWeights();                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     uint256 pxA = uint256(answerA);                                                                                                                                                                             │
│     uint256 pxB = uint256(answerB);                                                                                                                                                                             │
│     (uint256 fairResA, uint256 fairResB) = _computeFairReserves(                                                                                                                                                │
│       _getNormalizedBalance(tokens[0], balances[0]),                                                                                                                                                            │
│       _getNormalizedBalance(tokens[1], balances[1]),                                                                                                                                                            │
│       normalizedWeights[0],                                                                                                                                                                                     │
│       normalizedWeights[1],                                                                                                                                                                                     │
│       pxA,                                                                                                                                                                                                      │
│       pxB                                                                                                                                                                                                       │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     answer = int256(fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply()));                                                                                                                          │
│     updatedAt = assetUpdatedAtA;                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     // use oldest timestamp for updatedAt                                                                                                                                                                       │
│     if (assetUpdatedAtA > assetUpdatedAtB) {                                                                                                                                                                    │
│       updatedAt = assetUpdatedAtB;                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes",                                                                                                                                                                                                   │
│   "2": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function getAssetPrice(address _asset) public view override returns (uint256 price) {                                                                                                                         │
│     (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = eurOracle.latestRoundData();                                                                                                                               │
│     require(eurAnswer > 0, "EUR price data not valid");                                                                                                                                                         │
│     require(block.timestamp - eurUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, "EUR price data is stale");                                                                                                          │
│                                                                                                                                                                                                                 │
│     (, int256 answer, , uint256 assetUpdatedAt, ) = assetOracles[_asset].latestRoundData();                                                                                                                     │
│     require(answer > 0, "Price data not valid");                                                                                                                                                                │
│     require(block.timestamp - assetUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, "Price data is stale");                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint8 eurDecimals = eurOracle.decimals();                                                                                                                                                                   │
│     uint256 eurAccuracy = MathPow.pow(10, eurDecimals);                                                                                                                                                         │
│     return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));                                                                                                                                            │
│   }                                                                                                                                                                                                             │
│   function latestRoundData()                                                                                                                                                                                    │
│     public                                                                                                                                                                                                      │
│     view                                                                                                                                                                                                        │
│     override                                                                                                                                                                                                    │
│     returns (                                                                                                                                                                                                   │
│       uint80 roundId,                                                                                                                                                                                           │
│       int256 answer,                                                                                                                                                                                            │
│       uint256 startedAt,                                                                                                                                                                                        │
│       uint256 updatedAt,                                                                                                                                                                                        │
│       uint80 answeredInRound                                                                                                                                                                                    │
│     )                                                                                                                                                                                                           │
│   {                                                                                                                                                                                                             │
│     (address[] memory tokens, uint256[] memory balances, ) = vault.getPoolTokens(poolId);                                                                                                                       │
│     (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();                                                                                                                                │
│     (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();                                                                                                                                │
│                                                                                                                                                                                                                 │
│     uint256[] memory normalizedWeights = pool.getNormalizedWeights();                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     uint256 pxA = uint256(answerA);                                                                                                                                                                             │
│     uint256 pxB = uint256(answerB);                                                                                                                                                                             │
│     (uint256 fairResA, uint256 fairResB) = _computeFairReserves(                                                                                                                                                │
│       _getNormalizedBalance(tokens[0], balances[0]),                                                                                                                                                            │
│       _getNormalizedBalance(tokens[1], balances[1]),                                                                                                                                                            │
│       normalizedWeights[0],                                                                                                                                                                                     │
│       normalizedWeights[1],                                                                                                                                                                                     │
│       pxA,                                                                                                                                                                                                      │
│       pxB                                                                                                                                                                                                       │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     answer = int256(fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply()));                                                                                                                          │
│     updatedAt = assetUpdatedAtA;                                                                                                                                                                                │
│                                                                                                                                                                                                                 │
│     // use oldest timestamp for updatedAt                                                                                                                                                                       │
│     if (assetUpdatedAtA > assetUpdatedAtB) {                                                                                                                                                                    │
│       updatedAt = assetUpdatedAtB;                                                                                                                                                                              │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes.                                                                                                                                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function propose(                                                                                                                                                                                             │
│     address[] memory targets,                                                                                                                                                                                   │
│     uint256[] memory values,                                                                                                                                                                                    │
│     string[] memory signatures,                                                                                                                                                                                 │
│     bytes[] memory calldatas,                                                                                                                                                                                   │
│     string memory description,                                                                                                                                                                                  │
│     uint256 endTime                                                                                                                                                                                             │
│   ) public override returns (uint256) {                                                                                                                                                                         │
│     uint256 votingDuration = endTime.sub(block.timestamp);                                                                                                                                                      │
│     require(votingDuration >= a.parallel().config().minVotingPeriod(), "Proposal end-time too early");                                                                                                          │
│     require(votingDuration <= a.parallel().config().maxVotingPeriod(), "Proposal end-time too late");                                                                                                           │
│                                                                                                                                                                                                                 │
│     require(                                                                                                                                                                                                    │
│       a.votingEscrow().balanceOfAt(msg.sender, endTime) > proposalThreshold(),                                                                                                                                  │
│       "GovernorAlpha::propose: proposer votes below proposal threshold"                                                                                                                                         │
│     );                                                                                                                                                                                                          │
│     require(                                                                                                                                                                                                    │
│       targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,                                                                                             │
│       "GovernorAlpha::propose: proposal function information arity mismatch"                                                                                                                                    │
│     );                                                                                                                                                                                                          │
│     require(targets.length != 0, "GovernorAlpha::propose: must provide actions");                                                                                                                               │
│     require(targets.length <= proposalMaxOperations(), "GovernorAlpha::propose: too many actions");                                                                                                             │
│                                                                                                                                                                                                                 │
│     uint256 latestProposalId = latestProposalIds;                                                                                                                                                               │
│     if (latestProposalId != 0) {                                                                                                                                                                                │
│       ProposalState proposersLatestProposalState = state(latestProposalId);                                                                                                                                     │
│       require(                                                                                                                                                                                                  │
│         proposersLatestProposalState != ProposalState.Active,                                                                                                                                                   │
│         "GovernorAlpha::propose: one live proposal per proposer, found an already active proposal"                                                                                                              │
│       );                                                                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     proposalCount++;                                                                                                                                                                                            │
│     Proposal memory newProposal = Proposal({                                                                                                                                                                    │
│       id: proposalCount,                                                                                                                                                                                        │
│       proposer: msg.sender,                                                                                                                                                                                     │
│       eta: 0,                                                                                                                                                                                                   │
│       targets: targets,                                                                                                                                                                                         │
│       values: values,                                                                                                                                                                                           │
│       signatures: signatures,                                                                                                                                                                                   │
│       calldatas: calldatas,                                                                                                                                                                                     │
│       startTime: block.timestamp,                                                                                                                                                                               │
│       endTime: endTime,                                                                                                                                                                                         │
│       forVotes: 0,                                                                                                                                                                                              │
│       againstVotes: 0,                                                                                                                                                                                          │
│       canceled: false,                                                                                                                                                                                          │
│       executed: false                                                                                                                                                                                           │
│     });                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     proposals = newProposal;                                                                                                                                                                                    │
│     latestProposalIds = newProposal.id;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     emit ProposalCreated(                                                                                                                                                                                       │
│       newProposal.id,                                                                                                                                                                                           │
│       msg.sender,                                                                                                                                                                                               │
│       targets,                                                                                                                                                                                                  │
│       values,                                                                                                                                                                                                   │
│       signatures,                                                                                                                                                                                               │
│       calldatas,                                                                                                                                                                                                │
│       block.timestamp,                                                                                                                                                                                          │
│       endTime,                                                                                                                                                                                                  │
│       description                                                                                                                                                                                               │
│     );                                                                                                                                                                                                          │
│     return newProposal.id;                                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function castVote(uint256 proposalId, bool support) public override {                                                                                                                                         │
│     require(state(proposalId) == ProposalState.Active, "GovernorAlpha::_castVote: voting is closed");                                                                                                           │
│     Proposal storage proposal = proposals;                                                                                                                                                                      │
│     Receipt storage receipt = proposal.receipts;                                                                                                                                                                │
│     require(receipt.hasVoted == false, "GovernorAlpha::_castVote: voter already voted");                                                                                                                        │
│     uint256 votes = a.votingEscrow().balanceOfAt(msg.sender, proposal.endTime);                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (support) {                                                                                                                                                                                              │
│       proposal.forVotes = proposal.forVotes.add(votes);                                                                                                                                                         │
│     } else {                                                                                                                                                                                                    │
│       proposal.againstVotes = proposal.againstVotes.add(votes);                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     receipt.hasVoted = true;                                                                                                                                                                                    │
│     receipt.support = support;                                                                                                                                                                                  │
│     receipt.votes = votes;                                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     emit VoteCast(msg.sender, proposalId, support, votes);                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function pendingMIMO(address _user) public view returns (uint256) {                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function pendingPAR(address _user) public view returns (uint256) {                                                                                                                                            │
│     uint256 currentBalance = par.balanceOf(address(this)).sub(totalStake);                                                                                                                                      │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                        │
│                                                                                                                                                                                                                 │
│     return _users[_user].stake.rayMul(accParAmountPerShare.sub(_users[_user].accParAmountPerShare));                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     totalStake = totalStake.sub(value);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     require(a.mimo().transfer(user, pending));                                                                                                                                                                  │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public {                                                                                                                                                                   │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│     uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                              │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pendingPAR);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releasePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│     require(par.transfer(_user, pending));                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public override {                                                                                                                                                         │
│     IVotingEscrow votingEscrow = a.votingEscrow();                                                                                                                                                              │
│     require((msg.sender == _user) || (msg.sender == address(votingEscrow)));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 votingPower = votingEscrow.balanceOf(_user);                                                                                                                                                        │
│     totalStake = totalStake.add(votingPower).sub(userInfo.stake);                                                                                                                                               │
│     userInfo.stake = votingPower;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(_user, pending));                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual override {                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual override {                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.sub(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                       │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(par.transfer(user, pendingPAR));                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = totalStake.add(value);                                                                                                                                                                         │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = totalStake.add(value);                                                                                                                                                                         │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function liquidate(                                                                                                                                                                                           │
│     uint256 vaultId,                                                                                                                                                                                            │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 dexIndex,                                                                                                                                                                                           │
│     bytes calldata dexTxData                                                                                                                                                                                    │
│   ) public {                                                                                                                                                                                                    │
│     uint256 parBalanceBefore = _par.balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);                                                                                                                        │
│     IERC20 collateralToken = IERC20(vault.collateralType);                                                                                                                                                      │
│     _a.parallel().core().liquidatePartial(vaultId, amount);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     (address proxy, address router) = _dexAP.dexMapping(dexIndex);                                                                                                                                              │
│     collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));                                                                                                                                   │
│     router.call(dexTxData);                                                                                                                                                                                     │
│     _par.safeTransfer(msg.sender, _liquidateCallerReward);                                                                                                                                                      │
│     require(_par.balanceOf(address(this)) > parBalanceBefore, "LM104");                                                                                                                                         │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public {                                                                                                                                                                   │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│     uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                              │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pendingPAR);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public {                                                                                                                                                                   │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│     uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                              │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pendingPAR);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releasePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│     require(par.transfer(_user, pending));                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releasePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│     require(par.transfer(_user, pending));                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.sub(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                       │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(par.transfer(user, pendingPAR));                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                                │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));                                                                                                                            │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public override {                                                                                                                                                         │
│     IVotingEscrow votingEscrow = a.votingEscrow();                                                                                                                                                              │
│     require((msg.sender == _user) || (msg.sender == address(votingEscrow)));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 votingPower = votingEscrow.balanceOf(_user);                                                                                                                                                        │
│     totalStake = totalStake.add(votingPower).sub(userInfo.stake);                                                                                                                                               │
│     userInfo.stake = votingPower;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(_user, pending));                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function pendingMIMO(address _user) public view override returns (uint256) {                                                                                                                                  │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     totalStake = totalStake.sub(value);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     require(a.mimo().transfer(user, pending));                                                                                                                                                                  │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public {                                                                                                                                                                   │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│     uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                              │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pendingPAR);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releasePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│     require(par.transfer(_user, pending));                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public override {                                                                                                                                                         │
│     IVotingEscrow votingEscrow = a.votingEscrow();                                                                                                                                                              │
│     require((msg.sender == _user) || (msg.sender == address(votingEscrow)));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 votingPower = votingEscrow.balanceOf(_user);                                                                                                                                                        │
│     totalStake = totalStake.add(votingPower).sub(userInfo.stake);                                                                                                                                               │
│     userInfo.stake = votingPower;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(_user, pending));                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual override {                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.sub(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                       │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(par.transfer(user, pendingPAR));                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = totalStake.add(value);                                                                                                                                                                         │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (totalStake == 0) {                                                                                                                                                                                      │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = a.mimo().balanceOf(address(this));                                                                                                                                                 │
│     uint256 reward = currentBalance.sub(_balanceTracker);                                                                                                                                                       │
│     _balanceTracker = currentBalance;                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));                                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function liquidate(                                                                                                                                                                                           │
│     uint256 vaultId,                                                                                                                                                                                            │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 dexIndex,                                                                                                                                                                                           │
│     bytes calldata dexTxData                                                                                                                                                                                    │
│   ) public {                                                                                                                                                                                                    │
│     uint256 parBalanceBefore = _par.balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);                                                                                                                        │
│     IERC20 collateralToken = IERC20(vault.collateralType);                                                                                                                                                      │
│     _a.parallel().core().liquidatePartial(vaultId, amount);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     (address proxy, address router) = _dexAP.dexMapping(dexIndex);                                                                                                                                              │
│     collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));                                                                                                                                   │
│     router.call(dexTxData);                                                                                                                                                                                     │
│     _par.safeTransfer(msg.sender, _liquidateCallerReward);                                                                                                                                                      │
│     require(_par.balanceOf(address(this)) > parBalanceBefore, "LM104");                                                                                                                                         │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function pendingPAR(address _user) public view override returns (uint256) {                                                                                                                                   │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);                                                                                                                                    │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                         │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function pendingPAR(address _user) public view override returns (uint256) {                                                                                                                                   │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);                                                                                                                                    │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                         │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No.                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     totalStake = totalStake.sub(value);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     require(a.mimo().transfer(user, pending));                                                                                                                                                                  │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public {                                                                                                                                                                   │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│     uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                              │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pendingPAR);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releasePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│     require(par.transfer(_user, pending));                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public override {                                                                                                                                                         │
│     IVotingEscrow votingEscrow = a.votingEscrow();                                                                                                                                                              │
│     require((msg.sender == _user) || (msg.sender == address(votingEscrow)));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 votingPower = votingEscrow.balanceOf(_user);                                                                                                                                                        │
│     totalStake = totalStake.add(votingPower).sub(userInfo.stake);                                                                                                                                               │
│     userInfo.stake = votingPower;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(_user, pending));                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual override {                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.sub(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                       │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(par.transfer(user, pendingPAR));                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = totalStake.add(value);                                                                                                                                                                         │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function liquidate(                                                                                                                                                                                           │
│     uint256 vaultId,                                                                                                                                                                                            │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 dexIndex,                                                                                                                                                                                           │
│     bytes calldata dexTxData                                                                                                                                                                                    │
│   ) public {                                                                                                                                                                                                    │
│     uint256 parBalanceBefore = _par.balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);                                                                                                                        │
│     IERC20 collateralToken = IERC20(vault.collateralType);                                                                                                                                                      │
│     _a.parallel().core().liquidatePartial(vaultId, amount);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     (address proxy, address router) = _dexAP.dexMapping(dexIndex);                                                                                                                                              │
│     collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));                                                                                                                                   │
│     router.call(dexTxData);                                                                                                                                                                                     │
│     _par.safeTransfer(msg.sender, _liquidateCallerReward);                                                                                                                                                      │
│     require(_par.balanceOf(address(this)) > parBalanceBefore, "LM104");                                                                                                                                         │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public {                                                                                                                                                                   │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│     uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                              │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pendingPAR);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public {                                                                                                                                                                   │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│     uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                              │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pendingPAR);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releasePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│     require(par.transfer(_user, pending));                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releasePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│     require(par.transfer(_user, pending));                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.sub(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                       │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(par.transfer(user, pendingPAR));                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refreshPAR(uint256 newTotalStake) internal {                                                                                                                                                        │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);                                                                                                                               │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _updateBoost(address _user, UserInfo memory _userInfo) internal {                                                                                                                                    │
│     // if user had a boost already, first remove it from the totalStakeWithBoost                                                                                                                                │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     uint256 multiplier = _getBoostMultiplier(_user);                                                                                                                                                            │
│     _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);                                                                                                                                              │
│     _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);                                                                                                                                  │
│     _users[_user] = _userInfo;                                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _updateBoost(address _user, UserInfo memory _userInfo) internal {                                                                                                                                    │
│     // if user had a boost already, first remove it from the totalStakeWithBoost                                                                                                                                │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     uint256 multiplier = _getBoostMultiplier(_user);                                                                                                                                                            │
│     _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);                                                                                                                                              │
│     _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);                                                                                                                                  │
│     _users[_user] = _userInfo;                                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _updateBoost(address _user, UserInfo memory _userInfo) internal {                                                                                                                                    │
│     // if user had a boost already, first remove it from the totalStakeWithBoost                                                                                                                                │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     uint256 multiplier = _getBoostMultiplier(_user);                                                                                                                                                            │
│     _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);                                                                                                                                              │
│     _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);                                                                                                                                  │
│     _users[_user] = _userInfo;                                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _updateBoost(address _user, UserInfo memory _userInfo) internal {                                                                                                                                    │
│     // if user had a boost already, first remove it from the totalStakeWithBoost                                                                                                                                │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     uint256 multiplier = _getBoostMultiplier(_user);                                                                                                                                                            │
│     _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);                                                                                                                                              │
│     _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);                                                                                                                                  │
│     _users[_user] = _userInfo;                                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     totalStake = totalStake.sub(value);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     require(a.mimo().transfer(user, pending));                                                                                                                                                                  │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pending);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function restakePAR(address _user) public {                                                                                                                                                                   │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│     uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                              │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     _increaseStake(_user, pendingPAR);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual {                                                                                                                                                          │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releasePAR(address _user) public virtual {                                                                                                                                                           │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(totalStake);                                                                                                                                                                                    │
│     uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                          │
│     _parBalanceTracker = _parBalanceTracker.sub(pending);                                                                                                                                                       │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│     require(par.transfer(_user, pending));                                                                                                                                                                      │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public override {                                                                                                                                                         │
│     IVotingEscrow votingEscrow = a.votingEscrow();                                                                                                                                                              │
│     require((msg.sender == _user) || (msg.sender == address(votingEscrow)));                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 votingPower = votingEscrow.balanceOf(_user);                                                                                                                                                        │
│     totalStake = totalStake.add(votingPower).sub(userInfo.stake);                                                                                                                                               │
│     userInfo.stake = votingPower;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(_user, pending));                                                                                                                                                               │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) public virtual override {                                                                                                                                                 │
│     UserInfo storage userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     require(a.mimo().transfer(_user, pending));                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.add(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     uint256 pendingPAR;                                                                                                                                                                                         │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│       // maybe we should add the accumulated PAR to the stake of the user instead?                                                                                                                              │
│       pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                             │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       // add pendingPAR balance to stake and totalStake instead of sending it back                                                                                                                              │
│       userInfo.stake = userInfo.stake.add(pendingPAR);                                                                                                                                                          │
│       totalStake = totalStake.add(pendingPAR);                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value.add(pendingPAR));                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ No                                                                                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _decreaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     require(userInfo.stake >= value, "INSUFFICIENT_STAKE_FOR_USER"); //TODO cleanup error message                                                                                                               │
│     _refresh();                                                                                                                                                                                                 │
│     uint256 newTotalStake = totalStake.sub(value);                                                                                                                                                              │
│     _refreshPAR(newTotalStake);                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                │
│     _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                             │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));                                                                                                       │
│                                                                                                                                                                                                                 │
│     _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                    │
│     userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     userInfo.stake = userInfo.stake.sub(value);                                                                                                                                                                 │
│     totalStake = newTotalStake;                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(par.transfer(user, pendingPAR));                                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeDecreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address user, uint256 value) internal {                                                                                                                                               │
│     require(value > 0, "STAKE_MUST_BE_GREATER_THAN_ZERO"); //TODO cleanup error message                                                                                                                         │
│                                                                                                                                                                                                                 │
│     UserInfo storage userInfo = _users;                                                                                                                                                                         │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pending;                                                                                                                                                                                            │
│     if (userInfo.stake > 0) {                                                                                                                                                                                   │
│       pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));                                                                                                                      │
│       _balanceTracker = _balanceTracker.sub(pending);                                                                                                                                                           │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     totalStake = totalStake.add(value);                                                                                                                                                                         │
│     userInfo.stake = userInfo.stake.add(value);                                                                                                                                                                 │
│     userInfo.accAmountPerShare = _accAmountPerShare;                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     if (pending > 0) {                                                                                                                                                                                          │
│       require(a.mimo().transfer(user, pending));                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(user, value);                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _refresh() internal {                                                                                                                                                                                │
│     if (_totalStake == 0) {                                                                                                                                                                                     │
│       return;                                                                                                                                                                                                   │
│     }                                                                                                                                                                                                           │
│     uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));                                                                                                                                            │
│     uint256 currentParBalance = _par.balanceOf(address(this));                                                                                                                                                  │
│     uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);                                                                                                                                           │
│     uint256 parReward = currentParBalance.sub(_parBalanceTracker);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     _mimoBalanceTracker = currentMimoBalance;                                                                                                                                                                   │
│     _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));                                                                                                               │
│     _parBalanceTracker = currentParBalance;                                                                                                                                                                     │
│     _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {                                                                                          │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _a.mimo().balanceOf(address(this));                                                                                                                                                │
│     uint256 reward = currentBalance.sub(_mimoBalanceTracker);                                                                                                                                                   │
│     uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                            │
│     return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));                                                                                                                       │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(                                                                                                                                                                                     │
│     address _user,                                                                                                                                                                                              │
│     UserInfo memory _userInfo,                                                                                                                                                                                  │
│     uint256 _newTotalStake,                                                                                                                                                                                     │
│     bool _restakePAR                                                                                                                                                                                            │
│   ) internal {                                                                                                                                                                                                  │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│     _refreshPAR(_newTotalStake);                                                                                                                                                                                │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0 && !_restakePAR) {                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _releaseRewards(address _user, UserInfo memory _userInfo) internal {                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function pendingPAR(address _user) public view override returns (uint256) {                                                                                                                                   │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);                                                                                                                                    │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                         │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function pendingPAR(address _user) public view override returns (uint256) {                                                                                                                                   │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);                                                                                                                                    │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                         │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address _user, uint256 _value) internal {                                                                                                                                             │
│     require(_value > 0, "LM101");                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = _totalStake.add(_value);                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     _releaseRewards(_user, _userInfo, newTotalStake, true);                                                                                                                                                     │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     _totalStake = newTotalStake;                                                                                                                                                                                │
│     _userInfo.stake = _userInfo.stake.add(_value);                                                                                                                                                              │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       _userInfo.stake = _userInfo.stake.add(pendingPAR);                                                                                                                                                        │
│       _totalStake = _totalStake.add(pendingPAR);                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(_user, _value.add(pendingPAR));                                                                                                                                                         │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _increaseStake(address _user, uint256 _value) internal {                                                                                                                                             │
│     require(_value > 0, "LM101");                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 newTotalStake = _totalStake.add(_value);                                                                                                                                                            │
│                                                                                                                                                                                                                 │
│     _releaseRewards(_user, _userInfo, newTotalStake, true);                                                                                                                                                     │
│     uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                          │
│     _totalStake = newTotalStake;                                                                                                                                                                                │
│     _userInfo.stake = _userInfo.stake.add(_value);                                                                                                                                                              │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       _userInfo.stake = _userInfo.stake.add(pendingPAR);                                                                                                                                                        │
│       _totalStake = _totalStake.add(pendingPAR);                                                                                                                                                                │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     emit StakeIncreased(_user, _value.add(pendingPAR));                                                                                                                                                         │
│   }                                                                                                                                                                                                             │
│   function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {                                                                                        │
│     if (_totalStakeWithBoost == 0) {                                                                                                                                                                            │
│       return 0;                                                                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     uint256 currentBalance = _par.balanceOf(address(this));                                                                                                                                                     │
│     uint256 reward = currentBalance.sub(_parBalanceTracker);                                                                                                                                                    │
│     uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));                                                                                                              │
│                                                                                                                                                                                                                 │
│     return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));                                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _updateBoost(address _user, UserInfo memory _userInfo) internal {                                                                                                                                    │
│     // if user had a boost already, first remove it from the totalStakeWithBoost                                                                                                                                │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     uint256 multiplier = _getBoostMultiplier(_user);                                                                                                                                                            │
│     _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);                                                                                                                                              │
│     _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);                                                                                                                                  │
│     _users[_user] = _userInfo;                                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _updateBoost(address _user, UserInfo memory _userInfo) internal {                                                                                                                                    │
│     // if user had a boost already, first remove it from the totalStakeWithBoost                                                                                                                                │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     uint256 multiplier = _getBoostMultiplier(_user);                                                                                                                                                            │
│     _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);                                                                                                                                              │
│     _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);                                                                                                                                  │
│     _users[_user] = _userInfo;                                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _updateBoost(address _user, UserInfo memory _userInfo) internal {                                                                                                                                    │
│     // if user had a boost already, first remove it from the totalStakeWithBoost                                                                                                                                │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     uint256 multiplier = _getBoostMultiplier(_user);                                                                                                                                                            │
│     _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);                                                                                                                                              │
│     _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);                                                                                                                                  │
│     _users[_user] = _userInfo;                                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function _updateBoost(address _user, UserInfo memory _userInfo) internal {                                                                                                                                    │
│     // if user had a boost already, first remove it from the totalStakeWithBoost                                                                                                                                │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);                                                                                                                                │
│     }                                                                                                                                                                                                           │
│     uint256 multiplier = _getBoostMultiplier(_user);                                                                                                                                                            │
│     _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);                                                                                                                                              │
│     _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);                                                                                                                                  │
│     _users[_user] = _userInfo;                                                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│   function _getBoostMultiplier(address _user) internal view returns (uint256) {                                                                                                                                 │
│     uint256 veMIMO = _a.votingEscrow().balanceOf(_user);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (veMIMO == 0) return 1e18;                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     // Convert boostConfig variables to signed 64.64-bit fixed point numbers                                                                                                                                    │
│     int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);                                                                                                                                                          │
│     int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);                                                                                                                                                          │
│     int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);                                                                                                                                                          │
│     int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);                                                                                                                                                          │
│     int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000                                                                                                                                                         │
│     int128 e2 = e1.sub(e); // x/25000 - 6                                                                                                                                                                       │
│     int128 e3 = e2.neg(); // -(x/25000 - 6)                                                                                                                                                                     │
│     int128 e4 = e3.exp(); // e^-(x/25000 - 6)                                                                                                                                                                   │
│     int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)                                                                                                                                                              │
│     int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))                                                                                                                                               │
│     uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64                                                                                                                                            │
│     uint256 multiplier = uint256(e7); // convert to uint256                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, "LM103");                                                                                                                                │
│                                                                                                                                                                                                                 │
│     return multiplier;                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function _syncStake(address _user, UserInfo memory _userInfo) internal {                                                                                                                                      │
│     uint256 votingPower = _a.votingEscrow().balanceOf(_user);                                                                                                                                                   │
│     _totalStake = _totalStake.add(votingPower).sub(_userInfo.stake);                                                                                                                                            │
│     _userInfo.stake = votingPower;                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function releaseMIMO(address _user) external {                                                                                                                                                                │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _refresh();                                                                                                                                                                                                 │
│                                                                                                                                                                                                                 │
│     uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);                                                                                                                  │
│     uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);                                                                                                                 │
│                                                                                                                                                                                                                 │
│     if (_userInfo.stakeWithBoost > 0) {                                                                                                                                                                         │
│       _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);                                                                                                                                               │
│       _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│                                                                                                                                                                                                                 │
│     _userInfo.accAmountPerShare = _accMimoAmountPerShare;                                                                                                                                                       │
│     _userInfo.accParAmountPerShare = _accParAmountPerShare;                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│                                                                                                                                                                                                                 │
│     if (pendingMIMO > 0) {                                                                                                                                                                                      │
│       require(_a.mimo().transfer(_user, pendingMIMO), "LM100");                                                                                                                                                 │
│     }                                                                                                                                                                                                           │
│     if (pendingPAR > 0) {                                                                                                                                                                                       │
│       require(_par.transfer(_user, pendingPAR), "LM100");                                                                                                                                                       │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
│   function _syncStake(address _user, UserInfo memory _userInfo) internal {                                                                                                                                      │
│     uint256 votingPower = _a.votingEscrow().balanceOf(_user);                                                                                                                                                   │
│     _totalStake = _totalStake.add(votingPower).sub(_userInfo.stake);                                                                                                                                            │
│     _userInfo.stake = votingPower;                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function syncStake(address _user) public override {                                                                                                                                                           │
│     UserInfo memory _userInfo = _users[_user];                                                                                                                                                                  │
│     _syncStake(_user, _userInfo);                                                                                                                                                                               │
│     _updateBoost(_user, _userInfo);                                                                                                                                                                             │
│   }                                                                                                                                                                                                             │
│   function _syncStake(address _user, UserInfo memory _userInfo) internal {                                                                                                                                      │
│     uint256 votingPower = _a.votingEscrow().balanceOf(_user);                                                                                                                                                   │
│     _totalStake = _totalStake.add(votingPower).sub(_userInfo.stake);                                                                                                                                            │
│     _userInfo.stake = votingPower;                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralConfig(                                                                                                                                                                                 │
│     address _collateralType,                                                                                                                                                                                    │
│     uint256 _debtLimit,                                                                                                                                                                                         │
│     uint256 _liquidationRatio,                                                                                                                                                                                  │
│     uint256 _minCollateralRatio,                                                                                                                                                                                │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _originationFee,                                                                                                                                                                                    │
│     uint256 _liquidationBonus,                                                                                                                                                                                  │
│     uint256 _liquidationFee                                                                                                                                                                                     │
│   ) public override onlyManager {                                                                                                                                                                               │
│     require(address(_collateralType) != address(0));                                                                                                                                                            │
│     require(_minCollateralRatio >= _liquidationRatio);                                                                                                                                                          │
│     if (collateralIds[_collateralType] == 0) {                                                                                                                                                                  │
│       // Initialize new collateral                                                                                                                                                                              │
│       a.core().state().initializeRates(_collateralType);                                                                                                                                                        │
│       CollateralConfig memory config = CollateralConfig({                                                                                                                                                       │
│         collateralType: _collateralType,                                                                                                                                                                        │
│         debtLimit: _debtLimit,                                                                                                                                                                                  │
│         liquidationRatio: _liquidationRatio,                                                                                                                                                                    │
│         minCollateralRatio: _minCollateralRatio,                                                                                                                                                                │
│         borrowRate: _borrowRate,                                                                                                                                                                                │
│         originationFee: _originationFee,                                                                                                                                                                        │
│         liquidationBonus: _liquidationBonus,                                                                                                                                                                    │
│         liquidationFee: _liquidationFee                                                                                                                                                                         │
│       });                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       numCollateralConfigs++;                                                                                                                                                                                   │
│       _collateralConfigs = config;                                                                                                                                                                              │
│       collateralIds[_collateralType] = numCollateralConfigs;                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       // Update collateral config                                                                                                                                                                               │
│       a.core().state().refreshCollateral(_collateralType);                                                                                                                                                      │
│       uint256 id = collateralIds[_collateralType];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       _collateralConfigs.collateralType = _collateralType;                                                                                                                                                      │
│       _collateralConfigs.debtLimit = _debtLimit;                                                                                                                                                                │
│       _collateralConfigs.liquidationRatio = _liquidationRatio;                                                                                                                                                  │
│       _collateralConfigs.minCollateralRatio = _minCollateralRatio;                                                                                                                                              │
│       _collateralConfigs.borrowRate = _borrowRate;                                                                                                                                                              │
│       _collateralConfigs.originationFee = _originationFee;                                                                                                                                                      │
│       _collateralConfigs.liquidationBonus = _liquidationBonus;                                                                                                                                                  │
│       _collateralConfigs.liquidationFee = _liquidationFee;                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     emit CollateralUpdated(                                                                                                                                                                                     │
│       _collateralType,                                                                                                                                                                                          │
│       _debtLimit,                                                                                                                                                                                               │
│       _liquidationRatio,                                                                                                                                                                                        │
│       _minCollateralRatio,                                                                                                                                                                                      │
│       _borrowRate,                                                                                                                                                                                              │
│       _originationFee,                                                                                                                                                                                          │
│       _liquidationBonus,                                                                                                                                                                                        │
│       _liquidationFee                                                                                                                                                                                           │
│     );                                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralConfig(                                                                                                                                                                                 │
│     address _collateralType,                                                                                                                                                                                    │
│     uint256 _debtLimit,                                                                                                                                                                                         │
│     uint256 _liquidationRatio,                                                                                                                                                                                  │
│     uint256 _minCollateralRatio,                                                                                                                                                                                │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _originationFee,                                                                                                                                                                                    │
│     uint256 _liquidationBonus,                                                                                                                                                                                  │
│     uint256 _liquidationFee                                                                                                                                                                                     │
│   ) public override onlyManager {                                                                                                                                                                               │
│     require(address(_collateralType) != address(0));                                                                                                                                                            │
│     require(_minCollateralRatio >= _liquidationRatio);                                                                                                                                                          │
│     if (collateralIds[_collateralType] == 0) {                                                                                                                                                                  │
│       // Initialize new collateral                                                                                                                                                                              │
│       a.core().state().initializeRates(_collateralType);                                                                                                                                                        │
│       CollateralConfig memory config = CollateralConfig({                                                                                                                                                       │
│         collateralType: _collateralType,                                                                                                                                                                        │
│         debtLimit: _debtLimit,                                                                                                                                                                                  │
│         liquidationRatio: _liquidationRatio,                                                                                                                                                                    │
│         minCollateralRatio: _minCollateralRatio,                                                                                                                                                                │
│         borrowRate: _borrowRate,                                                                                                                                                                                │
│         originationFee: _originationFee,                                                                                                                                                                        │
│         liquidationBonus: _liquidationBonus,                                                                                                                                                                    │
│         liquidationFee: _liquidationFee                                                                                                                                                                         │
│       });                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       numCollateralConfigs++;                                                                                                                                                                                   │
│       _collateralConfigs = config;                                                                                                                                                                              │
│       collateralIds[_collateralType] = numCollateralConfigs;                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       // Update collateral config                                                                                                                                                                               │
│       a.core().state().refreshCollateral(_collateralType);                                                                                                                                                      │
│       uint256 id = collateralIds[_collateralType];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       _collateralConfigs.collateralType = _collateralType;                                                                                                                                                      │
│       _collateralConfigs.debtLimit = _debtLimit;                                                                                                                                                                │
│       _collateralConfigs.liquidationRatio = _liquidationRatio;                                                                                                                                                  │
│       _collateralConfigs.minCollateralRatio = _minCollateralRatio;                                                                                                                                              │
│       _collateralConfigs.borrowRate = _borrowRate;                                                                                                                                                              │
│       _collateralConfigs.originationFee = _originationFee;                                                                                                                                                      │
│       _collateralConfigs.liquidationBonus = _liquidationBonus;                                                                                                                                                  │
│       _collateralConfigs.liquidationFee = _liquidationFee;                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     emit CollateralUpdated(                                                                                                                                                                                     │
│       _collateralType,                                                                                                                                                                                          │
│       _debtLimit,                                                                                                                                                                                               │
│       _liquidationRatio,                                                                                                                                                                                        │
│       _minCollateralRatio,                                                                                                                                                                                      │
│       _borrowRate,                                                                                                                                                                                              │
│       _originationFee,                                                                                                                                                                                          │
│       _liquidationBonus,                                                                                                                                                                                        │
│       _liquidationFee                                                                                                                                                                                           │
│     );                                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {                                                                                                  │
│     a.core().state().refreshCollateral(_collateralType);                                                                                                                                                        │
│     _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;                                                                                                                                │
│     _emitUpdateEvent(_collateralType);                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function calculateCumulativeRate(                                                                                                                                                                             │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _cumulativeRate,                                                                                                                                                                                    │
│     uint256 _timeElapsed                                                                                                                                                                                        │
│   ) public view override returns (uint256) {                                                                                                                                                                    │
│     if (_timeElapsed == 0) return _cumulativeRate;                                                                                                                                                              │
│     uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);                                                                                                                                               │
│     return _cumulativeRate.rayMul(cumulativeElapsed);                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function calculateCumulativeRate(                                                                                                                                                                             │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _cumulativeRate,                                                                                                                                                                                    │
│     uint256 _timeElapsed                                                                                                                                                                                        │
│   ) public view override returns (uint256) {                                                                                                                                                                    │
│     if (_timeElapsed == 0) return _cumulativeRate;                                                                                                                                                              │
│     uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);                                                                                                                                               │
│     return _cumulativeRate.rayMul(cumulativeElapsed);                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function syncState(IVaultsCoreState _stateAddress) public override onlyManager notSynced {                                                                                                                    │
│     for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {                                                                                                                                          │
│       address collateralType = a.config().collateralConfigs(i).collateralType;                                                                                                                                  │
│       cumulativeRates = _stateAddress.cumulativeRates(collateralType);                                                                                                                                          │
│       lastRefresh = _stateAddress.lastRefresh(collateralType);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     synced = true;                                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function syncState(IVaultsCoreState _stateAddress) public override onlyManager notSynced {                                                                                                                    │
│     for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {                                                                                                                                          │
│       address collateralType = a.config().collateralConfigs(i).collateralType;                                                                                                                                  │
│       cumulativeRates = _stateAddress.cumulativeRates(collateralType);                                                                                                                                          │
│       lastRefresh = _stateAddress.lastRefresh(collateralType);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     synced = true;                                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function syncStateFromV1(IVaultsCoreV1 _core) public override onlyManager notSynced {                                                                                                                         │
│     for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {                                                                                                                                          │
│       address collateralType = a.config().collateralConfigs(i).collateralType;                                                                                                                                  │
│       cumulativeRates = _core.cumulativeRates(collateralType);                                                                                                                                                  │
│       lastRefresh = _core.lastRefresh(collateralType);                                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     synced = true;                                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function initializeRates(address _collateralType) public override onlyConfig {                                                                                                                                │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     lastRefresh[_collateralType] = block.timestamp;                                                                                                                                                             │
│     cumulativeRates[_collateralType] = WadRayMath.ray();                                                                                                                                                        │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│     "1": "No"                                                                                                                                                                                                   │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function refreshCollateral(address _collateralType) public override {                                                                                                                                         │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     require(a.config().collateralIds(_collateralType) != 0);                                                                                                                                                    │
│     uint256 timestamp = block.timestamp;                                                                                                                                                                        │
│     uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);                                                                                                                                          │
│     _refreshCumulativeRate(_collateralType, timeElapsed);                                                                                                                                                       │
│     lastRefresh[_collateralType] = timestamp;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function refreshCollateral(address _collateralType) public override {                                                                                                                                         │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     require(a.config().collateralIds(_collateralType) != 0);                                                                                                                                                    │
│     uint256 timestamp = block.timestamp;                                                                                                                                                                        │
│     uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);                                                                                                                                          │
│     _refreshCumulativeRate(_collateralType, timeElapsed);                                                                                                                                                       │
│     lastRefresh[_collateralType] = timestamp;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {                                                                                                                     │
│     uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);                                                                                                                                      │
│     uint256 oldCumulativeRate = cumulativeRates[_collateralType];                                                                                                                                               │
│     cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );                                                                                                                                                                                                          │
│     emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {                                                                                                                     │
│     uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);                                                                                                                                      │
│     uint256 oldCumulativeRate = cumulativeRates[_collateralType];                                                                                                                                               │
│     cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );                                                                                                                                                                                                          │
│     emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function acceptUpgrade(address payable _oldVaultsCore) public override onlyManager {                                                                                                                          │
│     IERC20 stableX = IERC20(a.stablex());                                                                                                                                                                       │
│     stableX.safeTransferFrom(_oldVaultsCore, address(this), stableX.balanceOf(_oldVaultsCore));                                                                                                                 │
│                                                                                                                                                                                                                 │
│     for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {                                                                                                                                          │
│       address collateralType = a.config().collateralConfigs(i).collateralType;                                                                                                                                  │
│       IERC20 asset = IERC20(collateralType);                                                                                                                                                                    │
│       asset.safeTransferFrom(_oldVaultsCore, address(this), asset.balanceOf(_oldVaultsCore));                                                                                                                   │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                              │
│     address collateralType = a.vaultsData().vaultCollateralType(_vaultId);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // Make sure current rate is up to date                                                                                                                                                                     │
│     state.refreshCollateral(collateralType);                                                                                                                                                                    │
│                                                                                                                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│     // Decrement vault borrow balance                                                                                                                                                                           │
│     if (_amount >= currentVaultDebt) {                                                                                                                                                                          │
│       //full repayment                                                                                                                                                                                          │
│       _amount = currentVaultDebt; //only pay back what's outstanding                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     _reduceVaultDebt(_vaultId, _amount);                                                                                                                                                                        │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│     debtNotifier.debtChanged(_vaultId);                                                                                                                                                                         │
│     emit Repaid(_vaultId, _amount, msg.sender);                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {                                                                                                                                       │
│     address collateralType = a.vaultsData().vaultCollateralType(_vaultId);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│     uint256 remainder = currentVaultDebt.sub(_amount);                                                                                                                                                          │
│     uint256 cumulativeRate = cumulativeRates(collateralType);                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     if (remainder == 0) {                                                                                                                                                                                       │
│       a.vaultsData().setBaseDebt(_vaultId, 0);                                                                                                                                                                  │
│     } else {                                                                                                                                                                                                    │
│       uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);                                                                                                                      │
│       a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);                                                                                                                                                        │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     state.refreshCollateral(v.collateralType);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     require(                                                                                                                                                                                                    │
│       !a.liquidationManager().isHealthy(                                                                                                                                                                        │
│         collateralValue,                                                                                                                                                                                        │
│         currentVaultDebt,                                                                                                                                                                                       │
│         a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).liquidationRatio                                                                                                               │
│       )                                                                                                                                                                                                         │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(                                                                                                                                           │
│       a.config().collateralLiquidationFee(v.collateralType)                                                                                                                                                     │
│     );                                                                                                                                                                                                          │
│     uint256 maxLiquiditionCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     uint256 repayAmount;                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (_amount > maxLiquiditionCost) {                                                                                                                                                                         │
│       _amount = maxLiquiditionCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // collateral value to be received by the liquidator is based on the total amount repaid (including the liquidationFee).                                                                                    │
│     uint256 collateralValueToReceive = _amount.add(a.liquidationManager().liquidationBonus(v.collateralType, _amount));                                                                                         │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation fee                                                                                                                                                       │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = a.liquidationManager().applyLiquidationDiscount(                                                                                                                      │
│         v.collateralType,                                                                                                                                                                                       │
│         collateralValue                                                                                                                                                                                         │
│       );                                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(a.stablex().balanceOf(address(this)) >= insuranceAmount);                                                                                                                                       │
│         a.stablex().burn(address(this), insuranceAmount); // Insurance uses local reserves to pay down debt                                                                                                     │
│         emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);                                                                                                                                              │
│       }                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = a.priceFeed().convertTo(v.collateralType, collateralValueToReceive);                                                                                                          │
│     a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                                │
│     IERC20 asset = IERC20(v.collateralType);                                                                                                                                                                    │
│     asset.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     debtNotifier.debtChanged(_vaultId);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     state.refreshCollateral(v.collateralType);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     require(                                                                                                                                                                                                    │
│       !a.liquidationManager().isHealthy(                                                                                                                                                                        │
│         collateralValue,                                                                                                                                                                                        │
│         currentVaultDebt,                                                                                                                                                                                       │
│         a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).liquidationRatio                                                                                                               │
│       )                                                                                                                                                                                                         │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(                                                                                                                                           │
│       a.config().collateralLiquidationFee(v.collateralType)                                                                                                                                                     │
│     );                                                                                                                                                                                                          │
│     uint256 maxLiquiditionCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     uint256 repayAmount;                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (_amount > maxLiquiditionCost) {                                                                                                                                                                         │
│       _amount = maxLiquiditionCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // collateral value to be received by the liquidator is based on the total amount repaid (including the liquidationFee).                                                                                    │
│     uint256 collateralValueToReceive = _amount.add(a.liquidationManager().liquidationBonus(v.collateralType, _amount));                                                                                         │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation fee                                                                                                                                                       │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = a.liquidationManager().applyLiquidationDiscount(                                                                                                                      │
│         v.collateralType,                                                                                                                                                                                       │
│         collateralValue                                                                                                                                                                                         │
│       );                                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(a.stablex().balanceOf(address(this)) >= insuranceAmount);                                                                                                                                       │
│         a.stablex().burn(address(this), insuranceAmount); // Insurance uses local reserves to pay down debt                                                                                                     │
│         emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);                                                                                                                                              │
│       }                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = a.priceFeed().convertTo(v.collateralType, collateralValueToReceive);                                                                                                          │
│     a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                                │
│     IERC20 asset = IERC20(v.collateralType);                                                                                                                                                                    │
│     asset.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     debtNotifier.debtChanged(_vaultId);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function liquidate(                                                                                                                                                                                           │
│     uint256 vaultId,                                                                                                                                                                                            │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 dexIndex,                                                                                                                                                                                           │
│     bytes calldata dexTxData                                                                                                                                                                                    │
│   ) public {                                                                                                                                                                                                    │
│     uint256 parBalanceBefore = _par.balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);                                                                                                                        │
│     IERC20 collateralToken = IERC20(vault.collateralType);                                                                                                                                                      │
│     _a.parallel().core().liquidatePartial(vaultId, amount);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     (address proxy, address router) = _dexAP.dexMapping(dexIndex);                                                                                                                                              │
│     collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));                                                                                                                                   │
│     router.call(dexTxData);                                                                                                                                                                                     │
│     _par.safeTransfer(msg.sender, _liquidateCallerReward);                                                                                                                                                      │
│     require(_par.balanceOf(address(this)) > parBalanceBefore, "LM104");                                                                                                                                         │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     state.refreshCollateral(v.collateralType);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     require(                                                                                                                                                                                                    │
│       !a.liquidationManager().isHealthy(                                                                                                                                                                        │
│         collateralValue,                                                                                                                                                                                        │
│         currentVaultDebt,                                                                                                                                                                                       │
│         a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).liquidationRatio                                                                                                               │
│       )                                                                                                                                                                                                         │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(                                                                                                                                           │
│       a.config().collateralLiquidationFee(v.collateralType)                                                                                                                                                     │
│     );                                                                                                                                                                                                          │
│     uint256 maxLiquiditionCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     uint256 repayAmount;                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (_amount > maxLiquiditionCost) {                                                                                                                                                                         │
│       _amount = maxLiquiditionCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // collateral value to be received by the liquidator is based on the total amount repaid (including the liquidationFee).                                                                                    │
│     uint256 collateralValueToReceive = _amount.add(a.liquidationManager().liquidationBonus(v.collateralType, _amount));                                                                                         │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation fee                                                                                                                                                       │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = a.liquidationManager().applyLiquidationDiscount(                                                                                                                      │
│         v.collateralType,                                                                                                                                                                                       │
│         collateralValue                                                                                                                                                                                         │
│       );                                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(a.stablex().balanceOf(address(this)) >= insuranceAmount);                                                                                                                                       │
│         a.stablex().burn(address(this), insuranceAmount); // Insurance uses local reserves to pay down debt                                                                                                     │
│         emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);                                                                                                                                              │
│       }                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = a.priceFeed().convertTo(v.collateralType, collateralValueToReceive);                                                                                                          │
│     a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                                │
│     IERC20 asset = IERC20(v.collateralType);                                                                                                                                                                    │
│     asset.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     debtNotifier.debtChanged(_vaultId);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price based on the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation          │
│ Code:                                                                                                                                                                                                           │
│   function liquidate(                                                                                                                                                                                           │
│     uint256 vaultId,                                                                                                                                                                                            │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 dexIndex,                                                                                                                                                                                           │
│     bytes calldata dexTxData                                                                                                                                                                                    │
│   ) public {                                                                                                                                                                                                    │
│     uint256 parBalanceBefore = _par.balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);                                                                                                                        │
│     IERC20 collateralToken = IERC20(vault.collateralType);                                                                                                                                                      │
│     _a.parallel().core().liquidatePartial(vaultId, amount);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     (address proxy, address router) = _dexAP.dexMapping(dexIndex);                                                                                                                                              │
│     collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));                                                                                                                                   │
│     router.call(dexTxData);                                                                                                                                                                                     │
│     _par.safeTransfer(msg.sender, _liquidateCallerReward);                                                                                                                                                      │
│     require(_par.balanceOf(address(this)) > parBalanceBefore, "LM104");                                                                                                                                         │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);                                                                                                                                       │
│                                                                                                                                                                                                                 │
│     state.refreshCollateral(v.collateralType);                                                                                                                                                                  │
│                                                                                                                                                                                                                 │
│     uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│                                                                                                                                                                                                                 │
│     require(                                                                                                                                                                                                    │
│       !a.liquidationManager().isHealthy(                                                                                                                                                                        │
│         collateralValue,                                                                                                                                                                                        │
│         currentVaultDebt,                                                                                                                                                                                       │
│         a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).liquidationRatio                                                                                                               │
│       )                                                                                                                                                                                                         │
│     );                                                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(                                                                                                                                           │
│       a.config().collateralLiquidationFee(v.collateralType)                                                                                                                                                     │
│     );                                                                                                                                                                                                          │
│     uint256 maxLiquiditionCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│                                                                                                                                                                                                                 │
│     uint256 repayAmount;                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     if (_amount > maxLiquiditionCost) {                                                                                                                                                                         │
│       _amount = maxLiquiditionCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // collateral value to be received by the liquidator is based on the total amount repaid (including the liquidationFee).                                                                                    │
│     uint256 collateralValueToReceive = _amount.add(a.liquidationManager().liquidationBonus(v.collateralType, _amount));                                                                                         │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation fee                                                                                                                                                       │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = a.liquidationManager().applyLiquidationDiscount(                                                                                                                      │
│         v.collateralType,                                                                                                                                                                                       │
│         collateralValue                                                                                                                                                                                         │
│       );                                                                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(a.stablex().balanceOf(address(this)) >= insuranceAmount);                                                                                                                                       │
│         a.stablex().burn(address(this), insuranceAmount); // Insurance uses local reserves to pay down debt                                                                                                     │
│         emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);                                                                                                                                              │
│       }                                                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│                                                                                                                                                                                                                 │
│     // reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = a.priceFeed().convertTo(v.collateralType, collateralValueToReceive);                                                                                                          │
│     a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                                │
│     IERC20 asset = IERC20(v.collateralType);                                                                                                                                                                    │
│     asset.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                                        │
│                                                                                                                                                                                                                 │
│     debtNotifier.debtChanged(_vaultId);                                                                                                                                                                         │
│                                                                                                                                                                                                                 │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function initialize(                                                                                                                                                                                          │
│     address _owner,                                                                                                                                                                                             │
│     VaultConfig memory vaultConfig,                                                                                                                                                                             │
│     IERC20 inceptionCollateral,                                                                                                                                                                                 │
│     IAddressProvider addressProvider,                                                                                                                                                                           │
│     IAdminInceptionVault adminInceptionVault,                                                                                                                                                                   │
│     IInceptionVaultsDataProvider inceptionVaultsDataProvider,                                                                                                                                                   │
│     IInceptionVaultPriceFeed inceptionPriceFeed                                                                                                                                                                 │
│   ) external override initializer {                                                                                                                                                                             │
│     _vaultConfig = vaultConfig;                                                                                                                                                                                 │
│     _inceptionCollateral = inceptionCollateral;                                                                                                                                                                 │
│     _lastRefresh = block.timestamp;                                                                                                                                                                             │
│     _cumulativeRate = WadRayMath.ray();                                                                                                                                                                         │
│     _a = addressProvider;                                                                                                                                                                                       │
│     _adminInceptionVault = adminInceptionVault;                                                                                                                                                                 │
│     _inceptionVaultsData = inceptionVaultsDataProvider;                                                                                                                                                         │
│     owner = _owner;                                                                                                                                                                                             │
│     _inceptionPriceFeed = inceptionPriceFeed;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                              │
│     // Make sure current rate is up to date                                                                                                                                                                     │
│     _refreshCumulativeRate();                                                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);                                                                                                                                        │
│     // Decrement vault borrow balance                                                                                                                                                                           │
│     if (_amount >= currentVaultDebt) {                                                                                                                                                                          │
│       // Full repayment                                                                                                                                                                                         │
│       _amount = currentVaultDebt; //only pay back what's outstanding                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     _reduceVaultDebt(_vaultId, _amount);                                                                                                                                                                        │
│     // This will require a user allowance first                                                                                                                                                                 │
│     IERC20 stablex = IERC20(_a.stablex());                                                                                                                                                                      │
│     stablex.safeTransferFrom(msg.sender, address(_adminInceptionVault), _amount);                                                                                                                               │
│     emit Repaid(_vaultId, _amount, msg.sender);                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ have inside code statements that update/accrue interest/exchange rate,                                                                                                                                          │
│ Code:                                                                                                                                                                                                           │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);                                                                                                               │
│     _refreshCumulativeRate();                                                                                                                                                                                   │
│     uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);                                                                                                                             │
│     uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);                                                                                                                                        │
│     require(                                                                                                                                                                                                    │
│       !_a.liquidationManager().isHealthy(collateralValue, currentVaultDebt, _vaultConfig.liquidationRatio),                                                                                                     │
│       "IV103"                                                                                                                                                                                                   │
│     );                                                                                                                                                                                                          │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);                                                                                                              │
│     uint256 maxLiquidationCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│     uint256 repayAmount;                                                                                                                                                                                        │
│     if (_amount > maxLiquidationCost) {                                                                                                                                                                         │
│       _amount = maxLiquidationCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     uint256 collateralValueToReceive = _amount.add(_amount.wadMul(_vaultConfig.liquidationBonus));                                                                                                              │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation bonus                                                                                                                                                     │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = collateralValue.wadDiv(_vaultConfig.liquidationBonus.add(WadRayMath.wad()));                                                                                          │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(_a.stablex().balanceOf(address(_adminInceptionVault)) >= insuranceAmount, "IV104");                                                                                                             │
│       }                                                                                                                                                                                                         │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     // Reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     IERC20 stablex = IERC20(_a.stablex());                                                                                                                                                                      │
│     stablex.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                               │
│     stablex.safeTransfer(address(_adminInceptionVault), _amount);                                                                                                                                               │
│     // Send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = _inceptionPriceFeed.convertTo(collateralValueToReceive);                                                                                                                      │
│     _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                          │
│     _inceptionCollateral.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                         │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No",                                                                                                                                                                                                    │
│   "2": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);                                                                                                               │
│     _refreshCumulativeRate();                                                                                                                                                                                   │
│     uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);                                                                                                                             │
│     uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);                                                                                                                                        │
│     require(                                                                                                                                                                                                    │
│       !_a.liquidationManager().isHealthy(collateralValue, currentVaultDebt, _vaultConfig.liquidationRatio),                                                                                                     │
│       "IV103"                                                                                                                                                                                                   │
│     );                                                                                                                                                                                                          │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);                                                                                                              │
│     uint256 maxLiquidationCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│     uint256 repayAmount;                                                                                                                                                                                        │
│     if (_amount > maxLiquidationCost) {                                                                                                                                                                         │
│       _amount = maxLiquidationCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     uint256 collateralValueToReceive = _amount.add(_amount.wadMul(_vaultConfig.liquidationBonus));                                                                                                              │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation bonus                                                                                                                                                     │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = collateralValue.wadDiv(_vaultConfig.liquidationBonus.add(WadRayMath.wad()));                                                                                          │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(_a.stablex().balanceOf(address(_adminInceptionVault)) >= insuranceAmount, "IV104");                                                                                                             │
│       }                                                                                                                                                                                                         │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     // Reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     IERC20 stablex = IERC20(_a.stablex());                                                                                                                                                                      │
│     stablex.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                               │
│     stablex.safeTransfer(address(_adminInceptionVault), _amount);                                                                                                                                               │
│     // Send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = _inceptionPriceFeed.convertTo(collateralValueToReceive);                                                                                                                      │
│     _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                          │
│     _inceptionCollateral.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                         │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have code statements that get or calculate LP token's value/price                                                                                                                                    │
│ Code:                                                                                                                                                                                                           │
│   function liquidate(                                                                                                                                                                                           │
│     uint256 vaultId,                                                                                                                                                                                            │
│     uint256 amount,                                                                                                                                                                                             │
│     uint256 dexIndex,                                                                                                                                                                                           │
│     bytes calldata dexTxData                                                                                                                                                                                    │
│   ) public {                                                                                                                                                                                                    │
│     uint256 parBalanceBefore = _par.balanceOf(address(this));                                                                                                                                                   │
│                                                                                                                                                                                                                 │
│     IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);                                                                                                                        │
│     IERC20 collateralToken = IERC20(vault.collateralType);                                                                                                                                                      │
│     _a.parallel().core().liquidatePartial(vaultId, amount);                                                                                                                                                     │
│                                                                                                                                                                                                                 │
│     (address proxy, address router) = _dexAP.dexMapping(dexIndex);                                                                                                                                              │
│     collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));                                                                                                                                   │
│     router.call(dexTxData);                                                                                                                                                                                     │
│     _par.safeTransfer(msg.sender, _liquidateCallerReward);                                                                                                                                                      │
│     require(_par.balanceOf(address(this)) > parBalanceBefore, "LM104");                                                                                                                                         │
│     _refreshPAR(_totalStake);                                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);                                                                                                               │
│     _refreshCumulativeRate();                                                                                                                                                                                   │
│     uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);                                                                                                                             │
│     uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);                                                                                                                                        │
│     require(                                                                                                                                                                                                    │
│       !_a.liquidationManager().isHealthy(collateralValue, currentVaultDebt, _vaultConfig.liquidationRatio),                                                                                                     │
│       "IV103"                                                                                                                                                                                                   │
│     );                                                                                                                                                                                                          │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);                                                                                                              │
│     uint256 maxLiquidationCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│     uint256 repayAmount;                                                                                                                                                                                        │
│     if (_amount > maxLiquidationCost) {                                                                                                                                                                         │
│       _amount = maxLiquidationCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     uint256 collateralValueToReceive = _amount.add(_amount.wadMul(_vaultConfig.liquidationBonus));                                                                                                              │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation bonus                                                                                                                                                     │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = collateralValue.wadDiv(_vaultConfig.liquidationBonus.add(WadRayMath.wad()));                                                                                          │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(_a.stablex().balanceOf(address(_adminInceptionVault)) >= insuranceAmount, "IV104");                                                                                                             │
│       }                                                                                                                                                                                                         │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     // Reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     IERC20 stablex = IERC20(_a.stablex());                                                                                                                                                                      │
│     stablex.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                               │
│     stablex.safeTransfer(address(_adminInceptionVault), _amount);                                                                                                                                               │
│     // Send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = _inceptionPriceFeed.convertTo(collateralValueToReceive);                                                                                                                      │
│     _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                          │
│     _inceptionCollateral.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                         │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate() internal {                                                                                                                                                                  │
│     uint256 timestamp = block.timestamp;                                                                                                                                                                        │
│     uint256 _timeElapsed = block.timestamp.sub(_lastRefresh);                                                                                                                                                   │
│     _cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);                                                                                        │
│     _lastRefresh = timestamp;                                                                                                                                                                                   │
│     emit CumulativeRateUpdated(_timeElapsed, _cumulativeRate);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "Yes"                                                                                                                                                                                                    │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────── Single Choice Scenario ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate, and have inside code statements that calculate/assign/distribute the balance/share/stake/fee/loan/reward                      │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate() internal {                                                                                                                                                                  │
│     uint256 timestamp = block.timestamp;                                                                                                                                                                        │
│     uint256 _timeElapsed = block.timestamp.sub(_lastRefresh);                                                                                                                                                   │
│     _cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);                                                                                        │
│     _lastRefresh = timestamp;                                                                                                                                                                                   │
│     emit CumulativeRateUpdated(_timeElapsed, _cumulativeRate);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Yes                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── Multiple Choice Scenarios ───────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: have inside code statements that update/accrue interest/exchange rate,                                                                                                                               │
│ Code:                                                                                                                                                                                                           │
│   function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {                                                                                                                                       │
│     uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);                                                                                                                                        │
│     uint256 remainder = currentVaultDebt.sub(_amount);                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     if (remainder == 0) {                                                                                                                                                                                       │
│       _inceptionVaultsData.setBaseDebt(_vaultId, 0);                                                                                                                                                            │
│     } else {                                                                                                                                                                                                    │
│       uint256 newBaseDebt = _a.ratesManager().calculateBaseDebt(remainder, _cumulativeRate);                                                                                                                    │
│       _inceptionVaultsData.setBaseDebt(_vaultId, newBaseDebt);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "1": "No"                                                                                                                                                                                                     │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function refreshCollateral(address _collateralType) public override {                                                                                                                                         │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     require(a.config().collateralIds(_collateralType) != 0);                                                                                                                                                    │
│     uint256 timestamp = now;                                                                                                                                                                                    │
│     uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);                                                                                                                                          │
│     _refreshCumulativeRate(_collateralType, timeElapsed);                                                                                                                                                       │
│     lastRefresh[_collateralType] = timestamp;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_refreshCumulativeRate(_collateralType, timeElapsed);`                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function refreshCollateral(address _collateralType) public override {                                                                                                                                         │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     require(a.config().collateralIds(_collateralType) != 0);                                                                                                                                                    │
│     uint256 timestamp = now;                                                                                                                                                                                    │
│     uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);                                                                                                                                          │
│     _refreshCumulativeRate(_collateralType, timeElapsed);                                                                                                                                                       │
│     lastRefresh[_collateralType] = timestamp;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_refreshCumulativeRate(_collateralType, timeElapsed);`                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:56:48] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/v1/VaultsCoreV1.sol, current          tasks.py:260
                             function: refreshCollateral, current vul: wrong-order-interest                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {                                                                                                                     │
│     uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);                                                                                                                                      │
│     uint256 oldCumulativeRate = cumulativeRates[_collateralType];                                                                                                                                               │
│     cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );                                                                                                                                                                                                          │
│     emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                   │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );`                                                                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {                                                                                                                     │
│     uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);                                                                                                                                      │
│     uint256 oldCumulativeRate = cumulativeRates[_collateralType];                                                                                                                                               │
│     cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );                                                                                                                                                                                                          │
│     emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                   │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );`                                                                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:56:49] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/v1/VaultsCoreV1.sol, current          tasks.py:260
                             function: _refreshCumulativeRate, current vul: wrong-order-interest                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                              │
│     address collateralType = a.vaultsData().vaultCollateralType(_vaultId);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // Make sure current rate is up to date                                                                                                                                                                     │
│     refreshCollateral(collateralType);                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│     // Decrement vault borrow balance                                                                                                                                                                           │
│     if (_amount >= currentVaultDebt) {                                                                                                                                                                          │
│       //full repayment                                                                                                                                                                                          │
│       _amount = currentVaultDebt; //only pay back what's outstanding                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     _reduceVaultDebt(_vaultId, _amount);                                                                                                                                                                        │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     emit Repaid(_vaultId, _amount, msg.sender);                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `refreshCollateral(collateralType);`                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                              │
│     address collateralType = a.vaultsData().vaultCollateralType(_vaultId);                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     // Make sure current rate is up to date                                                                                                                                                                     │
│     refreshCollateral(collateralType);                                                                                                                                                                          │
│                                                                                                                                                                                                                 │
│     uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);                                                                                                                                              │
│     // Decrement vault borrow balance                                                                                                                                                                           │
│     if (_amount >= currentVaultDebt) {                                                                                                                                                                          │
│       //full repayment                                                                                                                                                                                          │
│       _amount = currentVaultDebt; //only pay back what's outstanding                                                                                                                                            │
│     }                                                                                                                                                                                                           │
│     _reduceVaultDebt(_vaultId, _amount);                                                                                                                                                                        │
│     a.stablex().burn(msg.sender, _amount);                                                                                                                                                                      │
│                                                                                                                                                                                                                 │
│     emit Repaid(_vaultId, _amount, msg.sender);                                                                                                                                                                 │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward is `a.vaultsData().vaultCollateralType(_vaultId);`.                                                                  │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:56:50] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/v1/VaultsCoreV1.sol, current          tasks.py:260
                             function: repay, current vul: wrong-order-interest                                                                                                                                    
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "collateralValue": "Holds the calculated value of collateral in the vault"                                                                                                                                  │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "collateralToReceive": "Holds the calculated value of collateral to be received by the liquidator"                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:56:55] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/v1/VaultsCoreV1.sol, current          tasks.py:260
                             function: liquidate, current vul: price-manipulation                                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralConfig(                                                                                                                                                                                 │
│     address _collateralType,                                                                                                                                                                                    │
│     uint256 _debtLimit,                                                                                                                                                                                         │
│     uint256 _minCollateralRatio,                                                                                                                                                                                │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _originationFee                                                                                                                                                                                     │
│   ) public override onlyManager {                                                                                                                                                                               │
│     require(address(_collateralType) != address(0));                                                                                                                                                            │
│     if (collateralIds[_collateralType] == 0) {                                                                                                                                                                  │
│       //new collateral                                                                                                                                                                                          │
│       IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);                                                                                                                                        │
│       CollateralConfig memory config = CollateralConfig({                                                                                                                                                       │
│         collateralType: _collateralType,                                                                                                                                                                        │
│         debtLimit: _debtLimit,                                                                                                                                                                                  │
│         minCollateralRatio: _minCollateralRatio,                                                                                                                                                                │
│         borrowRate: _borrowRate,                                                                                                                                                                                │
│         originationFee: _originationFee                                                                                                                                                                         │
│       });                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       numCollateralConfigs++;                                                                                                                                                                                   │
│       _collateralConfigs = config;                                                                                                                                                                              │
│       collateralIds[_collateralType] = numCollateralConfigs;                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       // Update collateral config                                                                                                                                                                               │
│       IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);                                                                                                                                      │
│       uint256 id = collateralIds[_collateralType];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       _collateralConfigs.collateralType = _collateralType;                                                                                                                                                      │
│       _collateralConfigs.debtLimit = _debtLimit;                                                                                                                                                                │
│       _collateralConfigs.minCollateralRatio = _minCollateralRatio;                                                                                                                                              │
│       _collateralConfigs.borrowRate = _borrowRate;                                                                                                                                                              │
│       _collateralConfigs.originationFee = _originationFee;                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);`.                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralConfig(                                                                                                                                                                                 │
│     address _collateralType,                                                                                                                                                                                    │
│     uint256 _debtLimit,                                                                                                                                                                                         │
│     uint256 _minCollateralRatio,                                                                                                                                                                                │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _originationFee                                                                                                                                                                                     │
│   ) public override onlyManager {                                                                                                                                                                               │
│     require(address(_collateralType) != address(0));                                                                                                                                                            │
│     if (collateralIds[_collateralType] == 0) {                                                                                                                                                                  │
│       //new collateral                                                                                                                                                                                          │
│       IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);                                                                                                                                        │
│       CollateralConfig memory config = CollateralConfig({                                                                                                                                                       │
│         collateralType: _collateralType,                                                                                                                                                                        │
│         debtLimit: _debtLimit,                                                                                                                                                                                  │
│         minCollateralRatio: _minCollateralRatio,                                                                                                                                                                │
│         borrowRate: _borrowRate,                                                                                                                                                                                │
│         originationFee: _originationFee                                                                                                                                                                         │
│       });                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       numCollateralConfigs++;                                                                                                                                                                                   │
│       _collateralConfigs = config;                                                                                                                                                                              │
│       collateralIds[_collateralType] = numCollateralConfigs;                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       // Update collateral config                                                                                                                                                                               │
│       IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);                                                                                                                                      │
│       uint256 id = collateralIds[_collateralType];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       _collateralConfigs.collateralType = _collateralType;                                                                                                                                                      │
│       _collateralConfigs.debtLimit = _debtLimit;                                                                                                                                                                │
│       _collateralConfigs.minCollateralRatio = _minCollateralRatio;                                                                                                                                              │
│       _collateralConfigs.borrowRate = _borrowRate;                                                                                                                                                              │
│       _collateralConfigs.originationFee = _originationFee;                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);                                                                                                     │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_collateralConfigs = config;`                                                                                                                                                                                  │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:56:56] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/v1/ConfigProviderV1.sol, current      tasks.py:260
                             function: setCollateralConfig, current vul: wrong-order-interest                                                                                                                      
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "priceA": "Holds the price value from oracleA",                                                                                                                                                             │
│     "priceB": "Holds the price value from oracleB",                                                                                                                                                             │
│     "rA": "Holds the balance of token A in the pool",                                                                                                                                                           │
│     "rB": "Holds the balance of token B in the pool",                                                                                                                                                           │
│     "totalSupply": "Holds the total supply of LP tokens in the pool"                                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "answer": "Holds the calculated value/price of LP token"                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:56:57] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/oracles/GUniLPOracle.sol, current     tasks.py:260
                             function: latestRoundData, current vul: price-manipulation                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "eurAnswer": "Holds the EUR price data from the oracle",                                                                                                                                                    │
│     "answer": "Holds the price data for the specified asset from the oracle"                                                                                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "price": "Holds the calculated value/price of LP token"                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:56:58] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/oracles/GUniLPOracle.sol, current     tasks.py:359
                             function: latestRoundData, current vul: price-manipulation                                                                                                                            
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "fairResA": "Calculated value of fairResA",                                                                                                                                                                 │
│     "fairResB": "Calculated value of fairResB",                                                                                                                                                                 │
│     "pxA": "Calculated value of pxA",                                                                                                                                                                           │
│     "pxB": "Calculated value of pxB",                                                                                                                                                                           │
│     "pool.totalSupply()": "Total supply of LP tokens"                                                                                                                                                           │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "answer": "Variable holding the calculated value of LP token price"                                                                                                                                         │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:56:59] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/oracles/BalancerV2LPOracle.sol,       tasks.py:260
                             current function: latestRoundData, current vul: price-manipulation                                                                                                                    
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "eurAnswer": "Holds the EUR price data from the oracle",                                                                                                                                                    │
│     "eurUpdatedAt": "Holds the timestamp when EUR price data was last updated",                                                                                                                                 │
│     "answer": "Holds the price data from the specific asset oracle",                                                                                                                                            │
│     "assetUpdatedAt": "Holds the timestamp when asset price data was last updated"                                                                                                                              │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "price": "Holds the calculated value/price of LP token"                                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:00] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/oracles/BalancerV2LPOracle.sol,       tasks.py:359
                             current function: latestRoundData, current vul: price-manipulation                                                                                                                    
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "currentBalance": "Holds the custom token balanceOf calculation"                                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_accAmountPerShare": "Holds the calculated value of LP token"                                                                                                                                              │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:02] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:260
                             function: _refresh, current vul: price-manipulation                                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Tracks the MIMO balance for calculations",                                                                                                                                          │
│     "_parBalanceTracker": "Tracks the PAR balance for calculations"                                                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingMIMO": "Holds the calculated value of pending MIMO tokens"                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:359
                             function: _refresh, current vul: price-manipulation                                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_balanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation"                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:03] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:359
                             function: _refresh, current vul: price-manipulation                                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_balanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation"                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:04] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:359
                             function: _refresh, current vul: price-manipulation                                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "currentParBalance": "Holds the calculated value of the current Par balance"                                                                                                                                │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_accParAmountPerShare": "Holds the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:05] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:260
                             function: _refreshPAR, current vul: price-manipulation                                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate",                                                                                                                                   │
│     "_parBalanceTracker": "Holds the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                                                           │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Holds the calculated value/price of LP token"                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:359
                             function: _refreshPAR, current vul: price-manipulation                                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation"                                                                                                                         │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:06] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:359
                             function: _refreshPAR, current vul: price-manipulation                                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate"                                                                                                                                     │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Holds the calculated value/price of LP token"                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:07] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:359
                             function: _refreshPAR, current vul: price-manipulation                                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation"                                                                                                                         │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:08] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/PARMiner.sol, current tasks.py:359
                             function: _refreshPAR, current vul: price-manipulation                                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "currentBalance": "Holds the custom token balanceOf calculation"                                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_accAmountPerShare": "Holds the calculated value of LP token"                                                                                                                                              │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/GenericMiner.sol,     tasks.py:260
                             current function: _refresh, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Variable holding market reserves/AMM price/exchange rate",                                                                                                                          │
│     "_parBalanceTracker": "Variable holding custom token balance/total supply/amount/liquidity calculation"                                                                                                     │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:09] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/GenericMiner.sol,     tasks.py:359
                             current function: _refresh, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_balanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation"                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:10] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/GenericMiner.sol,     tasks.py:359
                             current function: _refresh, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_totalStake": "Variable holding the total stake amount"                                                                                                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_accMimoAmountPerShare": "Variable holding the calculated value/price of LP token"                                                                                                                         │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:11] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:260
                             current function: _refresh, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_balanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation"                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _refresh, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_par": "Holds the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                                                                         │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_accParAmountPerShare": "Holds the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:12] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:260
                             current function: _refreshPAR, current vul: price-manipulation                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Variable holding market reserves/AMM price/exchange rate calculation",                                                                                                              │
│     "_parBalanceTracker": "Variable holding custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:13] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _refreshPAR, current vul: price-manipulation                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_parBalanceTracker": "Stores the market reserves/AMMprice/exchangeRate calculation"                                                                                                                        │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:14] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _refreshPAR, current vul: price-manipulation                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation"                                                                                                                         │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Holds the calculated value/price of LP token"                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:15] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _refreshPAR, current vul: price-manipulation                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate",                                                                                                                                    │
│     "userInfo.accParAmountPerShare": "Holds the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                                                │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:16] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _refreshPAR, current vul: price-manipulation                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_a.mimo().balanceOf(address(this))": "Variable holding the market reserves/AMMprice/exchangeRate"                                                                                                          │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "accMimoAmountPerShare": "Variable holding the calculated value/price of LP token"                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:17] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:260
                             current function: _pendingMIMO, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Variable holding market reserves/AMM price/exchange rate",                                                                                                                          │
│     "_parBalanceTracker": "Variable holding custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:18] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _pendingMIMO, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate for MIMO token",                                                                                                                    │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate for PAR token"                                                                                                                       │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingMIMO": "Holds the calculated value/price of LP token"                                                                                                                                               │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:19] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _pendingMIMO, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Tracks the MIMO balance for calculations",                                                                                                                                          │
│     "_parBalanceTracker": "Tracks the PAR balance for calculations"                                                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingMIMO": "Holds the calculated value of pending MIMO tokens"                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:20] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _pendingMIMO, current vul: price-manipulation                                                                                                                       
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_boostConfig": "Holds the boost configuration variables for calculations"                                                                                                                                  │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "multiplier": "Holds the calculated value/price of LP token"                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:21] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:260
                             current function: _getBoostMultiplier, current vul: price-manipulation                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_totalStakeWithBoost": "Market reserves/AMM price/exchange rate calculation"                                                                                                                               │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "multiplier": "Calculated value/price of LP token"                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:22] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/PARMinerV2.sol,    tasks.py:359
                             current function: _getBoostMultiplier, current vul: price-manipulation                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_totalStake": "Variable holding the total stake amount"                                                                                                                                                    │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_accMimoAmountPerShare": "Variable holding the calculated value of MIMO LP token"                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _refresh, current vul: price-manipulation                                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Variable holding market reserves/AMMprice/exchangeRate",                                                                                                                            │
│     "_parBalanceTracker": "Variable holding market reserves/AMMprice/exchangeRate"                                                                                                                              │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:23] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _refresh, current vul: price-manipulation                                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation for MIMO token",                                                                                                        │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate calculation for PAR token"                                                                                                           │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingMIMO": "Holds the calculated value/price of LP token for MIMO token"                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:24] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _refresh, current vul: price-manipulation                                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate"                                                                                                                                     │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pending": "Holds the calculated value/price of LP token"                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:25] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _refresh, current vul: price-manipulation                                                                                                                                             
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_a.mimo().balanceOf(address(this))": "Variable holding the market reserves/AMMprice/exchangeRate"                                                                                                          │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "accMimoAmountPerShare": "Variable holding the calculated value/price of LP token"                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:26] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingMIMO, current vul: price-manipulation                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Tracks the MIMO balance for rewards distribution",                                                                                                                                  │
│     "_parBalanceTracker": "Tracks the PAR balance for rewards distribution",                                                                                                                                    │
│     "_accParAmountPerShare": "Accumulated PAR amount per share for reward calculation",                                                                                                                         │
│     "_userInfo.stakeWithBoost": "User's stake with boost for reward calculation"                                                                                                                                │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Holds the calculated pending PAR rewards"                                                                                                                                                    │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:27] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingMIMO, current vul: price-manipulation                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate for MIMO token",                                                                                                                    │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate for PAR token"                                                                                                                       │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingMIMO": "Holds the calculated value/price of LP token for MIMO token"                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:28] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingMIMO, current vul: price-manipulation                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Tracks the MIMO balance for calculations",                                                                                                                                          │
│     "_parBalanceTracker": "Tracks the PAR balance for calculations"                                                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingMIMO": "Holds the calculated value of pending MIMO tokens"                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:29] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingMIMO, current vul: price-manipulation                                                                                                                                         
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_par": "Token balanceOf/totalSupply/amount/liquidity calculation"                                                                                                                                          │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "accParAmountPerShare": "Calculated value/price of LP token"                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingPAR, current vul: price-manipulation                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate",                                                                                                                                   │
│     "_parBalanceTracker": "Holds the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                                                           │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Holds the calculated value/price of LP token"                                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:30] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingPAR, current vul: price-manipulation                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate for MIMO token",                                                                                                                    │
│     "_parBalanceTracker": "Holds the market reserves/AMMprice/exchangeRate for PAR token"                                                                                                                       │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingMIMO": "Holds the calculated value/price of LP token for MIMO token"                                                                                                                                │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:32] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingPAR, current vul: price-manipulation                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_mimoBalanceTracker": "Tracks the MIMO balance for the user",                                                                                                                                              │
│     "_parBalanceTracker": "Tracks the PAR balance for the user"                                                                                                                                                 │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingMIMO": "Holds the calculated value of pending MIMO tokens"                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingPAR, current vul: price-manipulation                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_par": "Token balanceOf/totalSupply/amount/liquidity calculation",                                                                                                                                         │
│     "_totalStake": "Token balanceOf/totalSupply/amount/liquidity calculation",                                                                                                                                  │
│     "_parBalanceTracker": "Token balanceOf/totalSupply/amount/liquidity calculation",                                                                                                                           │
│     "_accParAmountPerShare": "Market reserves/AMMprice/exchangeRate"                                                                                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "reward": "Calculated value/price of LP token"                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:34] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingPAR, current vul: price-manipulation                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_totalStake": "Variable holding the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                          │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "pendingPAR": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:35] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _pendingPAR, current vul: price-manipulation                                                                                                                                          
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_boostConfig": "Variables holding boost configuration parameters like a, b, c, d, e, maxBoost"                                                                                                             │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "multiplier": "Variable holding the calculated value/price of LP token"                                                                                                                                     │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:36] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:260
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _getBoostMultiplier, current vul: price-manipulation                                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_totalStakeWithBoost": "Market reserves/AMM price/exchange rate calculation"                                                                                                                               │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "multiplier": "Calculated value/price of LP token"                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:37] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _getBoostMultiplier, current vul: price-manipulation                                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_totalStakeWithBoost": "Holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_userInfo.stakeWithBoost": "Holds the calculated value/price of LP token"                                                                                                                                  │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:38] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File:                                                                                                                                                      tasks.py:359
                             /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/liquidityMining/v2/GenericMinerV2.sol, current function:               
                             _getBoostMultiplier, current vul: price-manipulation                                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralConfig(                                                                                                                                                                                 │
│     address _collateralType,                                                                                                                                                                                    │
│     uint256 _debtLimit,                                                                                                                                                                                         │
│     uint256 _liquidationRatio,                                                                                                                                                                                  │
│     uint256 _minCollateralRatio,                                                                                                                                                                                │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _originationFee,                                                                                                                                                                                    │
│     uint256 _liquidationBonus,                                                                                                                                                                                  │
│     uint256 _liquidationFee                                                                                                                                                                                     │
│   ) public override onlyManager {                                                                                                                                                                               │
│     require(address(_collateralType) != address(0));                                                                                                                                                            │
│     require(_minCollateralRatio >= _liquidationRatio);                                                                                                                                                          │
│     if (collateralIds[_collateralType] == 0) {                                                                                                                                                                  │
│       // Initialize new collateral                                                                                                                                                                              │
│       a.core().state().initializeRates(_collateralType);                                                                                                                                                        │
│       CollateralConfig memory config = CollateralConfig({                                                                                                                                                       │
│         collateralType: _collateralType,                                                                                                                                                                        │
│         debtLimit: _debtLimit,                                                                                                                                                                                  │
│         liquidationRatio: _liquidationRatio,                                                                                                                                                                    │
│         minCollateralRatio: _minCollateralRatio,                                                                                                                                                                │
│         borrowRate: _borrowRate,                                                                                                                                                                                │
│         originationFee: _originationFee,                                                                                                                                                                        │
│         liquidationBonus: _liquidationBonus,                                                                                                                                                                    │
│         liquidationFee: _liquidationFee                                                                                                                                                                         │
│       });                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       numCollateralConfigs++;                                                                                                                                                                                   │
│       _collateralConfigs = config;                                                                                                                                                                              │
│       collateralIds[_collateralType] = numCollateralConfigs;                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       // Update collateral config                                                                                                                                                                               │
│       a.core().state().refreshCollateral(_collateralType);                                                                                                                                                      │
│       uint256 id = collateralIds[_collateralType];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       _collateralConfigs.collateralType = _collateralType;                                                                                                                                                      │
│       _collateralConfigs.debtLimit = _debtLimit;                                                                                                                                                                │
│       _collateralConfigs.liquidationRatio = _liquidationRatio;                                                                                                                                                  │
│       _collateralConfigs.minCollateralRatio = _minCollateralRatio;                                                                                                                                              │
│       _collateralConfigs.borrowRate = _borrowRate;                                                                                                                                                              │
│       _collateralConfigs.originationFee = _originationFee;                                                                                                                                                      │
│       _collateralConfigs.liquidationBonus = _liquidationBonus;                                                                                                                                                  │
│       _collateralConfigs.liquidationFee = _liquidationFee;                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     emit CollateralUpdated(                                                                                                                                                                                     │
│       _collateralType,                                                                                                                                                                                          │
│       _debtLimit,                                                                                                                                                                                               │
│       _liquidationRatio,                                                                                                                                                                                        │
│       _minCollateralRatio,                                                                                                                                                                                      │
│       _borrowRate,                                                                                                                                                                                              │
│       _originationFee,                                                                                                                                                                                          │
│       _liquidationBonus,                                                                                                                                                                                        │
│       _liquidationFee                                                                                                                                                                                           │
│     );                                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ The first statement to update/accrue interest/exchange rate is `a.core().state().initializeRates(_collateralType);`.                                                                                            │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function setCollateralConfig(                                                                                                                                                                                 │
│     address _collateralType,                                                                                                                                                                                    │
│     uint256 _debtLimit,                                                                                                                                                                                         │
│     uint256 _liquidationRatio,                                                                                                                                                                                  │
│     uint256 _minCollateralRatio,                                                                                                                                                                                │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _originationFee,                                                                                                                                                                                    │
│     uint256 _liquidationBonus,                                                                                                                                                                                  │
│     uint256 _liquidationFee                                                                                                                                                                                     │
│   ) public override onlyManager {                                                                                                                                                                               │
│     require(address(_collateralType) != address(0));                                                                                                                                                            │
│     require(_minCollateralRatio >= _liquidationRatio);                                                                                                                                                          │
│     if (collateralIds[_collateralType] == 0) {                                                                                                                                                                  │
│       // Initialize new collateral                                                                                                                                                                              │
│       a.core().state().initializeRates(_collateralType);                                                                                                                                                        │
│       CollateralConfig memory config = CollateralConfig({                                                                                                                                                       │
│         collateralType: _collateralType,                                                                                                                                                                        │
│         debtLimit: _debtLimit,                                                                                                                                                                                  │
│         liquidationRatio: _liquidationRatio,                                                                                                                                                                    │
│         minCollateralRatio: _minCollateralRatio,                                                                                                                                                                │
│         borrowRate: _borrowRate,                                                                                                                                                                                │
│         originationFee: _originationFee,                                                                                                                                                                        │
│         liquidationBonus: _liquidationBonus,                                                                                                                                                                    │
│         liquidationFee: _liquidationFee                                                                                                                                                                         │
│       });                                                                                                                                                                                                       │
│                                                                                                                                                                                                                 │
│       numCollateralConfigs++;                                                                                                                                                                                   │
│       _collateralConfigs = config;                                                                                                                                                                              │
│       collateralIds[_collateralType] = numCollateralConfigs;                                                                                                                                                    │
│     } else {                                                                                                                                                                                                    │
│       // Update collateral config                                                                                                                                                                               │
│       a.core().state().refreshCollateral(_collateralType);                                                                                                                                                      │
│       uint256 id = collateralIds[_collateralType];                                                                                                                                                              │
│                                                                                                                                                                                                                 │
│       _collateralConfigs.collateralType = _collateralType;                                                                                                                                                      │
│       _collateralConfigs.debtLimit = _debtLimit;                                                                                                                                                                │
│       _collateralConfigs.liquidationRatio = _liquidationRatio;                                                                                                                                                  │
│       _collateralConfigs.minCollateralRatio = _minCollateralRatio;                                                                                                                                              │
│       _collateralConfigs.borrowRate = _borrowRate;                                                                                                                                                              │
│       _collateralConfigs.originationFee = _originationFee;                                                                                                                                                      │
│       _collateralConfigs.liquidationBonus = _liquidationBonus;                                                                                                                                                  │
│       _collateralConfigs.liquidationFee = _liquidationFee;                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     emit CollateralUpdated(                                                                                                                                                                                     │
│       _collateralType,                                                                                                                                                                                          │
│       _debtLimit,                                                                                                                                                                                               │
│       _liquidationRatio,                                                                                                                                                                                        │
│       _minCollateralRatio,                                                                                                                                                                                      │
│       _borrowRate,                                                                                                                                                                                              │
│       _originationFee,                                                                                                                                                                                          │
│       _liquidationBonus,                                                                                                                                                                                        │
│       _liquidationFee                                                                                                                                                                                           │
│     );                                                                                                                                                                                                          │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_collateralConfigs = config;`                                                                                                                                                                                  │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:39] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/core/ConfigProvider.sol, current      tasks.py:260
                             function: setCollateralConfig, current vul: wrong-order-interest                                                                                                                      
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function calculateCumulativeRate(                                                                                                                                                                             │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _cumulativeRate,                                                                                                                                                                                    │
│     uint256 _timeElapsed                                                                                                                                                                                        │
│   ) public view override returns (uint256) {                                                                                                                                                                    │
│     if (_timeElapsed == 0) return _cumulativeRate;                                                                                                                                                              │
│     uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);                                                                                                                                               │
│     return _cumulativeRate.rayMul(cumulativeElapsed);                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);`                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function calculateCumulativeRate(                                                                                                                                                                             │
│     uint256 _borrowRate,                                                                                                                                                                                        │
│     uint256 _cumulativeRate,                                                                                                                                                                                    │
│     uint256 _timeElapsed                                                                                                                                                                                        │
│   ) public view override returns (uint256) {                                                                                                                                                                    │
│     if (_timeElapsed == 0) return _cumulativeRate;                                                                                                                                                              │
│     uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);                                                                                                                                               │
│     return _cumulativeRate.rayMul(cumulativeElapsed);                                                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);`                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
                    ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/core/RatesManager.sol, current        tasks.py:260
                             function: calculateCumulativeRate, current vul: wrong-order-interest                                                                                                                  
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function syncState(IVaultsCoreState _stateAddress) public override onlyManager notSynced {                                                                                                                    │
│     for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {                                                                                                                                          │
│       address collateralType = a.config().collateralConfigs(i).collateralType;                                                                                                                                  │
│       cumulativeRates = _stateAddress.cumulativeRates(collateralType);                                                                                                                                          │
│       lastRefresh = _stateAddress.lastRefresh(collateralType);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     synced = true;                                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `cumulativeRates = _stateAddress.cumulativeRates(collateralType);`                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function syncState(IVaultsCoreState _stateAddress) public override onlyManager notSynced {                                                                                                                    │
│     for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {                                                                                                                                          │
│       address collateralType = a.config().collateralConfigs(i).collateralType;                                                                                                                                  │
│       cumulativeRates = _stateAddress.cumulativeRates(collateralType);                                                                                                                                          │
│       lastRefresh = _stateAddress.lastRefresh(collateralType);                                                                                                                                                  │
│     }                                                                                                                                                                                                           │
│     synced = true;                                                                                                                                                                                              │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `cumulativeRates = _stateAddress.cumulativeRates(collateralType);`                                                                                                                                              │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:41] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/core/VaultsCoreState.sol, current     tasks.py:260
                             function: syncState, current vul: wrong-order-interest                                                                                                                                
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function refreshCollateral(address _collateralType) public override {                                                                                                                                         │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     require(a.config().collateralIds(_collateralType) != 0);                                                                                                                                                    │
│     uint256 timestamp = block.timestamp;                                                                                                                                                                        │
│     uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);                                                                                                                                          │
│     _refreshCumulativeRate(_collateralType, timeElapsed);                                                                                                                                                       │
│     lastRefresh[_collateralType] = timestamp;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_refreshCumulativeRate(_collateralType, timeElapsed);`                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function refreshCollateral(address _collateralType) public override {                                                                                                                                         │
│     require(_collateralType != address(0));                                                                                                                                                                     │
│     require(a.config().collateralIds(_collateralType) != 0);                                                                                                                                                    │
│     uint256 timestamp = block.timestamp;                                                                                                                                                                        │
│     uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);                                                                                                                                          │
│     _refreshCumulativeRate(_collateralType, timeElapsed);                                                                                                                                                       │
│     lastRefresh[_collateralType] = timestamp;                                                                                                                                                                   │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_refreshCumulativeRate(_collateralType, timeElapsed);`                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:42] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/core/VaultsCoreState.sol, current     tasks.py:260
                             function: refreshCollateral, current vul: wrong-order-interest                                                                                                                        
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {                                                                                                                     │
│     uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);                                                                                                                                      │
│     uint256 oldCumulativeRate = cumulativeRates[_collateralType];                                                                                                                                               │
│     cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );                                                                                                                                                                                                          │
│     emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                   │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );`                                                                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {                                                                                                                     │
│     uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);                                                                                                                                      │
│     uint256 oldCumulativeRate = cumulativeRates[_collateralType];                                                                                                                                               │
│     cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );                                                                                                                                                                                                          │
│     emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);                                                                                                                │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(                                                                                                                                   │
│       borrowRate,                                                                                                                                                                                               │
│       oldCumulativeRate,                                                                                                                                                                                        │
│       _timeElapsed                                                                                                                                                                                              │
│     );`                                                                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:46] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/core/VaultsCoreState.sol, current     tasks.py:260
                             function: _refreshCumulativeRate, current vul: wrong-order-interest                                                                                                                   
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "collateralValue": "Holds the calculated value of collateral in the vault"                                                                                                                                  │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "collateralToReceive": "Holds the calculated value of collateral to be received by the liquidator"                                                                                                          │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:54] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/core/VaultsCore.sol, current          tasks.py:260
                             function: liquidatePartial, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ {                                                                                                                                                                                                               │
│   "VariableA": {                                                                                                                                                                                                │
│     "_par": "Holds the market reserves/AMMprice/exchangeRate OR the custom token balanceOf/totalSupply/amount/liquidity calculation"                                                                            │
│   },                                                                                                                                                                                                            │
│   "VariableB": {                                                                                                                                                                                                │
│     "_liquidateCallerReward": "Holds the calculated value/price of LP token"                                                                                                                                    │
│   }                                                                                                                                                                                                             │
│ }                                                                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:55] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:357
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/core/VaultsCore.sol, current          tasks.py:359
                             function: liquidatePartial, current vul: price-manipulation                                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:361
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 355, in simple_cli                                                                                       
                                 falcon_instance, function2_text)                                                                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);                                                                                                               │
│     _refreshCumulativeRate();                                                                                                                                                                                   │
│     uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);                                                                                                                             │
│     uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);                                                                                                                                        │
│     require(                                                                                                                                                                                                    │
│       !_a.liquidationManager().isHealthy(collateralValue, currentVaultDebt, _vaultConfig.liquidationRatio),                                                                                                     │
│       "IV103"                                                                                                                                                                                                   │
│     );                                                                                                                                                                                                          │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);                                                                                                              │
│     uint256 maxLiquidationCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│     uint256 repayAmount;                                                                                                                                                                                        │
│     if (_amount > maxLiquidationCost) {                                                                                                                                                                         │
│       _amount = maxLiquidationCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     uint256 collateralValueToReceive = _amount.add(_amount.wadMul(_vaultConfig.liquidationBonus));                                                                                                              │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation bonus                                                                                                                                                     │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = collateralValue.wadDiv(_vaultConfig.liquidationBonus.add(WadRayMath.wad()));                                                                                          │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(_a.stablex().balanceOf(address(_adminInceptionVault)) >= insuranceAmount, "IV104");                                                                                                             │
│       }                                                                                                                                                                                                         │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     // Reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     IERC20 stablex = IERC20(_a.stablex());                                                                                                                                                                      │
│     stablex.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                               │
│     stablex.safeTransfer(address(_adminInceptionVault), _amount);                                                                                                                                               │
│     // Send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = _inceptionPriceFeed.convertTo(collateralValueToReceive);                                                                                                                      │
│     _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                          │
│     _inceptionCollateral.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                         │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_refreshCumulativeRate()`                                                                                                                                                                                      │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {                                                                                                                   │
│     IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);                                                                                                               │
│     _refreshCumulativeRate();                                                                                                                                                                                   │
│     uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);                                                                                                                             │
│     uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);                                                                                                                                        │
│     require(                                                                                                                                                                                                    │
│       !_a.liquidationManager().isHealthy(collateralValue, currentVaultDebt, _vaultConfig.liquidationRatio),                                                                                                     │
│       "IV103"                                                                                                                                                                                                   │
│     );                                                                                                                                                                                                          │
│     uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);                                                                                                              │
│     uint256 maxLiquidationCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);                                                                                                                    │
│     uint256 repayAmount;                                                                                                                                                                                        │
│     if (_amount > maxLiquidationCost) {                                                                                                                                                                         │
│       _amount = maxLiquidationCost;                                                                                                                                                                             │
│       repayAmount = currentVaultDebt;                                                                                                                                                                           │
│     } else {                                                                                                                                                                                                    │
│       repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);                                                                                                                                          │
│     }                                                                                                                                                                                                           │
│     uint256 collateralValueToReceive = _amount.add(_amount.wadMul(_vaultConfig.liquidationBonus));                                                                                                              │
│     uint256 insuranceAmount = 0;                                                                                                                                                                                │
│     if (collateralValueToReceive >= collateralValue) {                                                                                                                                                          │
│       // Not enough collateral for debt & liquidation bonus                                                                                                                                                     │
│       collateralValueToReceive = collateralValue;                                                                                                                                                               │
│       uint256 discountedCollateralValue = collateralValue.wadDiv(_vaultConfig.liquidationBonus.add(WadRayMath.wad()));                                                                                          │
│       if (currentVaultDebt > discountedCollateralValue) {                                                                                                                                                       │
│         // Not enough collateral for debt alone                                                                                                                                                                 │
│         insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);                                                                                                                                      │
│         require(_a.stablex().balanceOf(address(_adminInceptionVault)) >= insuranceAmount, "IV104");                                                                                                             │
│       }                                                                                                                                                                                                         │
│       repayAmount = currentVaultDebt.sub(insuranceAmount);                                                                                                                                                      │
│       _amount = discountedCollateralValue;                                                                                                                                                                      │
│     }                                                                                                                                                                                                           │
│     // Reduce the vault debt by repayAmount                                                                                                                                                                     │
│     _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));                                                                                                                                               │
│     IERC20 stablex = IERC20(_a.stablex());                                                                                                                                                                      │
│     stablex.safeTransferFrom(msg.sender, address(this), _amount);                                                                                                                                               │
│     stablex.safeTransfer(address(_adminInceptionVault), _amount);                                                                                                                                               │
│     // Send the claimed collateral to the liquidator                                                                                                                                                            │
│     uint256 collateralToReceive = _inceptionPriceFeed.convertTo(collateralValueToReceive);                                                                                                                      │
│     _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));                                                                                                          │
│     _inceptionCollateral.safeTransfer(msg.sender, collateralToReceive);                                                                                                                                         │
│     emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);                                                                                                                           │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);`                                                                                                                │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:56] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/inception/InceptionVaultsCore.sol,    tasks.py:260
                             current function: liquidatePartial, current vul: wrong-order-interest                                                                                                                 
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to update/accrue interest/exchange rate? Answer only ZERO or ONE statement, cover the code with backquotes.                    │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate() internal {                                                                                                                                                                  │
│     uint256 timestamp = block.timestamp;                                                                                                                                                                        │
│     uint256 _timeElapsed = block.timestamp.sub(_lastRefresh);                                                                                                                                                   │
│     _cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);                                                                                        │
│     _lastRefresh = timestamp;                                                                                                                                                                                   │
│     emit CumulativeRateUpdated(_timeElapsed, _cumulativeRate);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);`                                                                                          │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────── Current Step ──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Knowledge: In the given code, which inside code statement is the first statement to calculate/assign/distribute the balance/share/stake/fee/loan/reward? Answer only ZERO or ONE statement, cover the code with │
│ backquotes.                                                                                                                                                                                                     │
│ Code:                                                                                                                                                                                                           │
│   function _refreshCumulativeRate() internal {                                                                                                                                                                  │
│     uint256 timestamp = block.timestamp;                                                                                                                                                                        │
│     uint256 _timeElapsed = block.timestamp.sub(_lastRefresh);                                                                                                                                                   │
│     _cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);                                                                                        │
│     _lastRefresh = timestamp;                                                                                                                                                                                   │
│     emit CumulativeRateUpdated(_timeElapsed, _cumulativeRate);                                                                                                                                                  │
│   }                                                                                                                                                                                                             │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────────────── Response ────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ `_cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);`                                                                                          │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
[12/08/24 19:57:57] ERROR    tasks: Static analysis failed: Invalid args                                                                                                                               tasks.py:258
                    ERROR    tasks: Current File: /home/owen/Documents/GitHub/GPTScan-Bigger-Model/datasets/code-423n4-Web3Bugs-data/2022-04-mimo-main/contracts/inception/InceptionVaultsCore.sol,    tasks.py:260
                             current function: _refreshCumulativeRate, current vul: wrong-order-interest                                                                                                           
                    ERROR    tasks: Traceback (most recent call last):                                                                                                                                 tasks.py:262
                               File "/home/owen/Documents/GitHub/GPTScan-Bigger-Model/src/tasks.py", line 254, in simple_cli                                                                                       
                                 res_1 = static_check.run_static_check(checker, args, function1, falcon_instance,                                                                                                  
                             UnboundLocalError: local variable 'falcon_instance' referenced before assignment                                                                                                      
                                                                                                                                                                                                                   
                      Scan Results                       
┏━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓
┃ Type ┃ Description ┃ Affected Files ┃ Analysis Report ┃
┡━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩
└──────┴─────────────┴────────────────┴─────────────────┘
                  Summary                   
┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓
┃ Key                  ┃ Value             ┃
┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━┩
│ Files                │ 143               │
│ Contracts            │ 146               │
│ Functions            │ 217               │
│ Lines of Code        │ 12550             │
│ Used Time            │ 317.4491436481476 │
│ Estimated Cost (USD) │ 0.175203          │
└──────────────────────┴───────────────────┘
